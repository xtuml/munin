= Enhance Logging with `log4cplus`

xtUML Project Analysis Note

== 1 Abstract

This note outlines enhancements to the practice of logging in the Munin
Protocol Verifier application.

== 2 Introduction and Background

Until January 2024, the MASL C{plus}{plus} model compiler <<dr-2>> used POCO
<<dr-3>> as the underlying logging technology.  Now MASL uses
`log4cplus` <<dr-4>>.  `log4cplus` provides more functionality and is
consistent with `log4j`, which is a popular logging framework for Java.

During testing of the Protocol Verifier, it was noted that the POCO logger
was using more memory than expected.  This was the trigger to change
logging technologies.

`log4cplus` is a bit different.  It makes sense to revisit the logging
strategy employed by the Munin project in the Protocol Verifier.  This
note will outline a Way Forward.

The primary requirements for what to log come from the requirements for
reporting which are documented in <<dr-5>>.  It is noted that logging and
reporting are closely related.  If requirements change for reporting, it
is helpful if a configuration change to the logging can supply the needed
extra reporting information.

=== 2.1 Logging Best Practices

As preparation for enhancing logging, a few published "Best Practice"
guides were studied.  We will take the opportunity in Munin to adopt/apply
some of these practices while we are changing to the `log4*` idiom of
logging.

The first Best Practice to logging is to author a mission statement for
the logging and proceed from there.  This aligns with Shlaer-Mellor
domain modelling quite nicely.

== 3 Requirements

. Establish a Project Munin logging mission statement to guide decision
  making.
. Make reporting flow from logging.
. Support logging levels:
  ** Fatal
  ** Error
  ** Warning
  ** Information
  ** Debug
  ** Trace
. Support conditional log message string arithmetic.
. Establish conventions for enabled logging.
. Support logger hierarchy.
. Establish naming conventions for logger hierarchy.
. Establish rules and guidelines for the construction of log messages.
. Facilitate machine parsing of log messages (using structured logging).
  TODO: Consider the format that Prometheus supports.
. Identify tooling that will be used to harvest the log data.
. Protect privacy and security by logging application-level information
  judiciously.

== 4 Analysis

=== 4.1 Munin Logging Mission Statement

* Munin software shall log information critical to the verification of protocols.
  This includes detection of alarms, failures and successes.
* Munin software shall be instrumented to enable the measurement of the
  performance of the Protocol Verifier application itself (benchmarking).
* Munin software shall be instrumented sparingly with debug statements
  adequate for defect isolation (debugging).
* The volume of production-level logging shall not exceed the volume of
  production audit event traffic.

=== 4.2 Breakdown of Application Traffic

The Protocol Verifier monitors devices through telemetry.  There are two
levels of detail in this telemetry, that of a _job_ and that of an
_event_.  In general, the user is interested in the status of a job.
Events are interesting only when they are erroneous.  Summaries of
aggratated events are interesting in terms of throughput.

=== 4.3 Job Logging

The primary deliverable log entry is the final status of a job.  A job
completes with status _successful_, _failed_ or _alarm_.  Together with
the job type (name) and identifier, this is the key status provided by the
Protocol Verifier.  Failed and alarmed jobs must also report internal
state satisfactory to understanding failure modes in application-level
jobs in the system being monitored.  Canonical logging practices shall be
applied to facilitate problem determination for failed and alarmed jobs.

To provide canonical log messages once and only once per job, information
about the job and events will be accumulated in instance attributes of the
modelled artefacts.  At the end of the job, the accumulated information
will be structured and delivered to the logger.

==== 4.3.1 Job-Level Statistics for Successful Jobs

For successful jobs, the following shall be reported:

* job type (name)
* job identifier
* event count

This job status report shall be logged exactly once at completion of the
job.  This information shall be contained in a single structured log
message.

The recommended location of this logging is in Sequence Verification.

==== 4.3.2 Job-Level Statistics for Failures and Alarms

For failed and alarmed jobs, the following statistics are required:

* job type (name)
* job identifier
* event count
* failure/alarm mode
* event trace
  ** event type (name)
  ** event identifier
  ** ordering

=== 4.4 Event Logging

Logging at the event level is largely infeasible and unnecessary in
production configurations.  However, in anticipation of performance
benchmarking, some event-level statistics shall be gathered in summary
format.

==== 4.4.1 Event Statistics

=== 4.5 Protocol Verifier Statistics

Several parameters are useful in the maintenance and support of the
Protocol Verifier.

The following statistics are reported as they happen.

* worker registered
* worker deregistered
* unassigned job count exceeded
  ** job count exceeded is reported once upon occurrence and then only
     reported again if the job count goes below the threshold.

The following statistic are reported periodically.

* event count since start
* event throughput
* worker count
* concurrent jobs at worker
* concurrent jobs overall
* unassigned jobs
* unassigned job count exceeded

This information shall be reported on a regular basis not exceeding once
per second (1 Hertz).

The recommended location of this logging is in Job Management.

=== 4.6 Logger Hierarchy

* The top-level logger shall be 'pv' (Protocol Verifier).
* Each domain shall have a logger.
  ** 'pv.jm':  Job Management
  ** 'pv.aeo':  Audit Event Ordering
  ** 'pv.sv':  Sequence Verification
  ** 'pv.istore':  Invariant Store
  ** 'pv.vg':  Verification Gateway
* Each domain shall define at least 2 loggers:  'job' and 'event'.
  ** 'pv.jm.job':  Job Management job logger
  ** 'pv.jm.event':  Job Management event logger
* Each domain may define lower-level loggers for specific purposes.
  ** 'pv.sv.happy':  Sequence Verification Happy module (class)
  ** 'pv.sv.unhappy':  Sequence Verification Unhappy module (class)
* A logger shall be defined for benchmarking.
  ** 'pv.benchmark':  throughput benchmark

== 5 Work Required

. Remove the reporting terminator and use loggers for reporting.
. Remove calls to AsyncLogger and use the new logging.
. Log a benchmark for each event as seen in Job Management and again in
  Sequence Verification.
. Update the source code in the domains to conditionalise logging.
. Update the source code in the domains to log canonically.
. Update the source code in the domains to avoid logging inside loops.
. Update the source code in the domains to adhere to the logger hierarchy
  and categories.
. Update the source code in the domains to use structured logging
  according to the prescribed conventions.

== 6 Acceptance Test

. Pass `regression.sh`.
. Run `run_benchmark.sh` and get as good or better performance.

=== 6.1 Data Volume Measurement

. `run_benchmark.sh` on old branch.  Measure the log data per unit time produced.
. `run_benchmark.sh` on new branch.  Measure the log data per unit time produced.
. Ensure that we are logging less data.  If not, understand why.

== 7 Document References

. [[dr-1]] https://github.com/xtuml/munin/issues/188[188 - Enhance Logging]
. [[dr-2]] https://github.com/xtuml/masl[MASL C{plus}{plus} Model Compiler GitHub Repository]
. [[dr-3]] https://pocoproject.org/[POCO Project]
. [[dr-4]] https://github.com/log4cplus/log4cplus[log4cplus]
. [[dr-5]] link:./189_reporting_ant.adoc[Enhance Reporting Analysis Note]

---

This work is licensed under the Creative Commons CC0 License

---
