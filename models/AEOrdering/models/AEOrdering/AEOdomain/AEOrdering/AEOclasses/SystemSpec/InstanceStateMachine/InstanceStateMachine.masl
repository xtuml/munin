//! ACTIVITY BEGIN. 'ff1e8b5d-11f3-496a-825a-79a87399f6d3' '2f5d88f3-93c0-4287-b943-38ef80510f15' DO NOT EDIT THIS LINE.
state AEOrdering::SystemSpec.Created () is
begin
  null;
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'ff1e8b5d-11f3-496a-825a-79a87399f6d3' '6429e330-5929-44e0-ac73-7a2be9959a84' DO NOT EDIT THIS LINE.
state AEOrdering::SystemSpec.ConfigChecked () is
logMessage : string;
fileStatus : Filesystem::file_status;
fileName : Filesystem::filename;

begin

	logMessage := "AEOrdering::SystemSpec.ConfigChecked";
	Logger::log(Logger::Information, "AEOrdering", logMessage);
	
	fileName := Filesystem::filename(this.configFilePath & this.configFile);
	if Filesystem::file_exists(fileName) then
		fileStatus := Filesystem::get_file_status(fileName);
		if fileStatus.modification_time /= this.configFileModificationTime then
			generate SystemSpec.loadConfig() to this;
		else
			schedule this.configTimer generate SystemSpec.checkConfigUpdate() to this delay this.specUpdateRate;
		end if;
		else
		logMessage := "AEOrdering::ConfigChecked, failed to locate config file. Specified file = " & this.configFilePath & this.configFile;
		Logger::log(Logger::Error, "AEOrdering", logMessage);
		raise program_error;
	end if;
	
exception
	when others => 	
	
		logMessage := "AEOrdering::SystemSpec.ConfigChecked, failed to load configuration file";
		Logger::log(Logger::Error, "AEOrdering", logMessage);
		
	
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'ff1e8b5d-11f3-496a-825a-79a87399f6d3' '2c9652a0-3e8f-4199-b65f-cee09cee74ea' DO NOT EDIT THIS LINE.
state AEOrdering::SystemSpec.ConfigUpdated () is
logMessage : string;
fileName : Filesystem::filename;
fileStatus : Filesystem::file_status;
jobType : instance of JobType;
configJSONString : string;
configJSONElement : JSON::JSONElement;
configJSONObject : JSON::JSONObject;
configValidationResult : JSON::JSONObject;
jobDefJSONObject : JSON::JSONObject;
jobDefinitionName : string;
jobTypeJSONString : string;
jobTypeJSONElement : JSON::JSONElement;
jobTypeValidationResult : JSON::JSONObject;
eventDataTypesJSONString : string;
eventDataTypesJSONElement : JSON::JSONElement;
userEvent : UserEventDataType;
emptyUserEvent : UserEventDataType;
userEvents : sequence of UserEventDataType;
emptyUserEvents : sequence of UserEventDataType;
associatedEvent : IntraJobInvDataType;
emptyAssociatedEvent : IntraJobInvDataType;
associatedEvents : sequence of IntraJobInvDataType;
emptyAssociatedEvents : sequence of IntraJobInvDataType;

begin
    
    logMessage := "AEOrdering::SystemSpec.ConfigUpdated";
    Logger::log(Logger::Information, "AEOrdering", logMessage);
    
    // check the config file has not been removed
    fileName := Filesystem::filename(this.configFilePath & this.configFile);
    if Filesystem::file_exists(fileName) then
        // read the contents of the config file 
        configJSONString := Filesystem::read_file(fileName);
        configJSONElement := JSON::parse(configJSONString);
        configValidationResult := JSONValidation::validate(configJSONElement, #PROP["orderingConfigSchema"]#);
        if JSON::get_boolean(configValidationResult["valid"]) then
            // extract the spec data items
            configJSONObject := JSON::get_object(configJSONElement);
            if configJSONObject'contains("SpecUpdateRate") then
                this.specUpdateRate := duration'parse(JSON::get_string(configJSONObject["SpecUpdateRate"]));
            end if;
            if configJSONObject'contains("MaxOutOfSequenceEvents") then
                this.maxOutOfSequenceEvents := JSON::get_integer(configJSONObject["MaxOutOfSequenceEvents"]);
            end if;
            if configJSONObject'contains("MaximumJobTime") then
                this.maximumJobTime := duration'parse(JSON::get_string(configJSONObject["MaximumJobTime"]));
            end if;
            if configJSONObject'contains("JobCompletePeriod") then
                this.jobCompletePeriod := duration'parse(JSON::get_string(configJSONObject["JobCompletePeriod"]));
            end if;
            if configJSONObject'contains("IncomingDirectory") then
                this.incomingDirectory := JSON::get_string(configJSONObject["IncomingDirectory"]);
                // check if the directory exists and if not create it
				if Filesystem::file_exists(Filesystem::filename(this.incomingDirectory)) = false then
					Filesystem::create_directory(Filesystem::filename(this.incomingDirectory));
				end if;
            end if;
            if configJSONObject'contains("ProcessingDirectory") then
                this.processingDirectory := JSON::get_string(configJSONObject["ProcessingDirectory"]);
                // check if the directory exists and if not create it
				if Filesystem::file_exists(Filesystem::filename(this.processingDirectory)) = false then
					Filesystem::create_directory(Filesystem::filename(this.processingDirectory));
				end if;
            end if;
            if configJSONObject'contains("ProcessedDirectory") then
                this.processedDirectory := JSON::get_string(configJSONObject["ProcessedDirectory"]);
                // check if the directory exists and if not create it
				if Filesystem::file_exists(Filesystem::filename(this.processedDirectory)) = false then
					Filesystem::create_directory(Filesystem::filename(this.processedDirectory));
				end if;
            end if;
            // read in the jobs that we expect to process
            if configJSONObject'contains("Jobs") and configJSONObject["Jobs"].kind = JSON::Array then
                for jobDefinitionElement in JSON::get_array(configJSONObject["Jobs"]) loop
                    jobDefJSONObject := JSON::get_object(jobDefinitionElement);
                    jobDefinitionName := JSON::get_string(jobDefJSONObject["JobDefinitionName"]);
                    jobType := find_one JobType(jobTypeName = jobDefinitionName);
                    if jobType = null then
                        jobType := create JobType(jobTypeName => jobDefinitionName, deprecated => false, Current_State => Created);
                        generate JobType.activateJobType() to jobType;
                    end if;
                    if jobDefJSONObject'contains("JobDeprecated") then
                        jobType.deprecated := JSON::get_boolean(jobDefJSONObject["JobDeprecated"]);
                        if jobType.deprecated = true then
                            jobType.jobTypeExpiryTime := timestamp'parse(JSON::get_string(jobDefJSONObject["JobTypeExpiryDate"]));
                            generate JobType.deprecateJobType() to jobType;
                        else
                            generate JobType.activateJobType() to jobType;
                        end if;
                    end if;
                    jobType.staleAuditEventDuration := duration'parse(JSON::get_string(jobDefJSONObject["StaleAuditEventDuration"]));
                    jobType.blockedAuditEventDuration := duration'parse(JSON::get_string(jobDefJSONObject["BlockedAuditEventDuration"]));

                    // load in the audit eventTypes
                    fileName := Filesystem::filename(this.configFilePath & jobType.jobTypeName & ".json");
                    if Filesystem::file_exists(fileName) then
                        jobTypeJSONString := Filesystem::read_file(fileName);
                        jobTypeJSONElement := JSON::parse(jobTypeJSONString);
                        jobTypeValidationResult := JSONValidation::validate(jobTypeJSONElement, #PROP["jobDefinitionSchema"]#);
                        if JSON::get_boolean(jobTypeValidationResult["valid"]) then
                            // extract the spec data items
                            jobType.loadEventTypes(JSON::get_object(jobTypeJSONElement));
                            // now adjust stale and blocked audit event durations
                            if jobDefJSONObject'contains("EventRules") and jobDefJSONObject["EventRules"].kind = JSON::Array then
                              jobType.updateAuditEventDurations(JSON::get_array(jobDefJSONObject["EventRules"]));
                            end if;
                        else
                            Logger::log(Logger::Debug, "AEReception", "Config file invalid:\n" & JSON::dump(jobTypeValidationResult, true));
                            raise JSON::JSONException("Config file invalid");
                        end if;
                    else
                        raise program_error;
                    end if;
                end loop;
            end if;
        else
            Logger::log(Logger::Debug, "AEOrdering", "Config file invalid:\n" & JSON::dump(configValidationResult, true));
            raise JSON::JSONException("Config file invalid");
        end if;
        
        // set the config file mod time
        fileName := Filesystem::filename(this.configFilePath & this.configFile);
        fileStatus := Filesystem::get_file_status(Filesystem::filename(fileName));
        this.configFileModificationTime := fileStatus.modification_time;
        
        // now check for any event data definition
        // TODO check the schema here
        for jobType in find JobType() loop
            fileName := Filesystem::filename(this.configFilePath & jobType.jobTypeName & "_event_data.json");
            if Filesystem::file_exists(fileName) then
                eventDataTypesJSONString := Filesystem::read_file(fileName);
                eventDataTypesJSONElement := JSON::parse(eventDataTypesJSONString);
                
                // extract the spec data items
                jobType.loadEventDataItemTypes(JSON::get_array(eventDataTypesJSONElement));
            end if;
        end loop;
        
        // report the latest set of events to the sequence domain
        for job in find JobType() loop
            for auditEventType in (job -> R12.AuditEventType() ordered_by (auditEventTypeId)) loop
                Req_IF_Verification~>eventDefinition(auditEventType.jobTypeName, auditEventType.sequenceName, auditEventType.eventType, auditEventType.occurrenceId, 
                	                                 auditEventType.previousEventTypes, auditEventType.isSequenceStart, auditEventType.isSequenceEnd, auditEventType.isBreak);
            end loop;
            // report any dynamic controls
            for dynamicControl in (job -> R12.AuditEventType -> R19.DynamicControl) loop
            	Req_IF_Verification~>dynamicControlDefinition(job.jobTypeName, dynamicControl.dynamicControlName, dynamicControl.controlType, dynamicControl.eventType, dynamicControl.occurrenceId, dynamicControl.userEventType, dynamicControl.userOccurrenceId);
            end loop;
        end loop;
        
        // report the latest set of extra job inv event data to the sequence domain
        for dataItemType in find DataItemType(dataItemType = "EXTRAJOBINV") loop
            if dataItemType -> R18.isConstrainedBy.DataItemType = null then
                // build up the event data items
                userEvents := emptyUserEvents;
                for constrainedDataItem in dataItemType -> R18.constrains.DataItemType loop
                    userEvent := emptyUserEvent;
                    userEvent.jobDefinitionName := constrainedDataItem.jobTypeName;
                    userEvent.auditEventType := constrainedDataItem.eventType;
                    userEvent.occurrenceId := constrainedDataItem.occurrenceId;
                    userEvent.alternativeDataItemName := constrainedDataItem.dataItemName;
                    userEvents := userEvents & userEvent;
                end loop;
                Req_IF_Verification~>extraJobInvariantDefinition(dataItemType.dataItemName, dataItemType.jobTypeName, dataItemType.eventType, dataItemType.occurrenceId, userEvents);
            end if;
        end loop;

        // report the latest set of extra job inv event data to the sequence domain
        for dataItemType in find DataItemType(dataItemType = "INTRAJOBINV") loop
            if dataItemType -> R18.isConstrainedBy.DataItemType = null then
                // build up the event data items
                associatedEvents := emptyAssociatedEvents;
                for constrainedDataItem in dataItemType -> R18.constrains.DataItemType loop
                    associatedEvent := emptyAssociatedEvent;
                    associatedEvent.auditEventType := constrainedDataItem.eventType;
                    associatedEvent.occurrenceId := constrainedDataItem.occurrenceId;
                    associatedEvent.alternativeDataItemName := constrainedDataItem.dataItemName;
                    associatedEvents := associatedEvents & associatedEvent;
                end loop;
                Req_IF_Verification~>intraJobInvariantDefinition(dataItemType.dataItemName, dataItemType.jobTypeName, associatedEvents);
            end if;
        end loop;

        // schedule to check the config file
        schedule this.configTimer generate SystemSpec.checkConfigUpdate() to this delay this.specUpdateRate;
    else
        logMessage := "AEOrdering::ConfigUpdated, failed to locate config file. Specified file = " & this.configFilePath & this.configFile;
        Logger::log(Logger::Error, "AEOrdering", logMessage);
        raise program_error;
    end if;
    
exception
    when program_error =>
        logMessage := "AEOrdering::SystemSpec.ConfigUpdated, failed to load configuration file";
        Logger::log(Logger::Error, "AEOrdering", logMessage);
        raise program_error;
    when others =>     
    
        logMessage := "AEOrdering::SystemSpec.ConfigUpdated, failed to load configuration file";
        Logger::log(Logger::Error, "AEOrdering", logMessage);
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

