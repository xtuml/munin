//! ACTIVITY BEGIN. '04749b6a-860c-4585-9214-393ebbdb0cc4' DO NOT EDIT THIS LINE.
public instance service AEOrdering::SystemSpec.lastModificationTime () return timestamp is
fileName: Filesystem::filename;
fileStatus: Filesystem::file_status;
mostRecentModificationTime: timestamp;
logMessage: string;
begin
    fileName := Filesystem::filename(this.configFilePath & this.configFile);
    if Filesystem::file_exists(fileName) then
        fileStatus := Filesystem::get_file_status(fileName);
        mostRecentModificationTime := fileStatus.modification_time;
    else
        logMessage := "AEOrdering::lastModificationTime : failed to locate config file. Specified file = " & this.configFilePath & this.configFile;
        Logger::log(Logger::Error, "AEOrdering", logMessage);
        raise program_error;
    end if;
    if Filesystem::file_exists(Filesystem::filename(this.jobDefinitionDirectory)) then
        for jobDefinitionFile in Filesystem::list_directory(Filesystem::filename(this.jobDefinitionDirectory)) loop
            if Strings::ends_with(jobDefinitionFile, ".json") then
                fileName := Filesystem::filename(this.jobDefinitionDirectory & "/" & string(jobDefinitionFile));
                fileStatus := Filesystem::get_file_status(fileName);
                if fileStatus.modification_time > mostRecentModificationTime then
                    mostRecentModificationTime := fileStatus.modification_time;
                end if;
            end if;
        end loop;
    end if;
    return mostRecentModificationTime;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '09b64602-e158-4716-a9b1-a304ca456f4f' DO NOT EDIT THIS LINE.
public instance service AEOrdering::SystemSpec.checkUpdatedConfig () return boolean is
logMessage : string;
fileName : Filesystem::filename;
fileStatus : Filesystem::file_status;
jobType : instance of JobType;
jobTypeUpdate : JobDefinitionFileType;
configUpdates : boolean := false;

begin
    fileName := Filesystem::filename(this.configFilePath & this.configFile);
    if Filesystem::file_exists(fileName) then
        fileStatus := Filesystem::get_file_status(fileName);
	    if this.configFileModificationTime /= fileStatus.modification_time then
    	    this.configFileModificationTime := fileStatus.modification_time;
    	    configUpdates := true;
    	end if;
    else
        logMessage := "AEOrdering::locateUpdatedConfig : failed to locate config file. Specified file = " & this.configFilePath & this.configFile;
        Logger::log(Logger::Error, "AEOrdering", logMessage);
    end if;
    if configUpdates = true then
    	return true; 
    else
    	return false;
    end if;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '1976b22d-34c9-4df2-a045-4c41c0c7149d' DO NOT EDIT THIS LINE.
public instance service AEOrdering::SystemSpec.loadConfigFile () is
logMessage : string;
fileName : Filesystem::filename;
configJSONString : string;
configJSONElement : JSON::JSONElement;
configJSONObject : JSON::JSONObject;
configValidationResult : JSON::JSONObject;
jobStoreLocation : string := "./";
jobStoreAgeLimit : duration := @P7D@;
jobStore : instance of JobStore;
jobStoreName : string := "JobIdStore.log";
invariantStoreLoadRate : duration;
maxIntraSequenceEventTimeoutPeriod : duration := @PT1S@;
waitPeriodForAllJobsCompletedCheck : duration := @P1D@;
waitPeriodForJobDeletion : duration := @PT30M@;
waitPeriodForInvariantDeletion : duration := @P1D@;
timeoutPeriodForRetreivingStoredInvariants : duration := @PT10S@;              
timeoutPeriodForHangingJob : duration := @PT15S@;

begin
    
    // check the config file has not been removed
    fileName := Filesystem::filename(this.configFilePath & this.configFile);
    if Filesystem::file_exists(fileName) then
        // read the contents of the config file 
        configJSONString := Filesystem::read_file(fileName);
        configJSONElement := JSON::parse(configJSONString);
        configValidationResult := JSONValidation::validate(configJSONElement, Environment::getenv(Environment::variable_name("ORDERING_CONFIG_SCHEMA_PATH")));
        if JSON::get_boolean(configValidationResult["valid"]) then
            // extract the spec data items
            configJSONObject := JSON::get_object(configJSONElement);
            if configJSONObject'contains("SpecUpdateRate") then
                this.specUpdateRate := duration'parse(JSON::get_string(configJSONObject["SpecUpdateRate"]));
            end if;
            if configJSONObject'contains("MaxOutOfSequenceEvents") then
                this.maxOutOfSequenceEvents := integer'parse(JSON::get_string(configJSONObject["MaxOutOfSequenceEvents"]));
            end if;
            if configJSONObject'contains("MaximumJobTime") then
                this.maximumJobTime := duration'parse(JSON::get_string(configJSONObject["MaximumJobTime"]));
            end if;
            if configJSONObject'contains("JobCompletePeriod") then
                this.jobCompletePeriod := duration'parse(JSON::get_string(configJSONObject["JobCompletePeriod"]));
            end if;
            if configJSONObject'contains("JobDefinitionDirectory") then
                this.jobDefinitionDirectory := JSON::get_string(configJSONObject["JobDefinitionDirectory"]);
            end if;
            if configJSONObject'contains("DefaultJobExpiryDuration") then
                this.defaultJobExpiryDuration := duration'parse(JSON::get_string(configJSONObject["DefaultJobExpiryDuration"]));
            end if;
            if configJSONObject'contains("DefaultStaleAuditEventDuration") then
                this.defaultStaleAuditEventDuration := duration'parse(JSON::get_string(configJSONObject["DefaultStaleAuditEventDuration"]));
            end if;
            if configJSONObject'contains("DefaultBlockedAuditEventDuration") then
                this.defaultBlockedAuditEventDuration := duration'parse(JSON::get_string(configJSONObject["DefaultBlockedAuditEventDuration"]));
            end if;
            if configJSONObject'contains("JobStoreLocation") then
                jobStoreLocation := JSON::get_string(configJSONObject["JobStoreLocation"]);
                if not Filesystem::file_exists(Filesystem::filename(jobStoreLocation)) then
                  Filesystem::create_directory(Filesystem::filename(jobStoreLocation));
                end if;
            end if;
            if configJSONObject'contains("JobStoreAgeLimit") then
                jobStoreAgeLimit := duration'parse(JSON::get_string(configJSONObject["JobStoreAgeLimit"]));
            end if;
            if configJSONObject'contains("InvariantStoreLoadRate") then
                invariantStoreLoadRate := duration'parse(JSON::get_string(configJSONObject["InvariantStoreLoadRate"]));
                if this.invariantStoreLoadRate /= invariantStoreLoadRate then
                	this.invariantStoreLoadRate := invariantStoreLoadRate;
                	Req_IF_InvariantStore~>setLoadRate(this.invariantStoreLoadRate);
                end if;
            end if;
            if configJSONObject'contains("MaxIntraSequenceEventTimeoutPeriod") then
				maxIntraSequenceEventTimeoutPeriod := duration'parse(JSON::get_string(configJSONObject["MaxIntraSequenceEventTimeoutPeriod"]));
			end if;
            if configJSONObject'contains("WaitPeriodForAllJobsCompletedCheck") then
				waitPeriodForAllJobsCompletedCheck := duration'parse(JSON::get_string(configJSONObject["WaitPeriodForAllJobsCompletedCheck"]));
			end if;
            if configJSONObject'contains("WaitPeriodForJobDeletion") then
				waitPeriodForJobDeletion := duration'parse(JSON::get_string(configJSONObject["WaitPeriodForJobDeletion"]));
			end if;
            if configJSONObject'contains("WaitPeriodForInvariantDeletion") then
				waitPeriodForInvariantDeletion := duration'parse(JSON::get_string(configJSONObject["WaitPeriodForInvariantDeletion"]));
			end if;
            if configJSONObject'contains("TimeoutPeriodForRetreivingStoredInvariants") then
				timeoutPeriodForRetreivingStoredInvariants    := duration'parse(JSON::get_string(configJSONObject["TimeoutPeriodForRetreivingStoredInvariants"]));           
			end if;
            if configJSONObject'contains("TimeoutPeriodForHangingJob") then
				timeoutPeriodForHangingJob := duration'parse(JSON::get_string(configJSONObject["TimeoutPeriodForHangingJob"]));
			end if;
			
			// report the verification timer controls 
			Req_IF_Verification~>reportVerificationTimerControls(maxIntraSequenceEventTimeoutPeriod, waitPeriodForAllJobsCompletedCheck,
				                                                 waitPeriodForJobDeletion, waitPeriodForInvariantDeletion,
				                                                 timeoutPeriodForRetreivingStoredInvariants, timeoutPeriodForHangingJob);
        else
            logMessage := "AEOrdering::SystemSpec.ConfigUpdated : Config file invalid:\n" & JSON::dump(configValidationResult, true);
            Logger::log(Logger::Debug, "AEOrdering", logMessage);
            raise JSON::JSONException("Config file invalid");
        end if;
        // set the config file mod time
        this.configFileModificationTime := this.lastModificationTime();        
    else
        logMessage := "AEOrdering::ConfigUpdated : failed to locate config file. Specified file = " & this.configFilePath & this.configFile;
        Logger::log(Logger::Error, "AEOrdering", logMessage);
    end if;
    
    // if the job store does not exist then create it
    jobStore := find_one JobStore();
    if jobStore = null then
    	jobStoreName := "JobIdStore" & "-" &  this.startJobGroup'image & "-" & this.endJobGroup'image;
    	jobStoreLocation := jobStoreLocation & "/" & this.startJobGroup'image & "-" & this.endJobGroup'image;
    	Filesystem::create_directory(Filesystem::filename(jobStoreLocation));
    	jobStore := create JobStore(jobStoreName => jobStoreName, jobStoreLocation => jobStoreLocation, jobStoreAgeLimit => jobStoreAgeLimit, fileStoreCreationTime => timestamp'now, Current_State => Created);
    	JobStore.loadJobStore();
    end if;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '4fb59be1-16d5-495d-91b8-e131f269a1ab' DO NOT EDIT THIS LINE.
public instance service AEOrdering::SystemSpec.checkUpdatedJobDefinitions ( updatedJobDefinitions : out sequence of JobDefinitionFileType ) is
logMessage : string;
fileName : Filesystem::filename;
fileStatus : Filesystem::file_status;
jobType : instance of JobType;
jobTypeUpdate : JobDefinitionFileType;

begin
    if Filesystem::file_exists(Filesystem::filename(this.jobDefinitionDirectory)) then
        for jobDefinitionFile in Filesystem::list_directory(Filesystem::filename(this.jobDefinitionDirectory)) loop
            if Strings::ends_with(jobDefinitionFile, ".json") then
                fileName := Filesystem::filename(this.jobDefinitionDirectory & "/") & jobDefinitionFile;
                fileStatus := Filesystem::get_file_status(fileName);
                jobType := find_one JobType(jobDefinitionFileName = fileName);
                if jobType /= null then
                	// job already exists so check if it has been updated
    	            if fileStatus.modification_time > jobType.modificationTime then
        	            jobTypeUpdate.lastModificationTime := fileStatus.modification_time;
        	            jobTypeUpdate.jobDefinitionFileName := string(fileName);
        	            updatedJobDefinitions := updatedJobDefinitions & jobTypeUpdate;
            	    end if;
            	else
            		jobTypeUpdate.lastModificationTime := fileStatus.modification_time;
        	        jobTypeUpdate.jobDefinitionFileName := string(fileName);
      	            updatedJobDefinitions := updatedJobDefinitions & jobTypeUpdate;
            	end if;
            end if;
        end loop;
    else
        logMessage := "AEOrdering::locateUpdatedConfig : failed to locate job definition directory. Specified directory = " & this.jobDefinitionDirectory;
        Logger::log(Logger::Error, "AEOrdering", logMessage);
    end if;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '20792409-ecb1-4461-a693-09b0cc215a06' DO NOT EDIT THIS LINE.
public instance service AEOrdering::SystemSpec.loadJobDefinitions ( updatedJobDefinitions : out sequence of JobDefinitionFileType ) is
logMessage : string;
jobType : instance of JobType;
jobTypeJSONString : string;
jobTypeJSONElement : JSON::JSONElement;
jobTypeValidationResult : JSON::JSONObject;
jobTypeJSONObject : JSON::JSONObject;
userEvent : UserEventDataType;
emptyUserEvent : UserEventDataType;
userEvents : sequence of UserEventDataType;
emptyUserEvents : sequence of UserEventDataType;
associatedEvent : IntraJobInvDataType;
emptyAssociatedEvent : IntraJobInvDataType;
associatedEvents : sequence of IntraJobInvDataType;
emptyAssociatedEvents : sequence of IntraJobInvDataType;
constrainingDataItem : instance of DataItemType;
constrainingDataItemName : string;
intraJobInvDataItems : set of instance of DataItemType;
updatedJobTypes : sequence of instance of JobType;
eventDefinitions : sequence of EventDefinitionType;
emptyEventDefinitions : sequence of EventDefinitionType;

begin
    // process job definitions
    for jobDefinitionFile in updatedJobDefinitions loop
    	if Filesystem::file_exists(Filesystem::filename(jobDefinitionFile.jobDefinitionFileName)) then
            // if the file extension is ".json", assume the file is a job definition
            if Strings::ends_with(jobDefinitionFile.jobDefinitionFileName, ".json") then
                jobTypeJSONString := Filesystem::read_file(Filesystem::filename(jobDefinitionFile.jobDefinitionFileName));
                jobTypeJSONElement := JSON::parse(jobTypeJSONString);
                jobTypeValidationResult := JSONValidation::validate(jobTypeJSONElement, Environment::getenv(Environment::variable_name("JOB_DEFINITION_SCHEMA_PATH")));
                if JSON::get_boolean(jobTypeValidationResult["valid"]) then
                    jobTypeJSONObject := JSON::get_object(jobTypeJSONElement);
                    // find or create the job
                    jobType := find_one JobType(jobTypeName = JSON::get_string(jobTypeJSONObject["JobDefinitionName"]));
                    if jobType = null then
                        jobType := create JobType(
                            jobTypeName => JSON::get_string(jobTypeJSONObject["JobDefinitionName"]),
                            deprecated => false,
                            jobTypeExpiryTime => timestamp'now + this.defaultJobExpiryDuration,
                            staleAuditEventDuration => this.defaultStaleAuditEventDuration,
                            blockedAuditEventDuration => this.defaultBlockedAuditEventDuration,
                            jobDefinitionFileName => Filesystem::filename(jobDefinitionFile.jobDefinitionFileName),
                            modificationTime => jobDefinitionFile.lastModificationTime,
                            Current_State => Created
                        );
						if jobTypeJSONObject'contains("JobDeprecated") then
							jobType.deprecated := boolean'parse(JSON::get_string(jobTypeJSONObject["JobDeprecated"]));
						end if;
						if jobTypeJSONObject'contains("JobTypeExpiryDate") then
							jobType.jobTypeExpiryTime := timestamp'parse(JSON::get_string(jobTypeJSONObject["JobTypeExpiryDate"]));
						end if;
						if jobTypeJSONObject'contains("StaleAuditEventDuration") then
							jobType.staleAuditEventDuration := duration'parse(JSON::get_string(jobTypeJSONObject["StaleAuditEventDuration"]));
						end if;
						if jobTypeJSONObject'contains("BlockedAuditEventDuration") then
							jobType.blockedAuditEventDuration := duration'parse(JSON::get_string(jobTypeJSONObject["BlockedAuditEventDuration"]));
						end if;
                        generate JobType.activateJobType() to jobType;
                    end if;
                    // extract the spec data items
                    jobType.loadEventTypes(JSON::get_object(jobTypeJSONElement));
                    // TODO update event specific rules
                    updatedJobTypes := updatedJobTypes & jobType;
                else
                    logMessage := "AEOrdering::SystemSpec.ConfigUpdated : Job definition file invalid: " & jobDefinitionFile.jobDefinitionFileName & "\n" & JSON::dump(jobTypeValidationResult, true);
                    Logger::log(Logger::Debug, "AEOrdering", logMessage);
                    raise JSON::JSONException("Job definition file invalid");
                end if;
            end if;
        end if;
	end loop;
	
    // resolve data item forward references
    for dataItemForwardRef in find SourceDataItemForwardReference() loop
        dataItemForwardRef.resolve();
    end loop;
    
    // report the latest set of events to the sequence domain
    for job in find updatedJobTypes() loop
    	eventDefinitions := emptyEventDefinitions;
    	associatedEvents := emptyAssociatedEvents;
        for auditEventType in (job -> R12.AuditEventType() ordered_by (auditEventTypeId)) loop
            eventDefinitions := eventDefinitions & (auditEventType.sequenceName, auditEventType.eventType, auditEventType.occurrenceId, 
            	                                 auditEventType.previousEventTypes, auditEventType.isSequenceStart, auditEventType.isSequenceEnd, 
            	                                 auditEventType.isBreak, auditEventType.isSequenced, auditEventType.critical);
        end loop;
        Req_IF_Verification~>jobDefinition(job.jobTypeName, eventDefinitions);
        // report any dynamic controls
        for dynamicControl in (job -> R12.AuditEventType -> R19.DynamicControl) loop
        	Req_IF_Verification~>dynamicControlDefinition(job.jobTypeName, dynamicControl.dynamicControlName, dynamicControl.controlType, dynamicControl.eventType, dynamicControl.occurrenceId, dynamicControl.userEventType, dynamicControl.userOccurrenceId);
        end loop;
        
        // report the latest set of intra job inv event data to the sequence domain
        intraJobInvDataItems := job -> R14.DataItemType(dataItemType = "INTRAJOBINV");
        if intraJobInvDataItems'length > 0 then
	        for dataItemType in intraJobInvDataItems loop
	        	associatedEvent := emptyAssociatedEvent;
	            associatedEvent.auditEventType := dataItemType.eventType;
	            associatedEvent.occurrenceId := dataItemType.occurrenceId;
	            associatedEvent.alternativeDataItemName := dataItemType.dataItemName;
	            associatedEvents := associatedEvents & associatedEvent;
	            constrainingDataItem := dataItemType -> R18.isConstrainedBy.DataItemType;
	            if constrainingDataItem /= null then
	               constrainingDataItemName := constrainingDataItem.dataItemName;
	           end if;
	        end loop;
            Req_IF_Verification~>intraJobInvariantDefinition(constrainingDataItemName, job.jobTypeName, associatedEvents);
         end if;
    end loop;
        
    // report the latest set of extra job inv event data to the sequence domain
    for dataItemType in find DataItemType(dataItemType = "EXTRAJOBINV") loop
        if dataItemType -> R18.isConstrainedBy.DataItemType = null then
            // build up the event data items
            userEvents := emptyUserEvents;
            for constrainedDataItem in dataItemType -> R18.constrains.DataItemType loop
                userEvent := emptyUserEvent;
                userEvent.jobDefinitionName := constrainedDataItem.jobTypeName;
                userEvent.auditEventType := constrainedDataItem.eventType;
                userEvent.occurrenceId := constrainedDataItem.occurrenceId;
                userEvent.alternativeDataItemName := constrainedDataItem.dataItemName;
                userEvents := userEvents & userEvent;
            end loop;
            Req_IF_Verification~>extraJobInvariantDefinition(dataItemType.dataItemName, dataItemType.jobTypeName, dataItemType.eventType, dataItemType.occurrenceId, userEvents);
        end if;
    end loop;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

