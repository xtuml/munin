//! ACTIVITY BEGIN. '74d12669-f0f1-4050-8f62-08b090fb01ce' DO NOT EDIT THIS LINE.
public service AEOrdering::AcceptEvent ( jobId : in string,
                                        jobName : in string,
                                        auditEventType : in string,
                                        auditEventId : in string,
                                        auditEventTime : in string,
                                        prevAuditEventIds : in sequence of string,
                                        auditEventData : in AuditEventDataType ) is
logMessage : string;
job : instance of Job;
inProgressJob : instance of InProgressJob;
failedJob : instance of FailedJob;
auditEvent : instance of AuditEvent;
jobFailureReason : string;
failureReason : string;
systemSpec : instance of SystemSpec;
eventContent : string;
rawJobId : UUID::raw_uuid;
lane : integer;
instrumentationEventId : string;
instrumentationEventType : string;

begin

	logMessage := "AEOrdering::AcceptEvent : jobId = " & jobId & ", auditEventType = " & auditEventType & ", auditEventId = " & auditEventId;
	Logger::log(Logger::Debug, "AEOrdering", logMessage);
	systemSpec := find_one SystemSpec();
	rawJobId := UUID::extract_raw(UUID::formatted_uuid(jobId));
	lane := integer(rawJobId[rawJobId'last]);
	if lane >= systemSpec.startJobGroup and lane <= systemSpec.endJobGroup then
	
		job := find_one Job(jobId = jobId);
		if job = null then
			job := create Job(jobId => jobId, outOfSequenceEventCount => 0, jobStartTime => timestamp'now, totalOutOfSequence => 0, maxOutOfSequence => 0, reportedJobName => jobName, Current_State => Created);
			if find_one JobType(jobTypeName = jobName) /= null then
				inProgressJob := create InProgressJob(jobId => job.jobId);
				link inProgressJob R2 job;
				generate Job.jobStarted() to job;
				eventContent := "JobId = " & job.jobId;
				Reporting~>reportEvent(Logger::Information, "aeordering_job_processed", eventContent);
				// ...and then report that AEO has started processing a new job as part of the 
	        		// verification of the Protocol Verifier itself.
	        		instrumentationEventId := "Unused";
	        		instrumentationEventType := "AEO_PVJobStart";
	        		Req_IF_BehaviourVerification~>sendInstrumentationEvent("ProtocolVerifier", job.jobId, instrumentationEventId, instrumentationEventType);
			else
				// we have created the job but the reported job name does not match a known JobType
				// so we need to fail the job
				failedJob := create FailedJob(jobId => job.jobId, failureReason => "Invalid job name supplied", jobFailureTime => timestamp'now);
				failureReason := "JobId = " & job.jobId & "FailureReason = Invalid job name supplied, jobName = " & jobName;
				link failedJob R2 job;
				generate Job.jobFailed() to job;
			end if;
		end if;
		
		// create the audit event
		if job -> R2.FailedJob /= null then
			jobFailureReason := "JobId = " & job.jobId & " : FailureReason = Job has failed";
		elsif job -> R2.ArchivedJob /= null then
			jobFailureReason := "JobId = " & job.jobId & " : FailureReason = Job is already archived";
		end if;
		auditEvent := AuditEvent.createAuditEvent(job, jobName, auditEventType, auditEventId, auditEventTime, prevAuditEventIds, auditEventData, failureReason);
		
		// check if the audit event is blocked
		if auditEvent = null or job -> R2.ArchivedJob /= null or job -> R2.FailedJob /= null then
			job.failJob(jobFailureReason);
		elsif auditEvent -> R4.BlockedAuditEvent /= null then
			link auditEvent R1 job;
			job.outOfSequenceEventCount := (job -> R1.AuditEvent)'length;
			// if this out of sequence event count is higher than the current max out of sequence then update the current max out of sequence
			if job.outOfSequenceEventCount > job.maxOutOfSequence then
				job.maxOutOfSequence := job.outOfSequenceEventCount;
			end if;
			// if we have exceeded the max out of sequence events then fail the job
			if job.outOfSequenceEventCount >= systemSpec.maxOutOfSequenceEvents then
				failureReason := "JobId = " & job.jobId & "FailureReason = Maximum out of sequence events reached, max = " & systemSpec.maxOutOfSequenceEvents'image;
				job.failJob(failureReason);
			end if;
			
		// check if we need to report a jobFailure
		elsif auditEvent -> R4.FailedAuditEvent /= null and job -> R2.InProgressJob /= null then
			job.failJob(failureReason);
		end if;
	end if;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd313277c-1d1c-4def-8303-bc6aa6b950dd' DO NOT EDIT THIS LINE.
public service AEOrdering::deleteJob ( jobId : in string ) is
instrumentationEventId : string;
instrumentationEventType : string;
logMessage : string;
theJob : instance of Job;

begin
  theJob := find_one Job(jobId = jobId);
  if theJob /= null then
    // Firstly, report that AEO has initiated the deletion of the Job (as part of 
    // the behaviour verification process of the Protocol Verifier itself). Note
    // that if the Job includes any blocked events at this point then the job
    // will be failed before eventually timing out any being deleted, otherwise
    // it can be immediately deleted.
    instrumentationEventId := "Unused";
    instrumentationEventType := "AEO_PVJobDeletionInitiated";
    Req_IF_BehaviourVerification~>sendInstrumentationEvent("ProtocolVerifier", jobId, instrumentationEventId, instrumentationEventType);

    // Then, check if the job has any blocked events and if so fail the job otherwise delete the job
	if (theJob -> R9.AuditEvent -> R4.BlockedAuditEvent)'length > 0 then
	  theJob.failJob("JobId = " & jobId & " : FailureReason = Job ended with blocked events");
    else  
	  theJob.jobDeleted();
	  Req_IF_Verification~>jobComplete(jobId);
    end if;
  else
    // TODO - Raise log message that reports that the specified job does not exist  
  end if;
	
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

