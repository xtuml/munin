//! ACTIVITY BEGIN. 'bb579c50-132b-494e-8018-81a7b4ca3778' '167ab2c4-e4fa-415a-a012-1eed723e4434' DO NOT EDIT THIS LINE.
state AEReception::Reception.starting () is
begin
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'bb579c50-132b-494e-8018-81a7b4ca3778' '00f732b9-8e05-41dc-a357-6bdce5e53842' DO NOT EDIT THIS LINE.
state AEReception::Reception.receiving_audit_event () is
logMessage: string;
element_received : JSON::JSONElement;
json_object: JSON::JSONObject;
validation_result: JSON::JSONObject;
event_received: boolean := false;
receptionSpec : instance of ReceptionSpec;
jobEventFileLocation : string;
eventContent : string;
jobId: string;
eventId: string := "UnknownID";

begin

    // We may get a node name or an event.
    element_received := this.jsonElements[this.currentIndex];
    receptionSpec := find_one ReceptionSpec();
    if element_received.kind = JSON::String then
        // If we received a node name, then we did not get the event.  Go get it.
        this.currentNodeName := JSON::get_string(element_received);

    elsif element_received.kind = JSON::Object then
        json_object := JSON::get_object(element_received);
        if json_object'keys'length = 1 and json_object'keys'any = "__comment__" then
            // ignore comment objects
            logMessage := "AEReception::Reception.receiving_audit_event : JSON comment: " & JSON::get_string(json_object[json_object'keys'any]);
	        Logger::log(Logger::Debug, "AEReception", "JSON comment: " & JSON::get_string(json_object[json_object'keys'any]));
        else
            // report the event received
            if json_object'contains("eventId") then
              	eventId := JSON::get_string(json_object["eventId"]);
            end if;
			eventContent := "EventId = " & eventId;
			Reporting~>reportEvent(Logger::Information, "reception_event_received", eventContent);

            // validate the event
            if this.validate then
            	validation_result := JSONValidation::validate(element_received, #PROP["auditEventSchema"]#);
				if JSON::get_boolean(validation_result["valid"]) = true then
					eventContent := "EventId = " & eventId;
					Reporting~>reportEvent(Logger::Information, "reception_event_valid", eventContent);
				else
					eventContent := "EventId = " & eventId;
					Reporting~>reportEvent(Logger::Error, "reception_event_invalid", eventContent);
					logMessage := "AEReception::Reception.receiving_audit_event : Dropping invalid event with ID: " & eventId & "\n" & JSON::dump(validation_result, true);
					Logger::log(Logger::Debug, "AEReception", logMessage);
				end if;
			end if;

			// only process valid events (or if validation is disabled)
			if this.validate = false or JSON::get_boolean(validation_result["valid"]) = true then
				// extract the job ID from the JSON structure
				jobId := JSON::get_string(json_object["jobId"]);
				
				// send the event along
				if this.currentNodeName = "" then
					logMessage := "AEReception::Reception.receiving_audit_event : Audit event with blank node name";
					Logger::log(Logger::Warning, "AEReception", logMessage);
				end if;
				
				// publish the event to ordering
				declare
				  prevIds: sequence of string;
				  evtData: dictionary;
				begin
					if json_object'contains("previousEventIds") then
						if json_object["previousEventIds"].kind = JSON::Array then
							for prev_id_json in JSON::get_array(json_object["previousEventIds"]) loop
								prevIds := prevIds & JSON::get_string(prev_id_json);
							end loop;
						elsif json_object["previousEventIds"].kind = JSON::String then
	                        prevIds := prevIds & JSON::get_string(json_object["previousEventIds"]);
	                    end if;
					end if;
					for key in json_object'keys loop
						if key /= "jobId" and
						   key /= "jobName" and
						   key /= "eventType" and
						   key /= "eventId" and
						   key /= "timestamp" and
						   key /= "previousEventIds" then
							if json_object[key].kind = JSON::String then
								evtData[key] := JSON::get_string(json_object[key]);
							else
								evtData[key] := JSON::dump(json_object[key]);
							end if;
						end if;
					end loop;
					Ordering~>AcceptEvent(
						JSON::get_string(json_object["jobId"]),
						this.currentNodeName,
						JSON::get_string(json_object["applicationName"]),
						JSON::get_string(json_object["eventType"]),
						JSON::get_string(json_object["eventId"]),
						JSON::get_string(json_object["timestamp"]),
						prevIds,
						evtData
					);
				end;
				
				this.eventsProcessed := this.eventsProcessed + 1;
				event_received := true;
        	end if;
        end if;

    else
	    logMessage := "AEReception::Reception.receiving_audit_event : Invalid JSON type: " & element_received.kind'image;
	    Logger::log(Logger::Error, "AEReception", logMessage);
		eventContent := "FailureReason = Invalid JSON type = " & element_received.kind'image;;
		Reporting~>reportEvent(Logger::Error, "reception_file_process_error", eventContent);
    end if;
    
    // process the next data item or finish
    this.currentIndex := this.currentIndex + 1;
    if this.currentIndex <= this.jsonElements'last then
        if event_received then
        	// check if have reached the max limit for events in the job event file.
        	if receptionSpec.maxEventsPerReceptionJob > 0 and this.eventsProcessed >= receptionSpec.maxEventsPerReceptionJob then
    			this.eventsProcessed := 0;
            	// only reschedule the throttle timer if an event was received
            	schedule this.throttleTimer generate Reception.ready_for_event() to this delay this.aeDelay;
            else
	            generate Reception.ready_for_event() to this;
            end if;
        else
            generate Reception.ready_for_event() to this;
        end if;
    else
        cancel this.throttleTimer;
        generate Reception.no_more_events() to this;
    end if;

end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'bb579c50-132b-494e-8018-81a7b4ca3778' 'af392d9f-ad3c-4926-8aee-c8e9eb8dffa9' DO NOT EDIT THIS LINE.
state AEReception::Reception.done () is
logMessage : string;
receptionSpec : instance of ReceptionSpec;

begin
	

	receptionSpec := find_one ReceptionSpec();
	// keep the reception job until the deletion timer fires
	this.receptionComplete := true;
	
	// schedule the deletion
	schedule this.deletionTimer generate Reception.reception_expired() to this delay receptionSpec.receptionDeletionTime;
	
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'bb579c50-132b-494e-8018-81a7b4ca3778' 'b800b83d-014a-4d72-9661-d34476c735a0' DO NOT EDIT THIS LINE.
state AEReception::Reception.parsing ( auditEvents : in string ) is
logMessage : string;
json_element: JSON::JSONElement;
eventContent : string;

begin

    // Read the file and parse
//	eventContent := "FileProcessed = " & this.filePath;;
//	Reporting~>reportEvent(Logger::Information, "reception_file_processed", eventContent);
    json_element := JSON::parse(auditEvents);
	if json_element.kind = JSON::Array then
        this.jsonElements := JSON::get_array(json_element);
        this.currentIndex := this.jsonElements'first;
        generate Reception.ready_for_event() to this;
    else
        logMessage := "AEReception::Reception.parsing : Incorrect JSON format : " & auditEvents;
        Logger::log(Logger::Error, "AEReception", logMessage);
		eventContent := "FailureReason = Incorrect JSON format = " & auditEvents;;
		Reporting~>reportEvent(Logger::Error, "reception_file_process_error", eventContent);
        generate Reception.parse_failed() to this;
    end if;

exception

    when JSON::JSONException =>
	   logMessage := "AEReception::Reception.parsing : Failed to parse JSON : " & auditEvents;
	   Logger::log(Logger::Error, "AEReception", logMessage);
		eventContent := "FailureReason = Failed to parse JSON = " & auditEvents;;
		Reporting~>reportEvent(Logger::Error, "reception_file_process_error", eventContent);
	   generate Reception.parse_failed() to this;
	   
	when others =>
	   logMessage := "AEReception::Reception.parsing : Could not process audit events : " & auditEvents;
	   Logger::log(Logger::Error, "AEReception", logMessage);
//		eventContent := "FailureReason = Could not read file = " & this.filePath;;
//		Reporting~>reportEvent(Logger::Error, "reception_file_process_error", eventContent);
	   generate Reception.parse_failed() to this;

end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'bb579c50-132b-494e-8018-81a7b4ca3778' 'cc64b9b1-baf2-4721-863b-afbb21126496' DO NOT EDIT THIS LINE.
state AEReception::Reception.ReceptionDeleted () is
begin
	
	// remove the reception
	delete this;
	
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

