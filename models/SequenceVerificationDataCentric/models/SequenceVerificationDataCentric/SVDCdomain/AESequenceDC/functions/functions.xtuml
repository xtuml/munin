// BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

within SequenceVerificationDataCentric::SVDCdomain::AESequenceDC is

	package functions is
		@function_num(2);
		function acceptOrderedEvent(ae_time: in string, app: in string, ae_type: in string, jobId: in string, prevAEIds: in sequence of string, id: in string, auditEventData: in sequence of auditEventDataStructure) is
			@noparse
			existingJob : instance of Job;
			theAuditEventDefinition : instance of AuditEventDefinition;
			theJobDefinition : instance of JobDefinition;
			logMessage : string;
			
			begin
			  // Check to see if the received event is part of a Job that is already being processed
			  existingJob := find_only Job (jobID = jobId);
			  if existingJob /= null then
			    //We have an existing Job and this event should be the next in sequence for that Job
			    generate Job.newEventForExistingJob (id, prevAEIds, ae_type, auditEventData) to existingJob;
			  else
			    // The received event must be for a new job, but before the event can be accepted we need to verify that 
			    // the JobDefinition for this new job is neither Suspended nor Deprecated (if it is, the event cannot be accepted)
			    theAuditEventDefinition := find_only AuditEventDefinition (AEType = ae_type);
			    if theAuditEventDefinition /= null then
			      // The ae_type is a known type - use this to find which JobDefinition it relates to and then verify that it is ACTIVE.
			      theJobDefinition := theAuditEventDefinition -> R1.AESequenceDefinition -> R7;
			      if (theJobDefinition.isSuspended = true) or (theJobDefinition.isDeprecated = true)then
			        // Log info: The accepted event is for a new Job that has a non-active JobDefinition 
			        logMessage := "The event - AuditEventId = " & id & "cannot be accepted because it relates to a new Job whose JobDefinition is either Suspended or Deprecated";
			        Logger::log(Logger::Information, "AESequenceDC", logMessage);        
			      else     
			        //We have a new job and this event should be tested as a valid initial event for a Job
			        //AuditEvent.AddEventForNewJob (jobId => jobId, eventID => id, prevEventId => prev, aeType => ae_type);
			        AuditEvent.AddEventForNewJob (jobId, id, prevAEIds, ae_type, auditEventData);
			      end;
			    else
			      // Log info: Report that the specified audit event type (ae_type) does not exist.
			      logMessage := "Accepted event is of an unknown type - AEType = " & ae_type;
			      Logger::log(Logger::Information, "AESequenceDC", logMessage); 
			    end if;
			  end if;
			  //
			  //
			  //
			end service;
			@endnoparse
		end function;

		@function_num(10);
		function createSVDCsystemSpec(maxIntraSequenceEventTimeoutPeriod: in duration, waitPeriodForAllJobsCompletedCheck: in duration, waitPeriodForJobDeletion: in duration, waitPeriodForInvariantDeletion: in duration, timeoutPeriodForRetreivingStoredInvariants: in duration) is
			@noparse
			theSVDCSystemSpec : instance of SystemSpecification;
			begin
			  theSVDCSystemSpec := create unique SystemSpecification (intraSequenceEventTimeoutPeriod => maxIntraSequenceEventTimeoutPeriod,
			  	                                                      checkJobDefReadyForDeletionPeriod => waitPeriodForAllJobsCompletedCheck,
			  	                                                      jobDeletionWaitPeriod => waitPeriodForJobDeletion,
			  	                                                      sourceExtraJobInvariantDeletionPeriod => waitPeriodForInvariantDeletion,
			  	                                                      persistentInvariantRestoreTimeoutPeriod => timeoutPeriodForRetreivingStoredInvariants);
			  //
			end service;
			@endnoparse
		end function;

		@function_num(8);
		function deleteJob(jobId: in string) is
			@noparse
			theJob : instance of Job;
			logMessage : string;
			
			begin
			
			  theJob := find_one Job (jobID = jobId);
			  if theJob /= null then
			    theJob.deleteJob();
			
			  else
			
			    logMessage := "jobId provided is unknown " & jobId;
				Logger::log(Logger::Information, "AESequenceDC", logMessage);
			      
			  end if;
			  //
			  //
			  //
			end service;
			@endnoparse
		end function;

		//! This service allows a Job Definition to be deprecated. In early versions this will simple result in deletion of the Job Defintion and its
		//! associated Sequence Definitions, Audit Events Definitions, etc. In due course this can be refuiend to check that there are no Jobs of that
		//! Job Definition currently in progress. If there are then these jobs should be allowed to complete. The Job Definition is then only removed
		//! when there are no in progress Jobs.
		@function_num(9);
		function deprecateJobDefinition(jobName: in string) is
			@noparse
			theJobDefn : instance of JobDefinition;
			logMessage : string;
			
			begin
			
			  // Move the JobDefinition into the 'Deprecated' state and wait for all outstanding Jobs of that 
			  // type to complete (either successful for fail) before automatically deleting it.
			  theJobDefn := find_one JobDefinition (jobName = jobName);
			  if theJobDefn /= null then
			    generate JobDefinition.deprecate() to theJobDefn;
			  else
			  
			    logMessage := "Job Definition specified for deprecation is unknown - jobName " & jobName;
				Logger::log(Logger::Information, "AESequenceDC", logMessage);
			  
			  end if;  
			end service;
			@endnoparse
		end function;

		@function_num(14);
		function dynamicControlDefinition(jobName: in string, dynamicControlName: in string, dynamicControlType: in dynamicControlTypeEnum, sourceEventType: in string, sourceOccurrenceId: in integer, userEventType: in string, userOccurrenceId: in integer) is
			@noparse
			// This function defines the dynamic control, which is a loop count or a branch count, together with the event
			// that provides it and the event that uses it. This function could be split such that the dynamic control is
			// set up with just the source event and the user event linked in later on in a different call to a different 
			// function.
			//
			
			begin
			  DynamicControlDefinition.createDynamicControlDefinition (jobName,
			  	                                                       dynamicControlName,
			  	                                                       dynamicControlType,
			  	                                                       sourceEventType,
			  	                                                       sourceOccurrenceId);
			  DynamicControlDefinition.linkUserEventDefn (jobName,
			  	                                          dynamicControlName,
			  	                                          dynamicControlType,
			  	                                          userEventType,
			  	                                          userOccurrenceId);
			  
			end service;
			@endnoparse
		end function;

		//! This service defines the specification instance for an Audit Event Definition.
		//! Each one of these refers to its previous Audit Event Definition to define the sequence.
		//! The first one in the sequence has no previous audit event definition and has the boolean isSequenceStartEvent set to true.
		//! The last one in the sequence does have a previous audit event definition and has the boolean isSequenceEndEvent set to true.
		//! Forks in the sequence are supported by multiple Audit Event Definitions having the same previous Audit Event Definition.
		//! Merges in the sequence could be supported by allowing multiple values in Previous Audit Event Definition
		@function_num(7);
		function eventDefinition(jobName: in string, sequenceName: in string, eventType: in string, occurrenceId: in integer, previousEventTypes: in sequence of eventStructure, isSequenceStart: in boolean, isSequenceEnd: in boolean, isBreak: in boolean) is
			@noparse
			theJobDefn : instance of JobDefinition;
			theSequenceDefn : instance of AESequenceDefinition;
			theEventDefn : instance of AuditEventDefinition;
			theEventDefnsInSequence : set of instance of AuditEventDefinition;
			matchingEventDefn : instance of AuditEventDefinition;
			thePrevEventDefn : instance of AuditEventDefinition;
			thePlaceholderEventDefn : instance of AuditEventDefinition;
			theEventInSeqDef : instance of AEInSequenceDefinition;
			thePlaceholderEventInSeqDef : instance of AEInSequenceDefinition;
			theEventOccInSeqDef : instance of AEOccurrenceInSequenceDefinition;
			thePlaceholderEventOccInSeqDef : instance of AEOccurrenceInSequenceDefinition;
			thePrevEventInSeqDefn : instance of AEInSequenceDefinition;
			thePrevEventOccInSeqDefn : instance of AEOccurrenceInSequenceDefinition;
			existingEventOccurrencesInSeqDefn : set of instance of AEOccurrenceInSequenceDefinition;
			newEventInSeqPairDef : instance of AEInSequencePairDefn;
			theConstraintDefn : instance of ConstraintDefinition;
			logMessage : string;
			previousEventType : eventStructure;
			
			//
			begin
			  theJobDefn := find_one JobDefinition (jobName = jobName);
			  if theJobDefn = null then
			    // Event Definition for new Job so create the Job Definition
			    theJobDefn := create unique JobDefinition (jobName => jobName, isDeprecated => false, isSuspended => false, Current_State => Active);
			  end if; 
			     
			  theSequenceDefn := find_one AESequenceDefinition (sequenceDefinitionName = sequenceName);
			  if theSequenceDefn = null then
			    // Event Definition for new Sequence so create the Sequence Definition
			    theSequenceDefn := create unique AESequenceDefinition (sequenceDefinitionName => sequenceName);
			    link theSequenceDefn R7 theJobDefn;
			  end if;
			   
			  theEventDefn := find_one AuditEventDefinition (AEType = eventType);
			  if theEventDefn = null then
			    // The event definition hasn't been seen before so is a valid addition
			    theEventDefn := create unique AuditEventDefinition (AEType => eventType); 
			    theEventInSeqDef := create AEInSequenceDefinition (AEDefinitionId => theEventDefn.AEDefinitionId, AESequenceId => theSequenceDefn.AESequenceId);
			    link theEventDefn R1 theSequenceDefn using theEventInSeqDef;
			    theEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (
			    	                                                            AEDefinitionId => theEventDefn.AEDefinitionId, 
			    	                                                            AESequenceId => theSequenceDefn.AESequenceId, 
			    	                                                            occurrenceNumberInSequence => occurrenceId, 
			    	                                                            isSequenceStart => isSequenceStart, 
			    	                                                            isSequenceEnd => isSequenceEnd,
			                                                                    isBreak => isBreak);
			    link theEventOccInSeqDef R12 theEventInSeqDef;
			  else
			    // The event definition has been seen before which could indicate the repetition of an event type in a sequence
			    theEventDefnsInSequence := theSequenceDefn -> R1.AuditEventDefinition;
			    matchingEventDefn := find_one theEventDefnsInSequence (AEType = eventType);
			    if matchingEventDefn /= null then
			      // We have already seen this event type which could be because of a placeholder event definition or because of a repeated occurrence of an event definition
			      // A placeholder event definition occurs where a cyclic topology is defined. The backwards connection means that the previous event the the current event has not been seen yet.
			      theEventInSeqDef := matchingEventDefn with theSequenceDefn -> R1.AEInSequenceDefinition;
			      // Check to see if the event definition already exists because of a placeholder
			      thePlaceholderEventOccInSeqDef := find_one (theEventInSeqDef -> R12)(isPlaceholder = true);
			      if thePlaceholderEventOccInSeqDef = null then
			        // This is a repetition of this event type in the sequence so add a new occurrence accordingly
			        theEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (                  
			      	                                                              AEDefinitionId => theEventDefn.AEDefinitionId, 
			      	                                                              AESequenceId => theSequenceDefn.AESequenceId, 
			      	                                                              occurrenceNumberInSequence => occurrenceId, 
			      	                                                              isSequenceStart => isSequenceStart, 
			      	                                                              isSequenceEnd => isSequenceEnd
			                                                                      );
			        link theEventInSeqDef R12 theEventOccInSeqDef;
			      else
			        // It is a placeholder so now we've seen it for real we can clear the isPlaceholder flag and set the other flags according to input data
			        thePlaceholderEventOccInSeqDef.isPlaceholder := false;
			        thePlaceholderEventOccInSeqDef.isSequenceEnd := isSequenceStart;
			        thePlaceholderEventOccInSeqDef.isSequenceEnd := isSequenceEnd;
			        thePlaceholderEventOccInSeqDef.isBreak := isBreak;
			        theEventOccInSeqDef := thePlaceholderEventOccInSeqDef;
			      end if;  
			    else  
			      // For now assume this is not allowed. TODO Check to see if the same event type can legitimately occur in different Job Types and Sequences
			      logMessage := "The event type provided in the initialisation data has been seen elsewhere , Job Definition = " & theJobDefn.jobName & ", Sequence Definition = " & theSequenceDefn.sequenceDefinitionName & ", Event type = " & theEventDefn.AEType;
				  Logger::log(Logger::Error, "AESequenceDC", logMessage);            
			    end if;
			  end if;
			  
			  for previousEventType in previousEventTypes'elements loop
			      thePrevEventDefn := find_one AuditEventDefinition (AEType = previousEventType.eventTypeName);
			      if thePrevEventDefn /= null then
			        thePrevEventInSeqDefn :=  thePrevEventDefn with theSequenceDefn -> R1.AEInSequenceDefinition;
			        existingEventOccurrencesInSeqDefn := thePrevEventInSeqDefn -> R12;
			        thePrevEventOccInSeqDefn := find_one existingEventOccurrencesInSeqDefn (occurrenceNumberInSequence = previousEventType.occurrenceId);
			        if thePrevEventOccInSeqDefn /= null then
			          newEventInSeqPairDef := create AEInSequencePairDefn (
			        	                                                 AESequenceId => theSequenceDefn.AESequenceId, 
			        	                                                 followingAEDefinitionId => theEventOccInSeqDef.AEDefinitionId, 
			        	                                                 precedingAEDefinitionId => thePrevEventOccInSeqDefn.AEDefinitionId, 
			        	                                                 followingoccurrenceNumberInSequence => theEventOccInSeqDef.occurrenceNumberInSequence, 
			        	                                                 precedingoccurrenceNumberInSequence => thePrevEventOccInSeqDefn.occurrenceNumberInSequence
			                                                             );
			          link thePrevEventOccInSeqDefn R6.precedes theEventOccInSeqDef using newEventInSeqPairDef;
			          theConstraintDefn := find_one ConstraintDefinition (constraintDefnId = previousEventType.constraintDefId and jobName = theJobDefn.jobName);
			          if theConstraintDefn /= null and (theConstraintDefn.constraintType'image = previousEventType.constraintValue) then
			            // This is an existing known constraint so this is an additional event pair in that constraint
			            link newEventInSeqPairDef R16 theConstraintDefn;
			          elsif previousEventType.constraintDefId /= "" then
			            // This is a new constraint
			            if previousEventType.constraintValue = "AND" then
			              theConstraintDefn := create ConstraintDefinition (constraintDefnId => previousEventType.constraintDefId, jobName => theJobDefn.jobName, constraintType => AND );
			            elsif previousEventType.constraintValue = "XOR" then
			              theConstraintDefn := create ConstraintDefinition (constraintDefnId => previousEventType.constraintDefId, jobName => theJobDefn.jobName, constraintType => XOR );
			            else
			              logMessage := "Invalid Constraint Value provided : " & previousEventType.constraintValue & "in Job Name = " & jobName;
				          Logger::log(Logger::Error, "AESequenceDC", logMessage);            
			            end if;
			            if theConstraintDefn /= null then
			              link theConstraintDefn R17 theJobDefn;
			              link newEventInSeqPairDef R16 theConstraintDefn;
			            end if;  
			          elsif previousEventType.constraintDefId = "" then
			            // No constraint specified which is valid
			          else
			            logMessage := "Invalid Constraint Definition provided : " & previousEventType.constraintDefId & "in Job Name = " & jobName;
				        Logger::log(Logger::Error, "AESequenceDC", logMessage);            
			          end if;
			        else
			          // We have a reference to a forward event which is possible in the case of cyclic sequences so create a placeholder event
			          // In this case the event definition has been seen before but not this referenced occurrence number
			          logMessage := "Info: There is a forward reference to an event so create a Placeholder for event: " & thePrevEventDefn.AEType & "in Job Name = " & jobName;
				      Logger::log(Logger::Information, "AESequenceDC", logMessage);            
			          
			          thePlaceholderEventDefn := thePrevEventDefn; 
			          thePlaceholderEventInSeqDef := thePlaceholderEventDefn with theSequenceDefn -> R1;
			          thePlaceholderEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (
			    	                                                            AEDefinitionId => thePlaceholderEventDefn.AEDefinitionId, 
			    	                                                            AESequenceId => theSequenceDefn.AESequenceId, 
			    	                                                            occurrenceNumberInSequence => previousEventType.occurrenceId, 
			   	                                                                isPlaceholder => true
			                                                                    );
			          link thePlaceholderEventOccInSeqDef R12 thePlaceholderEventInSeqDef;
			          newEventInSeqPairDef := create AEInSequencePairDefn (
			        	                                                 AESequenceId => theSequenceDefn.AESequenceId, 
			        	                                                 followingAEDefinitionId => theEventOccInSeqDef.AEDefinitionId, 
			        	                                                 precedingAEDefinitionId => thePlaceholderEventOccInSeqDef.AEDefinitionId, 
			        	                                                 followingoccurrenceNumberInSequence => theEventOccInSeqDef.occurrenceNumberInSequence, 
			        	                                                 precedingoccurrenceNumberInSequence => thePlaceholderEventOccInSeqDef.occurrenceNumberInSequence
			                                                             );
			          link thePlaceholderEventOccInSeqDef R6.precedes theEventOccInSeqDef using newEventInSeqPairDef;
			        
			        
			        end if;
			      else
			        // We have a reference to a forward event which is possible in the case of cyclic sequences so create a placeholder event
			        thePlaceholderEventDefn := create unique AuditEventDefinition (AEType => previousEventType.eventTypeName); 
			        thePlaceholderEventInSeqDef := create AEInSequenceDefinition (AEDefinitionId => thePlaceholderEventDefn.AEDefinitionId, AESequenceId => theSequenceDefn.AESequenceId);
			        link thePlaceholderEventDefn R1 theSequenceDefn using thePlaceholderEventInSeqDef;
			        thePlaceholderEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (
			    	                                                            AEDefinitionId => thePlaceholderEventDefn.AEDefinitionId, 
			    	                                                            AESequenceId => theSequenceDefn.AESequenceId, 
			    	                                                            occurrenceNumberInSequence => previousEventType.occurrenceId, 
			    	                                                            isSequenceStart => isSequenceStart, 
			    	                                                            isSequenceEnd => isSequenceEnd,
			    	                                                            isPlaceholder => true
			                                                                    );
			        link thePlaceholderEventOccInSeqDef R12 thePlaceholderEventInSeqDef;
			        newEventInSeqPairDef := create AEInSequencePairDefn (
			        	                                                 AESequenceId => theSequenceDefn.AESequenceId, 
			        	                                                 followingAEDefinitionId => theEventOccInSeqDef.AEDefinitionId, 
			        	                                                 precedingAEDefinitionId => thePlaceholderEventOccInSeqDef.AEDefinitionId, 
			        	                                                 followingoccurrenceNumberInSequence => theEventOccInSeqDef.occurrenceNumberInSequence, 
			        	                                                 precedingoccurrenceNumberInSequence => thePlaceholderEventOccInSeqDef.occurrenceNumberInSequence
			                                                             );
			        link thePlaceholderEventOccInSeqDef R6.precedes theEventOccInSeqDef using newEventInSeqPairDef;
			        
			        
			        // The previous event definition provided is unknown
			        //logMessage := "Previous event types provided in the initialisation data are unknown, Job Definition = " & theJobDefn.jobName & ", Sequence Definition = " & theSequenceDefn.sequenceDefinitionName & ", Event type = " & theEventDefn.AEType& ", Previous event type = " & previousEventType.eventTypeName;
				    //Logger::log(Logger::Error, "AESequenceDC", logMessage);                  
			      end if;
			
			//      logMessage := "Multiple previous event types provided in the initialisation data. Not currently supported, Job Definition = " & theJobDefn.jobName & ", Sequence Definition = " & theSequenceDefn.sequenceDefinitionName & ", Event type = " & theEventDefn.AEType;
			//	  Logger::log(Logger::Error, "AESequenceDC", logMessage);            
			        
			//    end if;
			  end loop;
			  //
			  //
			  //
			end service;
			@endnoparse
		end function;

		//! This function, invoked during initialisation after all of the eventDefinition functions have been called, adds an
		//! extra job invariant definition(such as entropy). The parameters define the extra job invariant, the job defintion and event
		//! definition that is the source of the and the invariant and also the full set of job definitions and event definitions
		//! that use the invariant.
		@function_num(13);
		function extraJobInvariantDefinition(auditEventDataName: in string, sourceJobDefnName: in string, sourceEventType: in string, sourceOccurrenceId: in integer, userEvents: in sequence of userEventDataStructure) is
			@noparse
			sourceInvariantEventType : eventStructure;
			invariantEventType : eventStructure;
			logMessage : string;
			
			begin
			  // TODO - remove the following log message (added for testing purposes).
			  logMessage := "Extra Job Invariant Definition added for "& auditEventDataName;
			  Logger::log(Logger::Information, "AESequenceDC", logMessage);
			
			  sourceInvariantEventType := (sourceEventType,sourceOccurrenceId,"","");
			  ExtraJobInvariantDefn.createSourceExtraJobInvariantDefn(sourceJobDefnName,auditEventDataName, sourceInvariantEventType, @P1D@);
			  // TODO - the lifetime of the extra job invariant is currently fixed at 1 day (see last parameter in previous function call). This needs 
			  // to be user-configurable and will require a change to the interface for the function 'extraJobInvaiantDefinition'.
			
			  for userEvent in userEvents loop
			    invariantEventType := (userEvent.auditEventType,userEvent.occurrenceId,"","");
			    ExtraJobInvariantDefn.linkUserExtraJobInvariantDefn(userEvent.jobDefinitionName, auditEventDataName, invariantEventType);
			  end loop;
			  
			end service;
			@endnoparse
		end function;

		@function_num(3);
		function failedJob(jobId: in string, failureReason: in string) is
			@noparse
			theJob : instance of Job;
			
			begin
			  theJob := find_only Job (jobID = jobId);
			  if theJob /= null then
			    generate Job.jobFailed(failureReason) to theJob;
			  end if;
			
			end service;
			@endnoparse
		end function;

		//! This function, invoked during initialisation after all of the eventDefinition functions have been called, adds an
		//! intra job invariant definition. The parameters define the intra job invariant, the job defintion that the invariant is used in
		//! and the full set of event definitions within that job definition that use the invariant.
		@function_num(13);
		function intraJobInvariantDefinition(jobDefnName: in string, auditEventDataName: in string, associatedEvents: in sequence of intraJobInvDataStructure) is
			@noparse
			invariantEventType : eventStructure;
			invariantEventTypes : sequence of eventStructure;
			begin
			  
			  for associatedEvent in associatedEvents loop
			    invariantEventType := (associatedEvent.auditEventType,associatedEvent.occurrenceId,"","");
			    invariantEventTypes := invariantEventTypes & invariantEventType;
			  end loop;
			  IntraJobInvariantDefn.createIntraJobInvariantDefn(jobDefnName, auditEventDataName, invariantEventTypes);
			
			  
			end service;
			@endnoparse
		end function;

		@function_num(4);
		function jobComplete(jobId: in string) is
			@noparse
			theJob : instance of Job;
			
			begin
			  //
			  theJob := find_only Job (jobID = jobId);
			  if theJob /= null then
			    generate Job.jobTimedOut() to theJob;
			  end if;
			  //
			end service;
			@endnoparse
		end function;

		@function_num(12);
		function reactivateJobDefinition(jobName: in string) is
			@noparse
			theJobDefn : instance of JobDefinition;
			logMessage : string;
			
			begin
			
			  // Reactivate the JobDefinition - this will only occur if it is in the 'Suspended' state
			  theJobDefn := find_one JobDefinition (jobName = jobName);
			  if theJobDefn /= null then
			    // Check whether the respective JobDefinition is in the 'Suspended' state.
			    if theJobDefn.isSuspended /= true then
			      logMessage := "Reactivation attempt of JobDefinition - jobName " & jobName & "failed because it was not in the SUSPENDED state";
				  Logger::log(Logger::Information, "AESequenceDC", logMessage);
				else
				   // Reactivate the suspended JobDefinition
			       generate JobDefinition.reactivate() to theJobDefn;
			    end if;
			  else
			    // 
			    logMessage := "The JobDefinition specified for reactivation is unknown - jobName " & jobName;
				Logger::log(Logger::Information, "AESequenceDC", logMessage);
			  
			  end if;
			end service;
			@endnoparse
		end function;

		@function_num(15);
		function restoreInvariants(restoredInvariants: in sequence of persistedInvariantStructure) is
			@noparse
			theRestoredExtraJobInvDefn : instance of ExtraJobInvariantDefn;
			theAEOccurrenceDefn : instance of AEOccurrenceInSequenceDefinition;
			theEventDefn : instance of AuditEventDefinition;
			theJobDefn : instance of JobDefinition;
			theJobs : set of instance of Job;
			theRestoredPersistentInvariant : instance of PersistedInvariant;
			existingInvariant : instance of PersistedInvariant;
			theSystemSpec : instance of SystemSpecification;
			
			logMessage : string;
			
			begin
			  for restoredInvariant in restoredInvariants loop
			                
			    theRestoredExtraJobInvDefn := find_one ExtraJobInvariantDefn (extraJobInvName = restoredInvariant.extraJobInvariantName);
			    if theRestoredExtraJobInvDefn /= null then    
			      theRestoredExtraJobInvDefn.restoreInvariantOfThisDefinition (restoredInvariant);      
			    
			    else
			                      
			      logMessage := "No Extra-Job Invariant Definition of the appropriate name was found so restoring the following Invariant cannot proceed " & restoredInvariant.extraJobInvariantName;
			      Logger::log(Logger::Information, "AESequenceDC", logMessage);
			  	                                                                           
			    end if;  
			                 
			  end loop;
			  
			  // Tell all extant Jobs that stored invariants have been found
			  theJobs := find Job (jobCompleted = false);
			  // generate event to all jobs here
			  for eachJob in theJobs loop
			    
			    // TODO Remove debug message
			    logMessage := "Additional Source Invariants found so re-evaluate the extra job invariants for Job " & eachJob.jobID;
			    Logger::log(Logger::Information, "AESequenceDC", logMessage);
			    
			    generate Job.StoredInvariantsReceived () to eachJob;
			  end loop;
			end service;
			@endnoparse
		end function;

		@function_num(11);
		function suspendJobDefinition(jobName: in string) is
			@noparse
			theJobDefn : instance of JobDefinition;
			logMessage : string;
			
			begin
			
			  // Move the JobDefinition into the 'Suspended' state - in this state no further new Jobs of this type
			  // will be processed until returned back to the 'Active' state.
			  theJobDefn := find_one JobDefinition (jobName = jobName);
			  if theJobDefn /= null then
			    // Note that if the Job is not in the 'Active' state then the suspension attempt will be ignored.
			    generate JobDefinition.suspend() to theJobDefn;
			  else
			  
			    logMessage := "The JobDefinition specified for suspension is unknown - jobName " & jobName;
				Logger::log(Logger::Information, "AESequenceDC", logMessage);
			  
			  end if;
			end service;
			@endnoparse
		end function;

	end package;

end;
