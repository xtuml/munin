//! ACTIVITY BEGIN. '298c8d7e-e4b9-4710-a16a-e892653eccda' DO NOT EDIT THIS LINE.
public service AESequenceDC::acceptOrderedEvent ( ae_time : in string,
                                                 ae_type : in string,
                                                 jobId : in string,
                                                 jobName : in string,
                                                 prevAEIds : in sequence of string,
                                                 id : in string,
                                                 auditEventData : in sequence of auditEventDataStructure ) is
existingJob : instance of Job;
existingJobs : set of instance of Job;
possibleSeqAuditEventDefinitions : set of instance of SequencedAuditEventDefinition;
possibleUnseqAuditEventDefinitions : set of instance of UnsequencedAuditEventDefinition;
theSeqAuditEventDefinition : instance of SequencedAuditEventDefinition;
theUnseqAuditEventDefinition : instance of UnsequencedAuditEventDefinition;
eventsSequenceDefs : set of instance of AESequenceDefinition;
jobsSequenceDefs : set of instance of AESequenceDefinition;
aeSequenceDefs : set of instance of AESequenceDefinition;
theSequenceDef : instance of AESequenceDefinition;
knownJobDefinition : instance of JobDefinition;
theUnhappyJob : instance of UnhappyJob;
jobCheckResult : boolean;
kvps : dictionary of string;

begin

  kvps["eventId"] := id; kvps["eventType"] := ae_type;
  // Report the event
  if (Logger::enabled(Logger::Debug, "pv.sv.acceptorderedevent")) then
    Logger::log(Logger::Debug, "pv.sv.acceptorderedevent",
      svLog("svdc_event_received", "initial receipt", jobId, jobName, kvps));
  end if;
  //NEW Check the jobType refers to a known JobDefinition
  knownJobDefinition := find_only JobDefinition (jobName = jobName);
  if knownJobDefinition /= null then
  
    if (knownJobDefinition.isSuspended = true) or (knownJobDefinition.isDeprecated = true) then
      Logger::log(Logger::Warning, "pv.sv.acceptorderedevent",
        svLog("svdc_invalid_event", "The accepted event is for a new Job that has a non-active JobDefinition (suspended or deprecated)", jobId, jobName, kvps));
    else    
         
      existingJobs := knownJobDefinition -> R8;
      possibleSeqAuditEventDefinitions := knownJobDefinition -> R7 -> R1.SequencedAuditEventDefinition;
      possibleUnseqAuditEventDefinitions := knownJobDefinition -> R39.UnsequencedAuditEventDefinition;
      // Check to see if the received event is part of a Job that is already being processed
      existingJob := find_only existingJobs (jobID = jobId);
      if existingJob /= null then
        //We have an existing Job and this event should be the next in sequence for that Job
        generate Job.newEventForExistingJob (id, prevAEIds, ae_type, auditEventData) to existingJob;
      else
        // The received event is either for a new job or a job that has been seen and is now deleted
        // TODO Check in Job Store for jobId and if present log and error for an event sent to a previously deleted job otherwise carry on
        JobAdmin~>CheckForJobId(jobId, jobCheckResult);
        if jobCheckResult = false then
          // We also need to check whether the event received is a known happy event type, an unhappy event type or an unknown event type
          theSeqAuditEventDefinition := find_only possibleSeqAuditEventDefinitions (AEType = ae_type);
          theUnseqAuditEventDefinition := find_only possibleUnseqAuditEventDefinitions (UnsequencedAEType = ae_type);
          if theSeqAuditEventDefinition /= null then
        
            //We have a new job and this event should be tested as a valid initial event for a Job
            SequencedAuditEvent.AddEventForNewJob (jobId, jobName, id, prevAEIds, ae_type, auditEventData);
          elsif theUnseqAuditEventDefinition /= null then
        
            //We have received an unhappy path event as the first event in this new job        
            UnsequencedAuditEvent.AddEventForNewUnhappyJob (jobId, jobName, id, prevAEIds, ae_type, auditEventData);
      
          else
            // Log info: Report that the specified audit event type (ae_type) does not exist for this job definition.
            Logger::log(Logger::Warning, "pv.sv.acceptorderedevent",
              svLog("svdc_invalid_event", "accepted event is of an unknown event type", jobId, jobName, kvps));
          end if;
        else
          // The jobId corresponds to that of a deleted job so this is an error condition
          Logger::log(Logger::Warning, "pv.sv.acceptorderedevent",
            svLog("svdc_invalid_event", "Event has been sent to a previously deleted Job", jobId, jobName, kvps));
        end if;
      end if;
    end if;  
  else
    // Log info: Report that the specified job definition as indicated by jobName does not exist.
    Logger::log(Logger::Warning, "pv.sv.acceptorderedevent",
      svLog("svdc_invalid_event", "Accepted event is of an unknown Job type", jobId, jobName, kvps));
    
  end if;

end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'bb8ee068-445c-4b0a-95b8-d612dd1a0a6c' DO NOT EDIT THIS LINE.
public service AESequenceDC::failedJob ( jobId : in string,
                                        failureReason : in string ) is
theJob : instance of Job;

begin
  theJob := find_only Job (jobID = jobId);
  if theJob /= null then
    generate Job.jobFailed(failureReason) to theJob;
  end if;

end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '0178da63-222b-4260-8c2a-2d4c29ff808d' DO NOT EDIT THIS LINE.
public service AESequenceDC::jobComplete ( jobId : in string ) is
theJob : instance of Job;

begin
  //
  theJob := find_only Job (jobID = jobId);
  if theJob /= null then
    generate Job.jobTimedOut() to theJob;
  end if;
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'f0bfcefa-2cc9-4e61-81da-4571627deee7' DO NOT EDIT THIS LINE.
public service AESequenceDC::eventDefinition ( jobName : in string,
                                              sequenceName : in string,
                                              eventType : in string,
                                              occurrenceId : in integer,
                                              previousEventTypes : in sequence of eventStructure,
                                              isSequenceStart : in boolean,
                                              isSequenceEnd : in boolean,
                                              isBreak : in boolean,
                                              isHappy : in boolean,
                                              isCritical : in boolean ) is
theJobDefn : instance of JobDefinition;
theSequenceDefn : instance of AESequenceDefinition;
theEventDefn : instance of SequencedAuditEventDefinition;
thisJobsEventDefns : set of instance of SequencedAuditEventDefinition;
theExistingEventDefn : instance of SequencedAuditEventDefinition;
theEventDefnsInSequence : set of instance of SequencedAuditEventDefinition;
matchingEventDefn : instance of SequencedAuditEventDefinition;
thePrevEventDefn : instance of SequencedAuditEventDefinition;
thePlaceholderEventDefn : instance of SequencedAuditEventDefinition;
theEventInSeqDef : instance of AEInSequenceDefinition;
thePlaceholderEventInSeqDef : instance of AEInSequenceDefinition;
theEventOccInSeqDef : instance of AEOccurrenceInSequenceDefinition;
thePlaceholderEventOccInSeqDef : instance of AEOccurrenceInSequenceDefinition;
thePrevEventInSeqDefn : instance of AEInSequenceDefinition;
thePrevEventOccInSeqDefn : instance of AEOccurrenceInSequenceDefinition;
existingEventOccurrencesInSeqDefn : set of instance of AEOccurrenceInSequenceDefinition;
newEventInSeqPairDef : instance of AEInSequencePairDefn;
theConstraintDefn : instance of ConstraintDefinition;
theUnseqEventDefn : instance of UnsequencedAuditEventDefinition;
theUnseqEventDefnInJobDefn  : instance of UnsequencedAEDefnInJobDefn;
newCriticalEventDefnInJobDefn : instance of CriticalEventDefnForJobDefn;
kvps : dictionary of string; 
previousEventType : eventStructure;

//
begin
  theJobDefn := find_one JobDefinition (jobName = jobName);
  if theJobDefn = null then
    // Event Definition for new Job so create the Job Definition
    theJobDefn := create unique JobDefinition (jobName => jobName, isDeprecated => false, isSuspended => false, Current_State => Active);
    // Log as INFO the creation of a new job definition
    Logger::log(Logger::Information, "pv.sv.eventdefinition",
      svLog("svdc_job_definition", "new job definition added", "", jobName, kvps));
  end if; 

  kvps["sequenceName"] := sequenceName; kvps["eventType"] := eventType;
  kvps["isSequenceStart"] := isSequenceStart'image; kvps["isSequenceEnd"] := isSequenceEnd'image;
  kvps["isBreak"] := isBreak'image; kvps["isHappy"] := isHappy'image; kvps["isCritical"] := isCritical'image;
  Logger::log(Logger::Debug, "pv.sv.eventdefinition",
    svLog("svdc_event_definition", "create new event defintion", "", jobName, kvps));

  if isHappy then
    // We have a definition for a Sequenced (or Happy) Event 
       
    theSequenceDefn := find_one AESequenceDefinition (sequenceDefinitionName = sequenceName);
    if theSequenceDefn = null then
      // Event Definition for new Sequence so create the Sequence Definition
      theSequenceDefn := create unique AESequenceDefinition (sequenceDefinitionName => sequenceName);
      link theSequenceDefn R7 theJobDefn;
      Logger::log(Logger::Debug, "pv.sv.eventdefinition",
        svLog("svdc_event_definition", "new sequence definition added", "", jobName, kvps));
    end if;
   
    theEventDefn := find_one SequencedAuditEventDefinition (AEType = eventType);
    thisJobsEventDefns := theJobDefn -> R7 -> R1.SequencedAuditEventDefinition;
    theExistingEventDefn := find_one thisJobsEventDefns (AEType = eventType);
    if theEventDefn = null then
      // The event definition hasn't been seen before so is a valid addition
      theEventDefn := create unique SequencedAuditEventDefinition (AEType => eventType); 

      // Capture whether this is a critical event in the happy path      
      if isCritical then
        newCriticalEventDefnInJobDefn := create CriticalEventDefnForJobDefn (AEDefinitionId => theEventDefn.AEDefinitionId,
        	                                                                 jobName => jobName);
        link theEventDefn R43 theJobDefn using newCriticalEventDefnInJobDefn;
        
      end if;  
      
      theEventInSeqDef := create AEInSequenceDefinition (AEDefinitionId => theEventDefn.AEDefinitionId, AESequenceId => theSequenceDefn.AESequenceId);
      link theEventDefn R1 theSequenceDefn using theEventInSeqDef;
      theEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (
    	                                                            AEDefinitionId => theEventDefn.AEDefinitionId, 
    	                                                            AESequenceId => theSequenceDefn.AESequenceId, 
    	                                                            occurrenceNumberInSequence => occurrenceId, 
    	                                                            isSequenceStart => isSequenceStart, 
    	                                                            isSequenceEnd => isSequenceEnd,
                                                                    isBreak => isBreak);
      link theEventOccInSeqDef R12 theEventInSeqDef;
      Logger::log(Logger::Debug, "pv.sv.eventdefinition",
        svLog("svdc_event_definition", "new happy event definition added", "", jobName, kvps));
    elsif theExistingEventDefn /= null then
      // The event definition has been seen before which could indicate the repetition of an event type within a sequence or the repetition of an event type in a different job definition
      theEventDefnsInSequence := theSequenceDefn -> R1.SequencedAuditEventDefinition;
      matchingEventDefn := find_one theEventDefnsInSequence (AEType = eventType);
      if matchingEventDefn /= null then
        // We have already seen this event type which could be because of a placeholder event definition or because of a repeated occurrence of an event definition
        // A placeholder event definition occurs where a cyclic topology is defined. The backwards connection means that the previous event the the current event has not been seen yet.
        theEventInSeqDef := matchingEventDefn with theSequenceDefn -> R1.AEInSequenceDefinition;
        // Check to see if the event definition already exists because of a placeholder
        thePlaceholderEventOccInSeqDef := find_one (theEventInSeqDef -> R12)(isPlaceholder = true);
        if thePlaceholderEventOccInSeqDef = null then
          // This is a repetition of this event type in the sequence so add a new occurrence accordingly
          theEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (                  
      	                                                              AEDefinitionId => theEventDefn.AEDefinitionId, 
      	                                                              AESequenceId => theSequenceDefn.AESequenceId, 
      	                                                              occurrenceNumberInSequence => occurrenceId, 
      	                                                              isSequenceStart => isSequenceStart, 
      	                                                              isSequenceEnd => isSequenceEnd
                                                                      );
          link theEventInSeqDef R12 theEventOccInSeqDef;
          Logger::log(Logger::Debug, "pv.sv.eventdefinition",
            svLog("svdc_event_definition", "additional event occurrence definition added", "", jobName, kvps));
        else
          // It is a placeholder so now we've seen it for real we can clear the isPlaceholder flag and set the other flags according to input data
          thePlaceholderEventOccInSeqDef.isPlaceholder := false;
          thePlaceholderEventOccInSeqDef.isSequenceEnd := isSequenceStart;
          thePlaceholderEventOccInSeqDef.isSequenceEnd := isSequenceEnd;
          thePlaceholderEventOccInSeqDef.isBreak := isBreak;
          theEventOccInSeqDef := thePlaceholderEventOccInSeqDef;
        end if;  
      else  
        // For now assume this is not allowed. TODO Check to see if the same event type can legitimately occur in different Job Types and Sequences
        Logger::log(Logger::Warning, "pv.sv.eventdefinition",
          svLog("svdc_invalid_event_definition", "The event type provided in the initialisation data has been seen elsewhere", "", jobName, kvps));
      end if;
    else
      // We have an event definition previously seen in a different job definition which is fine
      // Capture whether this is a critical event in the happy path      
      if isCritical then
        newCriticalEventDefnInJobDefn := create CriticalEventDefnForJobDefn (AEDefinitionId => theEventDefn.AEDefinitionId,
        	                                                                 jobName => jobName);
        link theEventDefn R43 theJobDefn using newCriticalEventDefnInJobDefn;
        
      end if;  
      
      theEventInSeqDef := create AEInSequenceDefinition (AEDefinitionId => theEventDefn.AEDefinitionId, AESequenceId => theSequenceDefn.AESequenceId);
      link theEventDefn R1 theSequenceDefn using theEventInSeqDef;
      theEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (
    	                                                            AEDefinitionId => theEventDefn.AEDefinitionId, 
    	                                                            AESequenceId => theSequenceDefn.AESequenceId, 
    	                                                            occurrenceNumberInSequence => occurrenceId, 
    	                                                            isSequenceStart => isSequenceStart, 
    	                                                            isSequenceEnd => isSequenceEnd,
                                                                    isBreak => isBreak);
      link theEventOccInSeqDef R12 theEventInSeqDef;
      Logger::log(Logger::Debug, "pv.sv.eventdefinition",
        svLog("svdc_event_definition", "Event Definition seen in another Job added to Job Definition", "", jobName, kvps));
      
    end if;
  
    for previousEventType in previousEventTypes'elements loop
        thePrevEventDefn := find_one thisJobsEventDefns (AEType = previousEventType.eventTypeName);
        if thePrevEventDefn /= null then
          thePrevEventInSeqDefn :=  thePrevEventDefn with theSequenceDefn -> R1.AEInSequenceDefinition;
          existingEventOccurrencesInSeqDefn := thePrevEventInSeqDefn -> R12;
          thePrevEventOccInSeqDefn := find_one existingEventOccurrencesInSeqDefn (occurrenceNumberInSequence = previousEventType.occurrenceId);
          if thePrevEventOccInSeqDefn /= null then
            newEventInSeqPairDef := create AEInSequencePairDefn (
                                                                 AESequenceId => theSequenceDefn.AESequenceId, 
                                                                 followingAEDefinitionId => theEventOccInSeqDef.AEDefinitionId, 
                                                                 precedingAEDefinitionId => thePrevEventOccInSeqDefn.AEDefinitionId, 
                                                                 followingoccurrenceNumberInSequence => theEventOccInSeqDef.occurrenceNumberInSequence, 
                                                                 precedingoccurrenceNumberInSequence => thePrevEventOccInSeqDefn.occurrenceNumberInSequence
                                                             );
            link thePrevEventOccInSeqDefn R6.precedes theEventOccInSeqDef using newEventInSeqPairDef;
            theConstraintDefn := find_one ConstraintDefinition (constraintDefnId = previousEventType.constraintDefId and jobName = theJobDefn.jobName);
            if theConstraintDefn /= null and (theConstraintDefn.constraintType'image = previousEventType.constraintValue) then
              // This is an existing known constraint so this is an additional event pair in that constraint
              link newEventInSeqPairDef R16 theConstraintDefn;
            elsif previousEventType.constraintDefId /= "" then
              // This is a new constraint
              if previousEventType.constraintValue = "AND" then
                theConstraintDefn := create ConstraintDefinition (constraintDefnId => previousEventType.constraintDefId, jobName => theJobDefn.jobName, constraintType => AND );
              elsif previousEventType.constraintValue = "XOR" then
                theConstraintDefn := create ConstraintDefinition (constraintDefnId => previousEventType.constraintDefId, jobName => theJobDefn.jobName, constraintType => XOR );
              else
                kvps["constraintValue"] := previousEventType.constraintValue;
                Logger::log(Logger::Warning, "pv.sv.eventdefinition",
                  svLog("svdc_invalid_event", "Invalid Constraint Value provided", "", jobName, kvps));
              end if;
              if theConstraintDefn /= null then
                link theConstraintDefn R17 theJobDefn;
                link newEventInSeqPairDef R16 theConstraintDefn;
              end if;  
            elsif previousEventType.constraintDefId = "" then
              // No constraint specified which is valid
            else
              kvps["constraintDefId"] := previousEventType.constraintDefId;
              Logger::log(Logger::Warning, "pv.sv.eventdefinition",
                svLog("svdc_invalid_event", "invalid constraint definition provided", "", jobName, kvps));
            end if;
          else
            // We have a reference to a forward event which is possible in the case of cyclic sequences so create a placeholder event
            // In this case the event definition has been seen before but not this referenced occurrence number
            Logger::log(Logger::Debug, "pv.sv.eventdefinition",
              svLog("svdc_event_definition", "There is a forward reference to an event so create a Placeholder for the new event occurrence", "", jobName, kvps));
          
            thePlaceholderEventDefn := thePrevEventDefn; 
            thePlaceholderEventInSeqDef := thePlaceholderEventDefn with theSequenceDefn -> R1;
            thePlaceholderEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (
                                                                    AEDefinitionId => thePlaceholderEventDefn.AEDefinitionId, 
                                                                    AESequenceId => theSequenceDefn.AESequenceId, 
                                                                    occurrenceNumberInSequence => previousEventType.occurrenceId, 
                                                                    isPlaceholder => true
                                                                    );
            link thePlaceholderEventOccInSeqDef R12 thePlaceholderEventInSeqDef;
            newEventInSeqPairDef := create AEInSequencePairDefn (
                                                                 AESequenceId => theSequenceDefn.AESequenceId, 
                                                                 followingAEDefinitionId => theEventOccInSeqDef.AEDefinitionId, 
                                                                 precedingAEDefinitionId => thePlaceholderEventOccInSeqDef.AEDefinitionId, 
                                                                 followingoccurrenceNumberInSequence => theEventOccInSeqDef.occurrenceNumberInSequence, 
                                                                 precedingoccurrenceNumberInSequence => thePlaceholderEventOccInSeqDef.occurrenceNumberInSequence
                                                                );
            link thePlaceholderEventOccInSeqDef R6.precedes theEventOccInSeqDef using newEventInSeqPairDef;
        
        
          end if;
        else
          // We have a reference to a forward event which is possible in the case of cyclic sequences so create a placeholder event
          // In this case the event definition has not been seen at all
          Logger::log(Logger::Debug, "pv.sv.eventdefinition",
            svLog("svdc_event_definition", "There is a forward reference to an event so create a Placeholder for the new event occurrence", "", jobName, kvps));
          thePlaceholderEventDefn := find_one SequencedAuditEventDefinition (AEType = previousEventType.eventTypeName);
          if thePlaceholderEventDefn = null then
            thePlaceholderEventDefn := create unique SequencedAuditEventDefinition (AEType => previousEventType.eventTypeName); 
            thePlaceholderEventInSeqDef := create AEInSequenceDefinition (AEDefinitionId => thePlaceholderEventDefn.AEDefinitionId, AESequenceId => theSequenceDefn.AESequenceId);
            link thePlaceholderEventDefn R1 theSequenceDefn using thePlaceholderEventInSeqDef;
          else
            thePlaceholderEventInSeqDef := find_one AEInSequenceDefinition (AEDefinitionId = thePlaceholderEventDefn.AEDefinitionId and AESequenceId = theSequenceDefn.AESequenceId);
            if thePlaceholderEventInSeqDef = null then
              thePlaceholderEventInSeqDef := create AEInSequenceDefinition (AEDefinitionId => thePlaceholderEventDefn.AEDefinitionId, AESequenceId => theSequenceDefn.AESequenceId);
              link thePlaceholderEventDefn R1 theSequenceDefn using thePlaceholderEventInSeqDef;
            end if;
          end if;  
          //link thePlaceholderEventDefn R1 theSequenceDefn using thePlaceholderEventInSeqDef;
          thePlaceholderEventOccInSeqDef := find_one AEOccurrenceInSequenceDefinition (
    	                                                            AEDefinitionId = thePlaceholderEventDefn.AEDefinitionId and 
    	                                                            AESequenceId = theSequenceDefn.AESequenceId and 
    	                                                            occurrenceNumberInSequence = previousEventType.occurrenceId);
    	  if thePlaceholderEventOccInSeqDef = null then                                                            
            thePlaceholderEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (
    	                                                            AEDefinitionId => thePlaceholderEventDefn.AEDefinitionId, 
    	                                                            AESequenceId => theSequenceDefn.AESequenceId, 
    	                                                            occurrenceNumberInSequence => previousEventType.occurrenceId, 
    	                                                            isSequenceStart => isSequenceStart, 
    	                                                            isSequenceEnd => isSequenceEnd,
    	                                                            isPlaceholder => true
                                                                    );
            link thePlaceholderEventOccInSeqDef R12 thePlaceholderEventInSeqDef;
          end if;
          newEventInSeqPairDef := create AEInSequencePairDefn (
        	                                                 AESequenceId => theSequenceDefn.AESequenceId, 
        	                                                 followingAEDefinitionId => theEventOccInSeqDef.AEDefinitionId, 
        	                                                 precedingAEDefinitionId => thePlaceholderEventOccInSeqDef.AEDefinitionId, 
        	                                                 followingoccurrenceNumberInSequence => theEventOccInSeqDef.occurrenceNumberInSequence, 
        	                                                 precedingoccurrenceNumberInSequence => thePlaceholderEventOccInSeqDef.occurrenceNumberInSequence
                                                             );
          link thePlaceholderEventOccInSeqDef R6.precedes theEventOccInSeqDef using newEventInSeqPairDef;
        
        
          // The previous event definition provided is unknown
          // Previous event types provided in the initialisation data are unknown ..."
	      //Logger::log(Logger::Error, "pv.sv.eventdefinition",
        end if;

//        Multiple previous event types provided in the initialisation data. Not currently supported ..."
//	  Logger::log(Logger::Error, "pv.sv.eventdefinition",
        
//    end if;
    end loop;
  
  else
   // We have a definition for a Unhappy (or Unsequenced) Event 
    theUnseqEventDefn := find_one UnsequencedAuditEventDefinition (UnsequencedAEType = eventType);
    if theUnseqEventDefn = null then
        theUnseqEventDefn := create unique UnsequencedAuditEventDefinition (UnsequencedAEType => eventType);
        theUnseqEventDefnInJobDefn := create UnsequencedAEDefnInJobDefn (UnsequencedAEDefnId => theUnseqEventDefn.UnsequencedAEDefnId,
                                                                         jobName => theJobDefn.jobName); 
        link theUnseqEventDefn R39 theJobDefn using theUnseqEventDefnInJobDefn ;
        kvps["unhappyEventType"] := theUnseqEventDefn.UnsequencedAEType;
        Logger::log(Logger::Debug, "pv.sv.eventdefinition",
          svLog("svdc_event_definition", "new unhappy event definition added", "", jobName, kvps));
  
    else
        theUnseqEventDefnInJobDefn := create UnsequencedAEDefnInJobDefn (UnsequencedAEDefnId => theUnseqEventDefn.UnsequencedAEDefnId,
                                                                         jobName => theJobDefn.jobName); 
        link theUnseqEventDefn R39 theJobDefn using theUnseqEventDefnInJobDefn ;
        kvps["unhappyEventType"] := theUnseqEventDefn.UnsequencedAEType;
        Logger::log(Logger::Debug, "pv.sv.eventdefinition",
          svLog("svdc_event_definition", "Existing Unhappy Event Definition found and added to this Job Definition", "", jobName, kvps));
    end if;
    
    // The following checks that an unhappy event is not marked as a critical event as that combination is not allowed
    if isCritical then
      Logger::log(Logger::Warning, "pv.sv.eventdefinition",
        svLog("svdc_invalid_event_definition", "The event type provided in the initialisation data is marked as Critical and an Unhappy Event - this combination is not allowed", "", jobName, kvps));
    end if;
  end if;  

end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'ad9b6852-61ff-4b7e-9f03-426846633e70' DO NOT EDIT THIS LINE.
private service AESequenceDC::deleteJob ( jobId : in string ) is
theJob : instance of Job;
kvps : dictionary of string;

begin

  theJob := find_one Job (jobID = jobId);
  if theJob /= null then
    theJob.deleteJob();

  else

    Logger::log(Logger::Error, "pv.sv.deletejob",
      svLog("svdc_unknown_job", "jobId provided is unknown", jobId, "", kvps));
      
  end if;
  //
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '8548b0fd-27ba-42ee-b392-3098142e30ed' DO NOT EDIT THIS LINE.
public service AESequenceDC::deprecateJobDefinition ( jobName : in string ) is
theJobDefn : instance of JobDefinition;
kvps : dictionary of string;

begin

  // Move the JobDefinition into the 'Deprecated' state and wait for all outstanding Jobs of that 
  // type to complete (either successful for fail) before automatically deleting it.
  theJobDefn := find_one JobDefinition (jobName = jobName);
  if theJobDefn /= null then
    generate JobDefinition.deprecate() to theJobDefn;
  else

    Logger::log(Logger::Warning, "pv.sv.deprecatejobdefinition",
      svLog("svdc_unknown_job", "Job Definition specified for deprecation is unknown", "", jobName, kvps));

  end if;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'ecc6c890-af9e-41d7-a4a0-cad083920fdf' DO NOT EDIT THIS LINE.
public service AESequenceDC::createSVDCsystemSpec ( maxIntraSequenceEventTimeoutPeriod : in duration,
                                                   waitPeriodForAllJobsCompletedCheck : in duration,
                                                   waitPeriodForJobDeletion : in duration,
                                                   waitPeriodForInvariantDeletion : in duration,
                                                   timeoutPeriodForRetreivingStoredInvariants : in duration,
                                                   timeoutPeriodForHangingJob : in duration ) is
theSVDCSystemSpec : instance of SystemSpecification;
begin
  theSVDCSystemSpec := find_one SystemSpecification ();
  if theSVDCSystemSpec = null then
    theSVDCSystemSpec := create unique SystemSpecification (intraSequenceEventTimeoutPeriod => maxIntraSequenceEventTimeoutPeriod,
  	                                                      checkJobDefReadyForDeletionPeriod => waitPeriodForAllJobsCompletedCheck,
  	                                                      jobDeletionWaitPeriod => waitPeriodForJobDeletion,
  	                                                      sourceExtraJobInvariantDeletionPeriod => waitPeriodForInvariantDeletion,
  	                                                      persistentInvariantRestoreTimeoutPeriod => timeoutPeriodForRetreivingStoredInvariants,              
  	                                                      jobHangingTimeoutPeriod => timeoutPeriodForHangingJob);
  else
    theSVDCSystemSpec.intraSequenceEventTimeoutPeriod := maxIntraSequenceEventTimeoutPeriod;
    theSVDCSystemSpec.checkJobDefReadyForDeletionPeriod := waitPeriodForAllJobsCompletedCheck;
  	theSVDCSystemSpec.jobDeletionWaitPeriod := waitPeriodForJobDeletion;
  	theSVDCSystemSpec.sourceExtraJobInvariantDeletionPeriod := waitPeriodForInvariantDeletion;
  	theSVDCSystemSpec.persistentInvariantRestoreTimeoutPeriod := timeoutPeriodForRetreivingStoredInvariants;              
  	theSVDCSystemSpec.jobHangingTimeoutPeriod := timeoutPeriodForHangingJob;
  end if;	                                                      
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'e933a4e5-fd85-42d8-9e5f-43423ba863e4' DO NOT EDIT THIS LINE.
public service AESequenceDC::suspendJobDefinition ( jobName : in string ) is
theJobDefn : instance of JobDefinition;
kvps : dictionary of string;

begin

  // Move the JobDefinition into the 'Suspended' state - in this state no further new Jobs of this type
  // will be processed until returned back to the 'Active' state.
  theJobDefn := find_one JobDefinition (jobName = jobName);
  if theJobDefn /= null then
    // Note that if the Job is not in the 'Active' state then the suspension attempt will be ignored.
    generate JobDefinition.suspend() to theJobDefn;
  else
  
    Logger::log(Logger::Warning, "pv.sv.suspendjobdefinition",
      svLog("svdc_unknown_job", "Job Definition specified for suspension is unknown", "", jobName, kvps));
  
  end if;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '9ff9de0d-be3c-4799-94fd-023a6a83a934' DO NOT EDIT THIS LINE.
public service AESequenceDC::reactivateJobDefinition ( jobName : in string ) is
theJobDefn : instance of JobDefinition;
kvps : dictionary of string;

begin

  // Reactivate the JobDefinition - this will only occur if it is in the 'Suspended' state
  theJobDefn := find_one JobDefinition (jobName = jobName);
  if theJobDefn /= null then
    // Check whether the respective JobDefinition is in the 'Suspended' state.
    if theJobDefn.isSuspended /= true then
      Logger::log(Logger::Warning, "pv.sv.reactivatejobdefinition",
        svLog("svdc_reactivation_failed", "Reactivation attempt of JobDefinition failed because it was not in the SUSPENDED state", "", jobName, kvps));
    else
       // Reactivate the suspended JobDefinition
       generate JobDefinition.reactivate() to theJobDefn;
    end if;
  else
    // 
    Logger::log(Logger::Warning, "pv.sv.reactivatejobdefinition",
      svLog("svdc_unknown_job", "Job Definition specified for reactivation is unknown", "", jobName, kvps));
  
  end if;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'e02e51d5-9455-4a34-b8c1-e2c7f0a628ed' DO NOT EDIT THIS LINE.
public service AESequenceDC::extraJobInvariantDefinition ( auditEventDataName : in string,
                                                          sourceJobDefnName : in string,
                                                          sourceEventType : in string,
                                                          sourceOccurrenceId : in integer,
                                                          userEvents : in sequence of userEventDataStructure ) is
sourceInvariantEventType : eventStructure;
invariantEventType : eventStructure;
kvps : dictionary of string;

begin

  kvps["auditEventDataName"] := auditEventDataName;
  Logger::log(Logger::Debug, "pv.sv.extrajobinvariantdefinition",
    svLog("svdc_invariant_defn", "Extra Job Invariant Definition added", "", sourceJobDefnName, kvps));

  sourceInvariantEventType := (sourceEventType,sourceOccurrenceId,"","");
  ExtraJobInvariantDefn.createSourceExtraJobInvariantDefn(sourceJobDefnName,auditEventDataName, sourceInvariantEventType, @P1D@);
  // TODO - the lifetime of the extra job invariant is currently fixed at 1 day (see last parameter in previous function call). This needs 
  // to be user-configurable and will require a change to the interface for the function 'extraJobInvaiantDefinition'.

  for userEvent in userEvents loop
    invariantEventType := (userEvent.auditEventType,userEvent.occurrenceId,"","");
    ExtraJobInvariantDefn.linkUserExtraJobInvariantDefn(userEvent.jobDefinitionName, auditEventDataName, invariantEventType);
  end loop;
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'a7653f36-7f90-48e4-b78f-af997de14261' DO NOT EDIT THIS LINE.
public service AESequenceDC::intraJobInvariantDefinition ( jobDefnName : in string,
                                                          auditEventDataName : in string,
                                                          associatedEvents : in sequence of intraJobInvDataStructure ) is
invariantEventType : eventStructure;
invariantEventTypes : sequence of eventStructure;
begin

  for associatedEvent in associatedEvents loop
    invariantEventType := (associatedEvent.auditEventType,associatedEvent.occurrenceId,"","");
    invariantEventTypes := invariantEventTypes & invariantEventType;
  end loop;
  IntraJobInvariantDefn.createIntraJobInvariantDefn(jobDefnName, auditEventDataName, invariantEventTypes);

end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '14010743-d12c-4236-a031-cc9825948007' DO NOT EDIT THIS LINE.
public service AESequenceDC::createDynamicControlDefinition ( jobName : in string,
                                                             dynamicControlName : in string,
                                                             dynamicControlType : in dynamicControlTypeEnum,
                                                             sourceEventType : in string,
                                                             sourceOccurrenceId : in integer,
                                                             userEventType : in string,
                                                             userOccurrenceId : in integer ) is
// This function defines the dynamic control, which is a loop count or a branch count, together with the event
// that provides it and the event that uses it. This function could be split such that the dynamic control is
// set up with just the source event and the user event linked in later on in a different call to a different 
// function.
//

begin
  DynamicControlDefinition.createDynamicControlDefinition (jobName,
  	                                                       dynamicControlName,
  	                                                       dynamicControlType,
  	                                                       sourceEventType,
  	                                                       sourceOccurrenceId);
  DynamicControlDefinition.linkUserEventDefn (jobName,
  	                                          dynamicControlName,
  	                                          dynamicControlType,
  	                                          userEventType,
  	                                          userOccurrenceId);
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '9ebd061a-f613-4920-9250-f9095dc73be3' DO NOT EDIT THIS LINE.
public service AESequenceDC::restoreInvariants ( restoredInvariants : in sequence of persistedInvariantStructure ) is
theRestoredExtraJobInvDefn : instance of ExtraJobInvariantDefn;
theAEOccurrenceDefn : instance of AEOccurrenceInSequenceDefinition;
theEventDefn : instance of SequencedAuditEventDefinition;
theJobDefn : instance of JobDefinition;
theJobs : set of instance of Job;
theRestoredPersistentInvariant : instance of PersistedInvariant;
existingInvariant : instance of PersistedInvariant;
theSystemSpec : instance of SystemSpecification;
kvps : dictionary of string;

begin
  for restoredInvariant in restoredInvariants loop
                
    theRestoredExtraJobInvDefn := find_one ExtraJobInvariantDefn (extraJobInvName = restoredInvariant.invariantName);
    if theRestoredExtraJobInvDefn /= null then    
      theRestoredExtraJobInvDefn.restoreInvariantOfThisDefinition (restoredInvariant);      
    
    else

      if (Logger::enabled(Logger::Debug, "pv.sv.restoreinvariants")) then
        kvps["invariantName"] := restoredInvariant.invariantName;
        Logger::log(Logger::Debug, "pv.sv.restoreinvariants",
          svLog("svdc_restore_invariant", "No Extra-Job Invariant Definition of the appropriate name was found so restoring the following Invariant cannot proceed", "", "", kvps));
      end if;

    end if;  
                 
  end loop;
  
  // Tell all extant Jobs that stored invariants have been found
  theJobs := find Job (jobCompleted = false);
  // generate event to all jobs here
  for eachJob in theJobs loop
    
    // TODO Remove debug message
    if (Logger::enabled(Logger::Debug, "pv.sv.restoreinvariants")) then
      Logger::log(Logger::Debug, "pv.sv.restoreinvariants",
        svLog("svdc_restore_invariant", "Additional Source Invariants found so re-evaluate the extra job invariants for Job", eachJob.jobID, "", kvps));
    end if;
    
    generate Job.StoredInvariantsReceived () to eachJob;
  end loop;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '589ab0f0-596d-403d-8d6a-7a6004724b5d' DO NOT EDIT THIS LINE.
public service AESequenceDC::createJobDefinition ( jobName : in string,
                                                  eventDefinitions : in sequence of eventDefinitionStructure ) is
theJobDefn : instance of JobDefinition;
kvps : dictionary of string;
begin
  theJobDefn := find_one JobDefinition (jobName = jobName);
  Logger::log(Logger::Debug, "pv.sv.createjobdefinition",
    svLog("svdc_create_job_defn", "new job definition", "", jobName, kvps));
  if theJobDefn = null then
    // Event Definition for new Job so create the Job Definition
    theJobDefn := create unique JobDefinition (jobName => jobName, isDeprecated => false, isSuspended => false, Current_State => Active);
    for eventDefinition in eventDefinitions loop
      Logger::log(Logger::Debug, "pv.sv.createjobdefinition",
        svLog("svdc_create_job_defn", "new event definition", "", jobName, kvps));
      AESequenceDC::eventDefinition(jobName, eventDefinition.sequenceName, eventDefinition.eventType, eventDefinition.occurrenceId, 
    		                          eventDefinition.previousEventTypes, eventDefinition.isSequenceStart, eventDefinition.isSequenceEnd, 
    		                          eventDefinition.isBreak, eventDefinition.isHappy, eventDefinition.isCritical);
    end loop;
  else
    Logger::log(Logger::Warning, "pv.sv.createjobdefinition",
      svLog("svdc_create_job_defn", "Updates for existing jobs not supported", "", jobName, kvps));
  end if;
     
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'db79ebe9-6208-482a-b58e-6dd4661cdb14' DO NOT EDIT THIS LINE.
private service AESequenceDC::svLog ( tag : in string,
                                     message : in string,
                                     jobId : in string,
                                     jobName : in string,
                                     key_value_pairs : in dictionary of string ) return string is
jsonElement : JSON::JSONElement;
key : string;
logMessageKeyValuePairs : dictionary of string;

begin
  logMessageKeyValuePairs["tag"] := tag;
  logMessageKeyValuePairs["message"] := message;
  logMessageKeyValuePairs["jobId"] := jobId;
  logMessageKeyValuePairs["jobName"] := jobName;
  for key in key_value_pairs'keys loop
    logMessageKeyValuePairs[key] := key_value_pairs[key];
  end loop;
  jsonElement := JSON::to_json( logMessageKeyValuePairs );
  return JSON::dump( jsonElement );
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

