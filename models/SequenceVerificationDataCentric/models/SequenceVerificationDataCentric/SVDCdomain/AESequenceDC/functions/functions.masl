//! ACTIVITY BEGIN. '298c8d7e-e4b9-4710-a16a-e892653eccda' DO NOT EDIT THIS LINE.
public service AESequenceDC::acceptOrderedEvent ( ae_time : in string,
                                                 app : in string,
                                                 ae_type : in string,
                                                 jobId : in string,
                                                 prevAEIds : in sequence of string,
                                                 id : in string,
                                                 auditEventData : in sequence of auditEventDataStructure ) is
existingJob : instance of Job;
theAuditEventDefinition : instance of AuditEventDefinition;
theJobDefinition : instance of JobDefinition;
logMessage : string;

begin
  // Check to see if the received event is part of a Job that is already being processed
  existingJob := find_only Job (jobID = jobId);
  if existingJob /= null then
    //We have an existing Job and this event should be the next in sequence for that Job
    generate Job.newEventForExistingJob (id, prevAEIds, ae_type, auditEventData) to existingJob;
  else
    // The received event must be for a new job, but before the event can be accepted we need to verify that 
    // the JobDefinition for this new job is neither Suspended nor Deprecated (if it is, the event cannot be accepted)
    theAuditEventDefinition := find_only AuditEventDefinition (AEType = ae_type);
    if theAuditEventDefinition /= null then
      // The ae_type is a known type - use this to find which JobDefinition it relates to and then verify that it is ACTIVE.
      theJobDefinition := theAuditEventDefinition -> R1.AESequenceDefinition -> R7;
      if (theJobDefinition.isSuspended = true) or (theJobDefinition.isDeprecated = true)then
        // Log info: The accepted event is for a new Job that has a non-active JobDefinition 
        logMessage := "The event - AuditEventId = " & id & "cannot be accepted because it relates to a new Job whose JobDefinition is either Suspended or Deprecated";
        Logger::log(Logger::Information, "AESequenceDC", logMessage);        
      else     
        //We have a new job and this event should be tested as a valid initial event for a Job
        //AuditEvent.AddEventForNewJob (jobId => jobId, eventID => id, prevEventId => prev, aeType => ae_type);
        AuditEvent.AddEventForNewJob (jobId, id, prevAEIds, ae_type, auditEventData);
      end;
    else
      // Log info: Report that the specified audit event type (ae_type) does not exist.
      logMessage := "Accepted event is of an unknown type - AEType = " & ae_type;
      Logger::log(Logger::Information, "AESequenceDC", logMessage); 
    end if;
  end if;
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'bb8ee068-445c-4b0a-95b8-d612dd1a0a6c' DO NOT EDIT THIS LINE.
public service AESequenceDC::failedJob ( jobId : in string,
                                        failureReason : in string ) is
theJob : instance of Job;

begin
  theJob := find_only Job (jobID = jobId);
  if theJob /= null then
    generate Job.jobFailed(failureReason) to theJob;
  end if;

end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '0178da63-222b-4260-8c2a-2d4c29ff808d' DO NOT EDIT THIS LINE.
public service AESequenceDC::jobComplete ( jobId : in string ) is
theJob : instance of Job;

begin
  //
  theJob := find_only Job (jobID = jobId);
  if theJob /= null then
    generate Job.jobTimedOut() to theJob;
  end if;
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'f0bfcefa-2cc9-4e61-81da-4571627deee7' DO NOT EDIT THIS LINE.
public service AESequenceDC::eventDefinition ( jobName : in string,
                                              sequenceName : in string,
                                              eventType : in string,
                                              occurrenceId : in integer,
                                              previousEventTypes : in sequence of eventStructure,
                                              isSequenceStart : in boolean,
                                              isSequenceEnd : in boolean,
                                              isBreak : in boolean ) is
theJobDefn : instance of JobDefinition;
theSequenceDefn : instance of AESequenceDefinition;
theEventDefn : instance of AuditEventDefinition;
theEventDefnsInSequence : set of instance of AuditEventDefinition;
matchingEventDefn : instance of AuditEventDefinition;
thePrevEventDefn : instance of AuditEventDefinition;
thePlaceholderEventDefn : instance of AuditEventDefinition;
theEventInSeqDef : instance of AEInSequenceDefinition;
thePlaceholderEventInSeqDef : instance of AEInSequenceDefinition;
theEventOccInSeqDef : instance of AEOccurrenceInSequenceDefinition;
thePlaceholderEventOccInSeqDef : instance of AEOccurrenceInSequenceDefinition;
thePrevEventInSeqDefn : instance of AEInSequenceDefinition;
thePrevEventOccInSeqDefn : instance of AEOccurrenceInSequenceDefinition;
existingEventOccurrencesInSeqDefn : set of instance of AEOccurrenceInSequenceDefinition;
newEventInSeqPairDef : instance of AEInSequencePairDefn;
theConstraintDefn : instance of ConstraintDefinition;
logMessage : string;
previousEventType : eventStructure;

//
begin
  theJobDefn := find_one JobDefinition (jobName = jobName);
  if theJobDefn = null then
    // Event Definition for new Job so create the Job Definition
    theJobDefn := create unique JobDefinition (jobName => jobName, isDeprecated => false, isSuspended => false, Current_State => Active);
  end if; 
     
  theSequenceDefn := find_one AESequenceDefinition (sequenceDefinitionName = sequenceName);
  if theSequenceDefn = null then
    // Event Definition for new Sequence so create the Sequence Definition
    theSequenceDefn := create unique AESequenceDefinition (sequenceDefinitionName => sequenceName);
    link theSequenceDefn R7 theJobDefn;
  end if;
   
  theEventDefn := find_one AuditEventDefinition (AEType = eventType);
  if theEventDefn = null then
    // The event definition hasn't been seen before so is a valid addition
    theEventDefn := create unique AuditEventDefinition (AEType => eventType); 
    theEventInSeqDef := create AEInSequenceDefinition (AEDefinitionId => theEventDefn.AEDefinitionId, AESequenceId => theSequenceDefn.AESequenceId);
    link theEventDefn R1 theSequenceDefn using theEventInSeqDef;
    theEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (
    	                                                            AEDefinitionId => theEventDefn.AEDefinitionId, 
    	                                                            AESequenceId => theSequenceDefn.AESequenceId, 
    	                                                            occurrenceNumberInSequence => occurrenceId, 
    	                                                            isSequenceStart => isSequenceStart, 
    	                                                            isSequenceEnd => isSequenceEnd,
                                                                    isBreak => isBreak);
    link theEventOccInSeqDef R12 theEventInSeqDef;
  else
    // The event definition has been seen before which could indicate the repetition of an event type in a sequence
    theEventDefnsInSequence := theSequenceDefn -> R1.AuditEventDefinition;
    matchingEventDefn := find_one theEventDefnsInSequence (AEType = eventType);
    if matchingEventDefn /= null then
      // We have already seen this event type which could be because of a placeholder event definition or because of a repeated occurrence of an event definition
      // A placeholder event definition occurs where a cyclic topology is defined. The backwards connection means that the previous event the the current event has not been seen yet.
      theEventInSeqDef := matchingEventDefn with theSequenceDefn -> R1.AEInSequenceDefinition;
      // Check to see if the event definition already exists because of a placeholder
      thePlaceholderEventOccInSeqDef := find_one (theEventInSeqDef -> R12)(isPlaceholder = true);
      if thePlaceholderEventOccInSeqDef = null then
        // This is a repetition of this event type in the sequence so add a new occurrence accordingly
        theEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (                  
      	                                                              AEDefinitionId => theEventDefn.AEDefinitionId, 
      	                                                              AESequenceId => theSequenceDefn.AESequenceId, 
      	                                                              occurrenceNumberInSequence => occurrenceId, 
      	                                                              isSequenceStart => isSequenceStart, 
      	                                                              isSequenceEnd => isSequenceEnd
                                                                      );
        link theEventInSeqDef R12 theEventOccInSeqDef;
      else
        // It is a placeholder so now we've seen it for real we can clear the isPlaceholder flag and set the other flags according to input data
        thePlaceholderEventOccInSeqDef.isPlaceholder := false;
        thePlaceholderEventOccInSeqDef.isSequenceEnd := isSequenceStart;
        thePlaceholderEventOccInSeqDef.isSequenceEnd := isSequenceEnd;
        thePlaceholderEventOccInSeqDef.isBreak := isBreak;
        theEventOccInSeqDef := thePlaceholderEventOccInSeqDef;
      end if;  
    else  
      // For now assume this is not allowed. TODO Check to see if the same event type can legitimately occur in different Job Types and Sequences
      logMessage := "The event type provided in the initialisation data has been seen elsewhere , Job Definition = " & theJobDefn.jobName & ", Sequence Definition = " & theSequenceDefn.sequenceDefinitionName & ", Event type = " & theEventDefn.AEType;
	  Logger::log(Logger::Error, "AESequenceDC", logMessage);            
    end if;
  end if;
  
  for previousEventType in previousEventTypes'elements loop
      thePrevEventDefn := find_one AuditEventDefinition (AEType = previousEventType.eventTypeName);
      if thePrevEventDefn /= null then
        thePrevEventInSeqDefn :=  thePrevEventDefn with theSequenceDefn -> R1.AEInSequenceDefinition;
        existingEventOccurrencesInSeqDefn := thePrevEventInSeqDefn -> R12;
        thePrevEventOccInSeqDefn := find_one existingEventOccurrencesInSeqDefn (occurrenceNumberInSequence = previousEventType.occurrenceId);
        if thePrevEventOccInSeqDefn /= null then
          newEventInSeqPairDef := create AEInSequencePairDefn (
        	                                                 AESequenceId => theSequenceDefn.AESequenceId, 
        	                                                 followingAEDefinitionId => theEventOccInSeqDef.AEDefinitionId, 
        	                                                 precedingAEDefinitionId => thePrevEventOccInSeqDefn.AEDefinitionId, 
        	                                                 followingoccurrenceNumberInSequence => theEventOccInSeqDef.occurrenceNumberInSequence, 
        	                                                 precedingoccurrenceNumberInSequence => thePrevEventOccInSeqDefn.occurrenceNumberInSequence
                                                             );
          link thePrevEventOccInSeqDefn R6.precedes theEventOccInSeqDef using newEventInSeqPairDef;
          theConstraintDefn := find_one ConstraintDefinition (constraintDefnId = previousEventType.constraintDefId and jobName = theJobDefn.jobName);
          if theConstraintDefn /= null and (theConstraintDefn.constraintType'image = previousEventType.constraintValue) then
            // This is an existing known constraint so this is an additional event pair in that constraint
            link newEventInSeqPairDef R16 theConstraintDefn;
          elsif previousEventType.constraintDefId /= "" then
            // This is a new constraint
            if previousEventType.constraintValue = "AND" then
              theConstraintDefn := create ConstraintDefinition (constraintDefnId => previousEventType.constraintDefId, jobName => theJobDefn.jobName, constraintType => AND );
            elsif previousEventType.constraintValue = "XOR" then
              theConstraintDefn := create ConstraintDefinition (constraintDefnId => previousEventType.constraintDefId, jobName => theJobDefn.jobName, constraintType => XOR );
            elsif previousEventType.constraintValue = "LOOPCOUNT" then
              theConstraintDefn := create ConstraintDefinition (constraintDefnId => previousEventType.constraintDefId, jobName => theJobDefn.jobName, constraintType => LOOPCOUNT );
            elsif previousEventType.constraintValue = "BRANCHCOUNT" then
              theConstraintDefn := create ConstraintDefinition (constraintDefnId => previousEventType.constraintDefId, jobName => theJobDefn.jobName, constraintType => BRANCHCOUNT );
            else
              logMessage := "Invalid Constraint Value provided : " & previousEventType.constraintValue & "in Job Name = " & jobName;
	          Logger::log(Logger::Error, "AESequenceDC", logMessage);            
            end if;
            if theConstraintDefn /= null then
              link theConstraintDefn R17 theJobDefn;
              link newEventInSeqPairDef R16 theConstraintDefn;
            end if;  
          elsif previousEventType.constraintDefId = "" then
            // No constraint specified which is valid
          else
            logMessage := "Invalid Constraint Definition provided : " & previousEventType.constraintDefId & "in Job Name = " & jobName;
	        Logger::log(Logger::Error, "AESequenceDC", logMessage);            
          end if;
        else
          // We have a reference to a forward event which is possible in the case of cyclic sequences so create a placeholder event
          // In this case the event definition has been seen before but not this referenced occurrence number
          thePlaceholderEventDefn := thePrevEventDefn; 
          thePlaceholderEventInSeqDef := thePlaceholderEventDefn with theSequenceDefn -> R1;
          thePlaceholderEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (
    	                                                            AEDefinitionId => thePlaceholderEventDefn.AEDefinitionId, 
    	                                                            AESequenceId => theSequenceDefn.AESequenceId, 
    	                                                            occurrenceNumberInSequence => previousEventType.occurrenceId, 
    	                                                            //isSequenceStart => isSequenceStart, 
    	                                                            //isSequenceEnd => isSequenceEnd,
    	                                                            isPlaceholder => true
                                                                    );
          link thePlaceholderEventOccInSeqDef R12 thePlaceholderEventInSeqDef;
          newEventInSeqPairDef := create AEInSequencePairDefn (
        	                                                 AESequenceId => theSequenceDefn.AESequenceId, 
        	                                                 followingAEDefinitionId => theEventOccInSeqDef.AEDefinitionId, 
        	                                                 precedingAEDefinitionId => thePlaceholderEventOccInSeqDef.AEDefinitionId, 
        	                                                 followingoccurrenceNumberInSequence => theEventOccInSeqDef.occurrenceNumberInSequence, 
        	                                                 precedingoccurrenceNumberInSequence => thePlaceholderEventOccInSeqDef.occurrenceNumberInSequence
                                                             );
          link thePlaceholderEventOccInSeqDef R6.precedes theEventOccInSeqDef using newEventInSeqPairDef;
        
        
        end if;
      else
        // We have a reference to a forward event which is possible in the case of cyclic sequences so create a placeholder event
        thePlaceholderEventDefn := create unique AuditEventDefinition (AEType => previousEventType.eventTypeName); 
        thePlaceholderEventInSeqDef := create AEInSequenceDefinition (AEDefinitionId => thePlaceholderEventDefn.AEDefinitionId, AESequenceId => theSequenceDefn.AESequenceId);
        link thePlaceholderEventDefn R1 theSequenceDefn using thePlaceholderEventInSeqDef;
        thePlaceholderEventOccInSeqDef := create AEOccurrenceInSequenceDefinition (
    	                                                            AEDefinitionId => thePlaceholderEventDefn.AEDefinitionId, 
    	                                                            AESequenceId => theSequenceDefn.AESequenceId, 
    	                                                            occurrenceNumberInSequence => previousEventType.occurrenceId, 
    	                                                            isSequenceStart => isSequenceStart, 
    	                                                            isSequenceEnd => isSequenceEnd,
    	                                                            isPlaceholder => true
                                                                    );
        link thePlaceholderEventOccInSeqDef R12 thePlaceholderEventInSeqDef;
        newEventInSeqPairDef := create AEInSequencePairDefn (
        	                                                 AESequenceId => theSequenceDefn.AESequenceId, 
        	                                                 followingAEDefinitionId => theEventOccInSeqDef.AEDefinitionId, 
        	                                                 precedingAEDefinitionId => thePlaceholderEventOccInSeqDef.AEDefinitionId, 
        	                                                 followingoccurrenceNumberInSequence => theEventOccInSeqDef.occurrenceNumberInSequence, 
        	                                                 precedingoccurrenceNumberInSequence => thePlaceholderEventOccInSeqDef.occurrenceNumberInSequence
                                                             );
        link thePlaceholderEventOccInSeqDef R6.precedes theEventOccInSeqDef using newEventInSeqPairDef;
        
        
        // The previous event definition provided is unknown
        //logMessage := "Previous event types provided in the initialisation data are unknown, Job Definition = " & theJobDefn.jobName & ", Sequence Definition = " & theSequenceDefn.sequenceDefinitionName & ", Event type = " & theEventDefn.AEType& ", Previous event type = " & previousEventType.eventTypeName;
	    //Logger::log(Logger::Error, "AESequenceDC", logMessage);                  
      end if;

//      logMessage := "Multiple previous event types provided in the initialisation data. Not currently supported, Job Definition = " & theJobDefn.jobName & ", Sequence Definition = " & theSequenceDefn.sequenceDefinitionName & ", Event type = " & theEventDefn.AEType;
//	  Logger::log(Logger::Error, "AESequenceDC", logMessage);            
        
//    end if;
  end loop;
  //
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'ad9b6852-61ff-4b7e-9f03-426846633e70' DO NOT EDIT THIS LINE.
private service AESequenceDC::deleteJob ( jobId : in string ) is
theJob : instance of Job;
logMessage : string;

begin

  theJob := find_one Job (jobID = jobId);
  if theJob /= null then
    theJob.deleteJob();

  else

    logMessage := "jobId provided is unknown " & jobId;
	Logger::log(Logger::Information, "AESequenceDC", logMessage);
      
  end if;
  //
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '8548b0fd-27ba-42ee-b392-3098142e30ed' DO NOT EDIT THIS LINE.
public service AESequenceDC::deprecateJobDefinition ( jobName : in string ) is
theJobDefn : instance of JobDefinition;
logMessage : string;

begin

  // Move the JobDefinition into the 'Deprecated' state and wait for all outstanding Jobs of that 
  // type to complete (either successful for fail) before automatically deleting it.
  theJobDefn := find_one JobDefinition (jobName = jobName);
  if theJobDefn /= null then
    generate JobDefinition.deprecate() to theJobDefn;
  else
  
    logMessage := "Job Definition specified for deprecation is unknown - jobName " & jobName;
	Logger::log(Logger::Information, "AESequenceDC", logMessage);
  
  end if;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'ecc6c890-af9e-41d7-a4a0-cad083920fdf' DO NOT EDIT THIS LINE.
public service AESequenceDC::createSVDCsystemSpec ( maxIntraSequenceEventTimeoutPeriod : in duration,
                                                   waitPeriodForAllJobsCompletedCheck : in duration,
                                                   waitPeriodForJobDeletion : in duration,
                                                   waitPeriodForInvariantDeletion : in duration ) is
theSVDCSystemSpec : instance of SystemSpecification;
begin
  theSVDCSystemSpec := create unique SystemSpecification (intraSequenceEventTimeoutPeriod => maxIntraSequenceEventTimeoutPeriod,
  	                                                      checkJobDefReadyForDeletionPeriod => waitPeriodForAllJobsCompletedCheck,
  	                                                      jobDeletionWaitPeriod => waitPeriodForJobDeletion,
  	                                                      sourceExtraJobInvariantDeletionPeriod => waitPeriodForInvariantDeletion);
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'e933a4e5-fd85-42d8-9e5f-43423ba863e4' DO NOT EDIT THIS LINE.
public service AESequenceDC::suspendJobDefinition ( jobName : in string ) is
theJobDefn : instance of JobDefinition;
logMessage : string;

begin

  // Move the JobDefinition into the 'Suspended' state - in this state no further new Jobs of this type
  // will be processed until returned back to the 'Active' state.
  theJobDefn := find_one JobDefinition (jobName = jobName);
  if theJobDefn /= null then
    // Note that if the Job is not in the 'Active' state then the suspension attempt will be ignored.
    generate JobDefinition.suspend() to theJobDefn;
  else
  
    logMessage := "The JobDefinition specified for suspension is unknown - jobName " & jobName;
	Logger::log(Logger::Information, "AESequenceDC", logMessage);
  
  end if;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '9ff9de0d-be3c-4799-94fd-023a6a83a934' DO NOT EDIT THIS LINE.
public service AESequenceDC::reactivateJobDefinition ( jobName : in string ) is
theJobDefn : instance of JobDefinition;
logMessage : string;

begin

  // Reactivate the JobDefinition - this will only occur if it is in the 'Suspended' state
  theJobDefn := find_one JobDefinition (jobName = jobName);
  if theJobDefn /= null then
    // Check whether the respective JobDefinition is in the 'Suspended' state.
    if theJobDefn.isSuspended /= true then
      logMessage := "Reactivation attempt of JobDefinition - jobName " & jobName & "failed because it was not in the SUSPENDED state";
	  Logger::log(Logger::Information, "AESequenceDC", logMessage);
	else
	   // Reactivate the suspended JobDefinition
       generate JobDefinition.reactivate() to theJobDefn;
    end if;
  else
    // 
    logMessage := "The JobDefinition specified for reactivation is unknown - jobName " & jobName;
	Logger::log(Logger::Information, "AESequenceDC", logMessage);
  
  end if;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'e02e51d5-9455-4a34-b8c1-e2c7f0a628ed' DO NOT EDIT THIS LINE.
public service AESequenceDC::extraJobInvariantDefinition ( auditEventDataName : in string,
                                                          sourceJobDefnName : in string,
                                                          sourceEventType : in string,
                                                          sourceOccurrenceId : in integer,
                                                          userEvents : in sequence of userEventDataStructure ) is
sourceInvariantEventType : eventStructure;
invariantEventType : eventStructure;

begin
  sourceInvariantEventType := (sourceEventType,sourceOccurrenceId,"","");
  ExtraJobInvariantDefn.createSourceExtraJobInvariantDefn(sourceJobDefnName,auditEventDataName, sourceInvariantEventType, @P1D@);

  for userEvent in userEvents loop
    invariantEventType := (userEvent.auditEventType,userEvent.occurrenceId,"","");
    ExtraJobInvariantDefn.linkUserExtraJobInvariantDefn(userEvent.jobDefinitionName, auditEventDataName, invariantEventType);
  end loop;
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'a7653f36-7f90-48e4-b78f-af997de14261' DO NOT EDIT THIS LINE.
public service AESequenceDC::intraJobInvariantDefinition ( jobDefnName : in string,
                                                          auditEventDataName : in string,
                                                          associatedEvents : in sequence of intraJobInvDataStructure ) is
invariantEventType : eventStructure;
invariantEventTypes : sequence of eventStructure;
begin
  
  for associatedEvent in associatedEvents loop
    invariantEventType := (associatedEvent.auditEventType,associatedEvent.occurrenceId,"","");
    invariantEventTypes := invariantEventTypes & invariantEventType;
  end loop;
  IntraJobInvariantDefn.createIntraJobInvariantDefn(jobDefnName, auditEventDataName, invariantEventTypes);

  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '14010743-d12c-4236-a031-cc9825948007' DO NOT EDIT THIS LINE.
public service AESequenceDC::dynamicControlDefinition ( jobName : in string,
                                                       dynamicControlName : in string,
                                                       dynamicControlType : in dynamicControlTypeEnum,
                                                       sourceEventType : in string,
                                                       sourceOccurrenceId : in integer,
                                                       userEventType : in string,
                                                       userOccurrenceId : in integer ) is
// This function defines the dynamic control, which is a loop count or a branch count, together with the event
// that provides it and the event that uses it. This function could be split such that the dynamic control is
// set up with just the source event and the user event linked in later on in a different call to a different 
// function.
begin
  DynamicControlDefinition.createDynamicControlDefinition (jobName,
  	                                                       dynamicControlName,
  	                                                       dynamicControlType,
  	                                                       sourceEventType,
  	                                                       sourceOccurrenceId);
  DynamicControlDefinition.linkUserEventDefn (jobName,
  	                                          dynamicControlName,
  	                                          dynamicControlType,
  	                                          userEventType,
  	                                          userOccurrenceId);
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

