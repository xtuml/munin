//! ACTIVITY BEGIN. 'd011774c-53f3-4995-b8bf-9a4879033d00' '4363c1b5-2587-4a86-9702-c5975f4b2816' DO NOT EDIT THIS LINE.
state AESequenceDC::Job.JobInProgress ( eventId : in string,
                                       prevAEIds : in sequence of string,
                                       aeType : in string,
                                       aeData : in sequence of auditEventDataStructure ) is
newEvent : instance of AuditEvent;
existingEvent : instance of AuditEvent;
theEventType : instance of AuditEventDefinition;
prevEvent : instance of AuditEvent;
prevEventIsValid : boolean;
theAeSequenceDef : instance of AESequenceDefinition;
theAeOccInSequenceDef : instance of AEOccurrenceInSequenceDefinition;
theAeOccurrencesInSequenceDef : set of instance of AEOccurrenceInSequenceDefinition;
prevAeOccInSequenceDef : instance of AEOccurrenceInSequenceDefinition;
expectedAeOccsInSequenceDef : set of instance of AEOccurrenceInSequenceDefinition;
possibleAeOccInSequenceDef : set of instance of AEOccurrenceInSequenceDefinition;
theAeInSequenceDef : instance of AEInSequenceDefinition;
aeSequenceDefs : set of instance of AESequenceDefinition;
theSequenceDef : instance of AESequenceDefinition;
theAeInSequencePairDefn : instance of AEInSequencePairDefn;
existingAuditEventPair : instance of AuditEventPair;
newAuditEventPair : instance of AuditEventPair;
theAuditEventPairs : set of instance of AuditEventPair;
currentSequence : instance of Sequence;
newSequence : instance of Sequence;
incompleteSequences : set of instance of Sequence;
incompleteSequence : instance of Sequence;
completeSequences : set of instance of Sequence;
sequencesForJob : set of instance of Sequence;
aeDataElement : auditEventDataStructure;
newIntraJobInvariant : instance of TransientInvariant;
theIntraJobInvariantDefn : instance of IntraJobInvariantDefn;
theSourceExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;
theUserExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;
theSourceExtraJobInvariant : instance of PersistedInvariant;
theUserExtraJobInvariant : instance of TransientInvariant;
theDynamicControlDefn : instance of DynamicControlDefinition;
theDynamicControlDefns : set of instance of DynamicControlDefinition;
theExistingDynamicControls : set of instance of DynamicControl;
newDynamicControl : instance of DynamicControl;
theUserDynamicControlDefn : instance of DynamicControlDefinition;
theCurrentDynamicControlDefn : instance of DynamicControlDefinition;
theUserDynamicControl : instance of DynamicControl;
thisJobsDynamicControl : instance of DynamicControl;
thisJobsDynamicControls : set of instance of DynamicControl;
theDynamicControls : set of instance of DynamicControl;
theSourceDynamicControl : instance of DynamicControl;
theCurrentDynamicControls : set of instance of DynamicControl;
thePrevUserDynamicControlDefn : instance of DynamicControlDefinition;
thePrevSourceDynamicControl : instance of DynamicControl;
thePrevUserDynamicControl : instance of DynamicControl;
thePrevUserDynamicControls : set of instance of DynamicControl;
theCandidatePrevUserDynamicControl : instance of DynamicControl;
theCandidatePrevUserDynamicControlDefn : instance of DynamicControlDefinition;
thePrevUserBranchPoints : set of instance of DynamicControl;
allPrevUserBranchPoints : set of instance of DynamicControl;
emptyPrevUserDynamicControl : instance of DynamicControl;
loopCount : integer;
branchCount : integer;
auditEventDataProcessed : boolean;
empty : sequence of string;
emptyPrevId : sequence of string:= empty & "";
lastPreviousEventId : string;
instanceForkFound : boolean;
logMessage : string;
failureMessage : string;
creationErrorMessage : string;


begin
  // Check to see if we've seen this event instance before
  existingEvent := find_one AuditEvent (AuditEventId = eventId);
  if existingEvent = null then
    // The received event has not been seen before, so link the new event to this Job.
    newEvent := create AuditEvent (AuditEventId => eventId, seenAsPreviousEvent => false);
    link this R3 newEvent;
    theEventType := find_only AuditEventDefinition (AEType = aeType);
    if theEventType /= null then
      // We have a valid event type
      link newEvent R2 theEventType;
      
      // Next, determine if the received event is of a type that is expected for the stated previous event - firstly
      // find the set of occurrences of the received event type for the sequence
      theSequenceDef := theEventType -> R1.AESequenceDefinition;
      theAeInSequenceDef := theSequenceDef with theEventType -> R1.AEInSequenceDefinition;
      theAeOccurrencesInSequenceDef := theAeInSequenceDef -> R12;
      
      // ...and then check that just one of these matches with an event occurrence that is expected for the previous event
      if (prevAEIds /= empty) and (prevAEIds /= emptyPrevId) then
        // Log info: Event has previous event ids
        logMessage := "AESequenceDC::Job.JobInProgress : Follow on event (" & eventId & ") for existing Job received with jobId = " & this.jobID & ", current event type = " & theEventType.AEType & " with " & prevAEIds'length'image & " previous event ids";
	    Logger::log(Logger::Debug, "AESequenceDC", logMessage);   

        auditEventDataProcessed := false;
        for aPrevEventId in prevAEIds loop 
          // Need to locate the previous event as defined in the event parameter
          prevEvent := find_one AuditEvent (AuditEventId = aPrevEventId);
          if prevEvent /= null then
            prevAeOccInSequenceDef := prevEvent -> R13;
            // Find the occurrence definitions for the events that are expected to follow that one as our new event should be one of those
            expectedAeOccsInSequenceDef := prevAeOccInSequenceDef -> R6.precedes.AEOccurrenceInSequenceDefinition;
      
            possibleAeOccInSequenceDef := expectedAeOccsInSequenceDef intersection theAeOccurrencesInSequenceDef;

            if (possibleAeOccInSequenceDef'length = 1) then
              theAeOccInSequenceDef := find_one possibleAeOccInSequenceDef ();
              // We have found the occurrence definition class to link with the new event
              if (newEvent -> R13 = null) then
                link theAeOccInSequenceDef R13 newEvent;
              end if;
          
              if theAeOccInSequenceDef.isSequenceStart = false then
	                 
                // We have a follow on event for an existing Job with a valid previous event
                theAeInSequencePairDefn := theAeOccInSequenceDef with prevAeOccInSequenceDef -> R6.follows.AEInSequencePairDefn;
                // Check that the previous event has not already been seen with this event as that would be an error
                existingAuditEventPair := find_one AuditEventPair (previousAuditEventId = prevEvent.AuditEventId and
                	                                               nextAuditEventId = newEvent.AuditEventId);
               
                if existingAuditEventPair = null then
                  // Link the new event to the previous event to capture the sequence we are seeing
                  newAuditEventPair := create AuditEventPair (previousAuditEventId => prevEvent.AuditEventId,
                                                              nextAuditEventId => newEvent.AuditEventId);
                  link newEvent R4.has_previous.AuditEvent prevEvent using newAuditEventPair;
                  link newAuditEventPair R15 theAeInSequencePairDefn;
                else
                    this.sequencingFailed := true;
                    this.failJob("The previous event has been repeated with this event which is an error for jobId = " & this.jobID & " , current event type = " & theEventType.AEType & " , Event Id = " & newEvent.AuditEventId & " and Previous Event Id = " & prevEvent.AuditEventId );              
                end if;  
             
                // Now test to see if this is a valid event sequence
                newEvent.TestPreviousEventIsValid (prevEvent, prevEventIsValid); 
                if prevEventIsValid then
                  // Previous event is valid 
                  //logMessage := "AESequenceDC::Job.JobInProgress : Previous event is valid - jobId = " & this.jobID & ", audit event sequence = " & theSequenceDef.sequenceDefinitionName & ", current event type = " & theEventType.AEType;
	              //Logger::log(Logger::Debug, "AESequenceDC", logMessage);    
                  // The new event is a follow on event to the previous event so we know it is part of the same sequence as the previous event
                  currentSequence := prevEvent -> R11;
                  if currentSequence /= null then
                    if (newEvent -> R11 = null) then
                      link newEvent R11 currentSequence;
                    end if;  
                    if prevEvent.seenAsPreviousEvent = false then
                      //Implementation of part of the Hanrahan algorithm
                      currentSequence.branchExtent := currentSequence.branchExtent - 1;
                    end if;
                    // Note that the previous Audit Event has now been seen as a previous audit event       
                    prevEvent.seenAsPreviousEvent := true;


                
                    // Process the audit event data for this new event 
                    // checking we haven't already added the audit event data for this event
                    // This approach is a bit clunky but ensures we don't try to add the audit event data more than once
                    if auditEventDataProcessed = false then
                      newEvent.ProcessAuditEventData (aeData);
                      auditEventDataProcessed := true;
                    end if;  
      



              
                    // Add logic for incrementing Loop Count
                    theUserDynamicControlDefn := theAeOccInSequenceDef -> R31;
                    if theUserDynamicControlDefn /= null then                      
                      thisJobsDynamicControls := this -> R35;
                      
                      theUserDynamicControl := find_one thisJobsDynamicControls (dynamicControlName = theUserDynamicControlDefn.dynamicControlName );
                      if theUserDynamicControl /= null and theUserDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.LOOPCOUNT then
                        if (theUserDynamicControl -> R36) = null then
                          link theUserDynamicControl R36 newEvent;
                        end if;                      
                    
                        if theUserDynamicControl.expectedDynamicControlValue > 0 then
                          if theUserDynamicControl.currentDynamicControlValue < theUserDynamicControl.expectedDynamicControlValue then
                            theUserDynamicControl.currentDynamicControlValue := theUserDynamicControl.currentDynamicControlValue + 1;
                          else
                            this.failJob("The loop count will exceed the expected loop count which is an error for jobId = " & this.jobID & " , current event type = " & theEventType.AEType & " , Event Id = " & newEvent.AuditEventId ); 
                          end if;                 
                        end if;  
                        
	                  else
                        logMessage := "AESequenceDC::Job.JobInProgress : This event is not carrying a Dynamic Control of type " & theUserDynamicControlDefn.dynamicControlType'image & " for " & this.jobID;
	                    Logger::log(Logger::Debug, "AESequenceDC", logMessage);
	                  end if;  
	                  
	                else 
	                  // This event doesn't have an event that has a loop count defined on it and so can be ignored
	                end if;  

                    // Check to see if this is a break event causing us to exit a loop and cancel the loop count
                    // TODO Is there a better way to do this now R36 and R37 have been added
                    if theAeOccInSequenceDef.isBreak = true then
                      thisJobsDynamicControls := this -> R35;
                      theCurrentDynamicControls := find thisJobsDynamicControls (expectedDynamicControlValue > 0);
                      for theCurrentDynamicControl in theCurrentDynamicControls loop
                        theCurrentDynamicControlDefn := theCurrentDynamicControl -> R29;
                        if theCurrentDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.LOOPCOUNT then
                          theCurrentDynamicControl.expectedDynamicControlValue := 0;
                        end if;
                      end loop;
                    end if;
	                

                    // Add logic for creating user Branch Count on Fork event
                    theUserDynamicControlDefn := theAeOccInSequenceDef -> R31;
                    if theUserDynamicControlDefn /= null and theUserDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.BRANCHCOUNT then                      

                      // We know this event is a fork point so find the corresponding source event to get the number of branches expected

                      theDynamicControls := theUserDynamicControlDefn -> R29;
                      theSourceDynamicControl := find_one theDynamicControls (isUser = false);
                      if theSourceDynamicControl /= null then
 
                        theUserDynamicControl := newEvent -> R36;
                        if theUserDynamicControl = null then
                          theUserDynamicControl := create unique DynamicControl (expectedDynamicControlValue => theSourceDynamicControl.expectedDynamicControlValue,
                            	                                                 currentDynamicControlValue => 0,
                            	                                                 isUser => true);
                          link theUserDynamicControl R36 newEvent;
                          link theUserDynamicControl R29 theUserDynamicControlDefn;
                          link theUserDynamicControl R35 this;

                        else
                          //this.failJob("This event already has a user branch count associated with it for jobId = " & this.jobID & " , current event type = " & theEventType.AEType & " , Event Id = " & newEvent.AuditEventId ); 

                        end if;  
                    
	                  else
                        this.failJob("The fork point has been found but no corresponding source branch count is associated with it for jobId = " & this.jobID & " , current event type = " & theEventType.AEType & " , Event Id = " & newEvent.AuditEventId ); 
	                  end if;  
	                  
	                else 
	                  // This event doesn't have an event that has a loop count defined on it and so can be ignored
	                end if;  

                    // Add logic for incrementing Branch Count - to count branches from a fork we have to look to see if the previous event was the fork event with a branch count on it.

                    thePrevUserDynamicControl := prevEvent -> R36;
                    if thePrevUserDynamicControl /= null and thePrevUserDynamicControl.isUser then
                      thePrevUserDynamicControl.currentDynamicControlValue := thePrevUserDynamicControl.currentDynamicControlValue + 1;
                      
                    end if;


                  
                    // TODO Verify this optional section is required
                    // Don't allow an instance branch unless there is a branch count defined
                    // This is an optional capability that adds extra verification. Without it instance branches
                    // can occur anywhere with any number of branches.
                    
                    theAeInSequencePairDefn := theAeOccInSequenceDef with prevAeOccInSequenceDef -> R6.follows.AEInSequencePairDefn;
                    theAuditEventPairs := theAeInSequencePairDefn -> R15;
                    if theAuditEventPairs'length > 1 then
                      // There is either an instance fork or a loop so check that the AuditEventPairs have a common previous event to find the instance fork
                      for eachAuditEventPair in theAuditEventPairs loop
                        if eachAuditEventPair.previousAuditEventId = lastPreviousEventId then
                          instanceForkFound := true;
                          exit;
                        end if;  
                        lastPreviousEventId := eachAuditEventPair.previousAuditEventId;
                      end loop;
                      if instanceForkFound then
                      
                        // There is an instance fork so check that the previous event is a user of a branch count
                        thePrevUserDynamicControl := prevEvent -> R36;
                        if thePrevUserDynamicControl /= null and thePrevUserDynamicControl.isUser then                        
                          thePrevUserDynamicControlDefn := thePrevUserDynamicControl -> R29;
                          if thePrevUserDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.BRANCHCOUNT and thePrevUserDynamicControl.expectedDynamicControlValue > 0 then
                            logMessage := "AESequenceDC::Job.JobInProgress : Valid Branch Count found on instance fork in Job = " & this.jobID & " at Event Type = " & (prevEvent -> R2).AEType;
	                        Logger::log(Logger::Debug, "AESequenceDC", logMessage);                       
                          else
                            this.failJob("There is no Branch Count defined for this fork point in Job = " & this.jobID & " at Event Type = " & (prevEvent -> R2).AEType);                         
                          end if;

                        else
                          // An instance fork has occurred but the Job Definition does not expect this to occur at this point in the sequence.
                          this.failJob("There is no Branch Count defined for this fork point in Job = " & this.jobID & " at Event Type = " & (prevEvent -> R2).AEType);
                        end if;
                      else
                        // There is no instance fork here so carry on
                      end if;
                    else
                      // There is no instance fork here so carry on
                    end if;  
                    // End of optional section which adds a constraint that instance forks are not allowed if there is no branch count on the fork event

                    // Add logic for setting Merge Count
                    theUserDynamicControlDefn := theAeOccInSequenceDef -> R31;
                    if theUserDynamicControlDefn /= null and theUserDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.MERGECOUNT then                      
                      thisJobsDynamicControls := this -> R35;
                      
                      theUserDynamicControl := find_one thisJobsDynamicControls (dynamicControlName = theUserDynamicControlDefn.dynamicControlName);
                      if theUserDynamicControl /= null then
                        if (theUserDynamicControl -> R36) = null then
                          link theUserDynamicControl R36 newEvent;
                        end if;                      
                        if theUserDynamicControl.expectedDynamicControlValue > 0 then
                          // The current Merge count value is set to the number of previous event ids
                          theUserDynamicControl.currentDynamicControlValue := prevAEIds'length;                                           
                        end if;  
	                  else
                        logMessage := "AESequenceDC::Job.JobInProgress : There is no event using a Dynamic Control of type " & theUserDynamicControlDefn.dynamicControlType'image & " for " & this.jobID;
	                    Logger::log(Logger::Debug, "AESequenceDC", logMessage);
	                  end if;  

	                  
	                else 
	                  // This event doesn't have an event that has a loop count defined on it and so can be ignored
	                end if;  
                    
                  else
                    //Log Job failure: Previous event is valid but is part of a broken sequence
                    this.sequencingFailed := true;
                    this.failJob("The previous event is valid but is part of a broken sequence - Event Type = " & (prevEvent -> R2).AEType);
                  end if;  
          
                else
                  //Log Job failure: Previous event is not valid for this sequence
                  this.sequencingFailed := true;
                  this.failJob("The type of a previous event provided is not known or not valid - Event Id = " & aPrevEventId);
         
                end if;
              else
                // The received event is a sequence start event but it has a previous event with it. This is an error condition
                this.sequencingFailed := true;
                this.failJob("This is a sequence start event with a previous event which can't happen - in Job = " & this.jobID & ", current event type = " & theEventType.AEType & ". event id = " & newEvent.AuditEventId);
              end if;  
            elsif possibleAeOccInSequenceDef'length = 0 then
              // There is no available definition for this situation so the sequence is broken.
              this.sequencingFailed := true;
              this.failJob("The previous event is valid but is part of a broken sequence - Event Type = " & (prevEvent -> R2).AEType);
        
            else
              // There are multiple possible Audit Event Occurrences In the Sequence Definition 
              // TODO What does this circumstance imply and what can we do about it.
              this.sequencingFailed := true;
              this.failJob("There are multiple possible outcomes so this situation was not foreseen - in Job = " & this.jobID & ", current event type = " & theEventType.AEType & ". event id = " & newEvent.AuditEventId);
            end if;
          else
            // The previous event id provided in the audit event data is not recognised as a previous event 
            this.sequencingFailed := true;
            this.failJob("The previous event id provided in the audit event data is not recognised as a previous event - in Job = " & this.jobID & " provided previous event id = " & aPrevEventId);
            
          end if;
        end loop; //End of loop over each previous event id  
        
        // Need to increment the branch extent for this sequence for this new event as part of the Hanrahan algorithm  
        currentSequence := newEvent -> R11;
        if currentSequence /= null then
          currentSequence.branchExtent := currentSequence.branchExtent + 1;
              
        else
          //Log Job failure: Previous event is valid but is part of a broken sequence
          this.sequencingFailed := true;
          this.failJob("No current sequence has been found for this audit event - Event Type = " & (newEvent -> R2).AEType);
        end if;  

      else
        // There is no previous event so check for a single AEOccurrenceInSequenceDef that marks a sequence start
        theAeOccInSequenceDef := find_one theAeOccurrencesInSequenceDef (isSequenceStart = true);

        if theAeOccInSequenceDef /= null then
          // The new event type is one that starts a sequence even though it's for an existing Job. This indicates a follow on sequence for an existing Job
          // This is expected when a start event is seen for a new sequence in an existing Job
          link newEvent R13 theAeOccInSequenceDef;
          //TODO Validate the new sequence is in the correct order
          // Check that no other sequences for the same Job are still in progress
          sequencesForJob := this -> R10;
          incompleteSequences := find sequencesForJob (isComplete = false);
          if incompleteSequences'length = 0 then
            // Log info: Received a new sequence start event for an existing Job but other sequences are complete
	        logMessage := "AESequenceDC::Job.JobInProgress : A further new sequence has been started for - jobId = " & this.jobID & ", with audit event = " & theEventType.AEType;
	        Logger::log(Logger::Debug, "AESequenceDC", logMessage);
	        
	        // This must be the first start event seen for a new sequence so create and link the sequence
	        newSequence := create unique Sequence (isComplete => theAeOccInSequenceDef.isSequenceEnd, branchExtent => 1);
	        link newSequence R10 this;
	        link newSequence R11 newEvent;
	        link newSequence R14 theSequenceDef;
	        
	      else
            // Log info: Received a new sequence start event for an existing Job - but other sequences are still in progress
	        logMessage := "AESequenceDC::Job.JobInProgress : A new sequence start event has been seen with other sequences incomplete for - jobId = " & this.jobID & ", with audit event = " & theEventType.AEType;
	        Logger::log(Logger::Debug, "AESequenceDC", logMessage);
	        
	        // Need to check if an incomplete sequence is one of the right type for this event
	        for incompleteSequence in incompleteSequences loop
	          if (incompleteSequence -> R14) = theSequenceDef then
	            // We have an incomplete sequence of the same type as the new event belongs to so this must be another start event for that sequence
	            link incompleteSequence R11 newEvent;
	            // So increment the branch extent
	            incompleteSequence.branchExtent := incompleteSequence.branchExtent + 1;
                // Log info: Received a new sequence start event that is an additional start event for an existing sequence
	            logMessage := "AESequenceDC::Job.JobInProgress : An additional sequence start event has been seen for an existing sequence for - jobId = " & this.jobID & ", in sequence = " & incompleteSequence.AESequenceId'image & "with audit event type = " & theEventType.AEType;
	            Logger::log(Logger::Debug, "AESequenceDC", logMessage);
	            
	          end if;
	        end loop;
	        // If the new start sequence event didn't match any existing sequences then it must be a new sequence
	        if (newEvent -> R11) = null then
	          // This must be the first start event seen for a new sequence so create and link the sequence
	          newSequence := create unique Sequence (isComplete => theAeOccInSequenceDef.isSequenceEnd, branchExtent => 1);
	          link newSequence R10 this;
	          link newSequence R11 newEvent;
	          link newSequence R14 theSequenceDef;          
	        end if;
	      end if;  



          // Process the audit event data for this first event
          newEvent.ProcessAuditEventData (aeData);    

        
        else
          // We have a valid new event type and no previous event. This should indicate the start of
          // a new sequence within a Job yet the definition is ambiguous about which start event it is
          // TODO Check: Can this ever happen and if so what can we do about it?
          this.sequencingFailed := true;
          this.failJob("An event starting a new sequence has been received but there is no matching start event definition for Job = " & this.jobID & ", with audit event type = " & theEventType.AEType);
        end if; 
      end if;    
 
      // TODO Remove later: Process Audit event data was here
      
        
      // Check to see if the received event marks an end point in the current sequence and if so check whether or
      // not it completes the sequence (note that sequences can have multiple end points due to branching)
      if (theAeOccInSequenceDef /= null) and (theAeOccInSequenceDef.isSequenceEnd) = true then
        currentSequence := newEvent -> R11;
        if currentSequence /= null then
          // Check to to see if the 'end point' event in the sequence also marks the sequence end.
          generate Job.endEventInSequenceDetected(currentSequence) to this;
        else
          //Log Job failure: This event marks the end of a sequence but is part of a broken sequence
          this.sequencingFailed := true;
          this.failJob("This event marks the end of a sequence but is part of a broken sequence - Event Type = " & theEventType.AEType);
        end if;
  
      end if;
      
      
    else
      // Log error: unrecognised event type received
      this.sequencingFailed := true;
      this.failJob("An unrecognised event type - " & aeType & "has been received for - jobId = " & this.jobID);
    //
    end if;
  else
    // Log error: The audit event id received has been seen before
    this.sequencingFailed := true;
    this.failJob("The audit event id received has been seen before - event id " & eventId & " , jobId = " & this.jobID);
  
  end if;  
//  
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd011774c-53f3-4995-b8bf-9a4879033d00' '45910edf-ed38-4fdb-b6b8-206e07e4bdec' DO NOT EDIT THIS LINE.
state AESequenceDC::Job.AssessingJobConstraints () is
eachAuditEventPair : instance of AuditEventPair;
theAuditEventPairs : sequence of instance of AuditEventPair;
theConstraintDefn : instance of ConstraintDefinition;
theConstraintDefns : sequence of instance of ConstraintDefinition;
theConstrainedSeqPairDefns : sequence of instance of AEInSequencePairDefn;
eachConstrainedSeqPairDefn : instance of AEInSequencePairDefn;
theConstrainedAuditEventPairs : sequence of instance of AuditEventPair;
thePreviousAuditEvents : set of instance of AuditEvent;
theFollowingAuditEventPairs : sequence of instance of AuditEventPair;
theForkAuditEvent : instance of AuditEvent;
theBranchedEvents : set of instance of AuditEvent;
validatedConstraint : boolean;
validatedDynamicControl : boolean;
logMessage : string;
failureReason: string;

begin
  // Need to check that constraints are honoured	
  theAuditEventPairs := this -> R3 -> R4.has_next.AuditEventPair;
  validatedConstraint := true;
  for eachAuditEventPair in theAuditEventPairs loop
    theConstraintDefn := eachAuditEventPair -> R15 -> R16;
    if theConstraintDefn /= null then
      if theConstraintDefn.constraintType = AND then
        // AND Constraint Logic
        theConstrainedSeqPairDefns := theConstraintDefn -> R16.AEInSequencePairDefn;
        for eachConstrainedSeqPairDefn in theConstrainedSeqPairDefns loop
          // Check that every element within the AND constraint is present
          if ((eachConstrainedSeqPairDefn -> R15) intersection theAuditEventPairs)'length = 0 then
            validatedConstraint := false;
          end if;
        end loop;
      elsif theConstraintDefn.constraintType = XOR then
        //XOR Constraint logic
        theConstrainedSeqPairDefns := theConstraintDefn -> R16.AEInSequencePairDefn;
        // Find the constrained event pairs - the graph edges after the XOR node - in this Job
        theConstrainedAuditEventPairs := (theConstrainedSeqPairDefns -> R15) intersection theAuditEventPairs;
        // Find the preceding XOR graph nodes
        thePreviousAuditEvents := theConstrainedAuditEventPairs -> R4.has_previous.AuditEvent;
        // Check that after an XOR fork event there is a single branch.      
        // This is a sound check since exactly one branch will follow each XOR fork audit event.
        for thePreviousAuditEvent in thePreviousAuditEvents loop
          theFollowingAuditEventPairs := thePreviousAuditEvent -> R4.has_next.AuditEventPair;
          if theFollowingAuditEventPairs'length /= 1 then
            validatedConstraint := false;
            logMessage := "AESequenceDC::Job.AssessingJobConstraints : XOR Constraint failed for Job = " & this.jobID & " at event " & (thePreviousAuditEvent -> R2).AEType & " with " & theFollowingAuditEventPairs'length'image & " branches following the XOR node";
            Logger::log(Logger::Debug, "AESequenceDC", logMessage);   
          end if;
        end loop;  
      else
        logMessage := "AESequenceDC::Job.AssessingJobConstraints : Unsupported Constraint Type for Job = " & this.jobID;
        Logger::log(Logger::Debug, "AESequenceDC", logMessage);    
      end if;
    end if;  
  end loop;
  
  // Also check that loop constraints are satisfied
  declare
    theDynamicControls : set of instance of DynamicControl;
    theDynamicControlDefn : instance of DynamicControlDefinition;
    
  begin
    validatedDynamicControl := true;
    theDynamicControls := this -> R35;
    for theDynamicControl in theDynamicControls loop
      theDynamicControlDefn := theDynamicControl -> R29;
      if theDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.LOOPCOUNT then
        if (theDynamicControl.expectedDynamicControlValue > 0) and (theDynamicControl.expectedDynamicControlValue /= theDynamicControl.currentDynamicControlValue) then
          validatedDynamicControl := false;          
          logMessage := "AESequenceDC::Job.AssessingJobConstraints : Loop Count check failed for Job = " & this.jobID & " Expected Loop Count = " & theDynamicControl.expectedDynamicControlValue'image & " Current Loop Count = " & theDynamicControl.currentDynamicControlValue'image;
          Logger::log(Logger::Debug, "AESequenceDC", logMessage);    
        else
          logMessage := "AESequenceDC::Job.AssessingJobConstraints : Loop Count check passed for Job = " & this.jobID & " Expected Loop Count = " & theDynamicControl.expectedDynamicControlValue'image & " Current Loop Count = " & theDynamicControl.currentDynamicControlValue'image;
          Logger::log(Logger::Debug, "AESequenceDC", logMessage);              
        end if;
      elsif theDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.BRANCHCOUNT then
//        if (theDynamicControl.expectedDynamicControlValue > 0) and (theDynamicControl.expectedDynamicControlValue /= theDynamicControl.currentDynamicControlValue) then
        theForkAuditEvent := theDynamicControl -> R36;

        if theDynamicControl -> R36 /= null then
        // We have a user dynamic control so check its values
          if (theDynamicControl.expectedDynamicControlValue > 0) and (theDynamicControl.currentDynamicControlValue /= theDynamicControl.expectedDynamicControlValue) then
            validatedDynamicControl := false;          
            logMessage := "AESequenceDC::Job.AssessingJobConstraints : Branch Count check failed for Job = " & this.jobID & " Expected Branch Count = " & theDynamicControl.expectedDynamicControlValue'image & " Current Branch Count = " & theBranchedEvents'length'image;
            Logger::log(Logger::Debug, "AESequenceDC", logMessage);    
          else
            logMessage := "AESequenceDC::Job.AssessingJobConstraints : Branch Count check passed for Job = " & this.jobID & " Expected Branch Count = " & theDynamicControl.expectedDynamicControlValue'image & " Current Branch Count = " & theBranchedEvents'length'image;
            Logger::log(Logger::Debug, "AESequenceDC", logMessage);              
          end if;
        else
          // This is the source branch count which isn't checked
        end if;    
      elsif theDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.MERGECOUNT then
        if (theDynamicControl.expectedDynamicControlValue > 0) and (theDynamicControl.expectedDynamicControlValue /= theDynamicControl.currentDynamicControlValue) then
          validatedConstraint := false;    
          // TODO Remove debug log message      
          logMessage := "AESequenceDC::Job.AssessingJobConstraints : Merge Count check failed for Job = " & this.jobID & " Expected Merge Count = " & theDynamicControl.expectedDynamicControlValue'image & " Current Merge Count = " & theDynamicControl.currentDynamicControlValue'image;
          Logger::log(Logger::Debug, "AESequenceDC", logMessage);    
        else
          logMessage := "AESequenceDC::Job.AssessingJobConstraints : Merge Count check passed for Job = " & this.jobID & " Expected Merge Count = " & theDynamicControl.expectedDynamicControlValue'image & " Current Merge Count = " & theDynamicControl.currentDynamicControlValue'image;
          Logger::log(Logger::Debug, "AESequenceDC", logMessage);              
        end if;
      
      end if;
    end loop;
  end;
  
  if (validatedConstraint = false) or (validatedDynamicControl = false) then
    // One or more of the checks has failed - determine which ones and act accordingly
    if (validatedConstraint = false) and (validatedDynamicControl = true) then
      // Only the constraint checks have failed
      failureReason := "one or more constraint checks have failed";
      generate Job.jobFailed(failureReason) to this;
    else
      if (validatedConstraint = true) and (validatedDynamicControl = false) then
        // Only the dynamic control checks have failed
        failureReason := "one or more dynamic control checks have failed";
        generate Job.jobFailed(failureReason) to this;
      else
        // Both checks must have failed
        failureReason := "one or more constraint checks AND one or more dynamic control checks have failed";
        generate Job.jobFailed(failureReason) to this;
      end if;
    end if;
  else
    // All constraint and dynamic control checks have passed for this Job
    logMessage := "AESequenceDC::Job.AssessingJobConstraints : Constraint and dynamic control checks passed for - jobId = " & this.jobID;
    Logger::log(Logger::Debug, "AESequenceDC", logMessage);
    generate Job.constraintCheckSuccessful() to this;
  end if;
  
//  if validatedConstraint = false then
//    failureReason := "Constraint Failed";
//    generate Job.jobFailed(failureReason) to this;
//  else
//    logMessage := "Constraint check passed for - jobId = " & this.jobID;
//    Logger::log(Logger::Information, "AESequenceDC", logMessage);
//    generate Job.constraintCheckSuccessful() to this;
//  end if;
//
end state;
//
//
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd011774c-53f3-4995-b8bf-9a4879033d00' '629612ca-ac5a-494b-b9de-7ef1afda21f0' DO NOT EDIT THIS LINE.
state AESequenceDC::Job.JobFailed ( failureReason : in string ) is
logMessage : string;
theSystemSpec : instance of SystemSpecification;
eventContent : string;

begin
  // Cancel the jobDeletionTimer (that may have been set in previous states) in preparation
  // for being set again within this state.
  cancel this.jobDeletionTimer;
  
  // The following line is necessary because it is possible for JobFailed to be received when the Job has completed
  // Current policy is that FailJob from AEOrdering trumps all behaviour in SVDC and so even a completed Job will be
  // set to JobFailed in this situation. Consequently it seems appropriate to clear the jobCompleted boolean
  this.jobCompleted := false;
  
  // Log info: Audit Event Sequence Verification has been informed of Job failure
  logMessage := "AESequenceDC::Job.JobFailed : Job Failed - jobId = " & this.jobID & " due to: " & failureReason;
  Logger::log(Logger::Error, "AESequenceDC", logMessage);
  eventContent := "JobId = " & this.jobID & " :  FailureReason = " & failureReason;
  Reporting~>reportEvent(Logger::Error, "svdc_job_failed", eventContent);
  
  // The Job is near the end of it's useful life - wait a bit longer and then trigger its final demise.
  theSystemSpec := find_one SystemSpecification();
  schedule this.jobDeletionTimer generate Job.endOfLifeReached() to this delay theSystemSpec.jobDeletionWaitPeriod;
  //          
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd011774c-53f3-4995-b8bf-9a4879033d00' 'e08a98eb-9e0e-4eaf-83d7-60649b23bdac' DO NOT EDIT THIS LINE.
state AESequenceDC::Job.JobGoneHorriblyWrong ( eventId : in string,
                                              prevAEIds : in sequence of string,
                                              aeType : in string,
                                              aeData : in sequence of auditEventDataStructure ) is
logMessage : string;
theSystemSpec : instance of SystemSpecification;
eventContent : string;

begin
    // Cancel the jobDeletionTimer (that may have been set in previous states) in preparation
  // for being set again within this state.
  cancel this.jobDeletionTimer;
  
  // The following line is necessary because it seems appropriate to clear the jobCompleted boolean if further
  // events are received after the Job completed
  this.jobCompleted := false;

  // Log error: new follow on event received for completed or failed Job
      // Log info: Audit Event Sequence Verification has been informed of Job completion
  logMessage := "AESequenceDC::Job.JobGoneHorriblyWrong : Job gone horribly wrong - a follow on event for a completed or failed job has been received - jobId = " & this.jobID;
  Logger::log(Logger::Error, "AESequenceDC", logMessage);
  eventContent := "JobId = " & this.jobID  & " : FailureReason = Job gone horribly wrong - a follow on event for a completed or failed job has been received";
  Reporting~>reportEvent(Logger::Error, "svdc_job_failed", eventContent);

  // The Job is near the end of it's useful life - wait a bit longer and then trigger its final demise.
  theSystemSpec := find_one SystemSpecification();
  schedule this.jobDeletionTimer generate Job.endOfLifeReached() to this delay theSystemSpec.jobDeletionWaitPeriod;
  //
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd011774c-53f3-4995-b8bf-9a4879033d00' '02372df1-eda5-43dc-9e3b-740dccc50479' DO NOT EDIT THIS LINE.
state AESequenceDC::Job.AssessingSequenceCompletion ( thePotentiallyCompletedSequence : in instance of Sequence ) is
aeSequenceDefs : set of instance of AESequenceDefinition;
completeSequences : set of instance of Sequence;
sequencesForJob : set of instance of Sequence;
theSystemSpec : instance of SystemSpecification;
logMessage : string;
 
begin
  // Log info: Audit Event Sequence Verification is checking for completion of a Sequence or Job
  logMessage := "AESequenceDC::Job.AssessingSequenceCompletion : Checking for completion of a Sequence or Job - jobId = " & this.jobID & " ,sequenceId = " & thePotentiallyCompletedSequence.sequenceId'image & " and branch extent = " & thePotentiallyCompletedSequence.branchExtent'image;
  Logger::log(Logger::Debug, "AESequenceDC", logMessage); 

  // Test to see if this is the last 'end' event for the current sequence
  thePotentiallyCompletedSequence.branchExtent := thePotentiallyCompletedSequence.branchExtent - 1;
  if thePotentiallyCompletedSequence.branchExtent = 0 then
    thePotentiallyCompletedSequence.isComplete := true; 
  else
    thePotentiallyCompletedSequence.isComplete := false;
  end if;  
   
  // Then check to see if the job is complete
  aeSequenceDefs := this -> R8 -> R7;
  sequencesForJob := this -> R10;
  completeSequences := find sequencesForJob (isComplete = true);
  if aeSequenceDefs'length = completeSequences'length then
    // All sequences for the Job appear to be complete - but just in case there's a late delivery of the first
    // event in a previously unseen optional branch of one of those sequences then give a short period for it to 
    // arrive before moving the Job into the JobCompleted state.
    theSystemSpec := find_one SystemSpecification();
    schedule this.jobEventTimer generate Job.jobComplete() to this delay theSystemSpec.intraSequenceEventTimeoutPeriod;
  end if;
        
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd011774c-53f3-4995-b8bf-9a4879033d00' 'fe76e332-fa89-4fc8-bf40-ea0923527fad' DO NOT EDIT THIS LINE.
state AESequenceDC::Job.JobTimeoutReported () is
logMessage : string;
begin
  // TODO: Can a jobFailed event occur once this state is reached?
  
  logMessage := "AESequenceDC::Job.JobTimeoutReported : The Job has been reported having timed out - jobId = " & this.jobID;
  Logger::log(Logger::Debug, "AESequenceDC", logMessage);
  
  // TODO: Consider adding a jobTimedOut (boolean) attribute to Job and set this to true on
  //       entry to this state such that it can be used in test assertions (because you cannot
  //       currently check the value of the current_state 'attribute'.

end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd011774c-53f3-4995-b8bf-9a4879033d00' 'af8e77f2-393f-44d3-add2-d0babcb15053' DO NOT EDIT THIS LINE.
state AESequenceDC::Job.JobSuccessful () is
logMessage : string;
theSystemSpec : instance of SystemSpecification;
eventContent : string;
jobDefinition : instance of JobDefinition;

begin
  // Job is considered to have completed - Record and log this fact.
  this.jobCompleted := true;
  jobDefinition := this -> R8.JobDefinition;
  // Log info: Audit Event Sequence Verification has determined that the Job is Complete
  logMessage := "AESequenceDC::Job.JobSuccessful : Sequence Verification determines that the Job - jobId = " & this.jobID & " is complete.";
  Logger::log(Logger::Debug, "Monitored System Status", logMessage);
  eventContent := "JobId = " & this.jobID & " : JobName = " & jobDefinition.jobName;
  Reporting~>reportEvent(Logger::Information, "svdc_job_success", eventContent);
  
  // The Job is thus near the end of it's useful life - wait a bit longer and then trigger its final demise.
  theSystemSpec := find_one SystemSpecification();
  schedule this.jobDeletionTimer generate Job.endOfLifeReached() to this delay theSystemSpec.jobDeletionWaitPeriod;
  //
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd011774c-53f3-4995-b8bf-9a4879033d00' '8fe3aaed-1b2a-4e4b-bd5a-8206f6e08cf0' DO NOT EDIT THIS LINE.
state AESequenceDC::Job.Deleted () is
logMessage : string;
theJobID : string;

begin
  // The Job has reached the end of its useful life and can be deleted.
  theJobID := this.jobID;
  this.deleteJob();
  
  // Synchronise the deletion of any counterpart Job instances in other domains.
  JobAdmin~>deleteJob(theJobID);

  logMessage := "AESequenceDC::Job.Deleted : Job with jobID: " & theJobID & " has been deleted";
  Logger::log(Logger::Debug, "AESequenceDC", logMessage);
  //
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd011774c-53f3-4995-b8bf-9a4879033d00' '8296783c-a40c-413b-b700-e18ecd9df26d' DO NOT EDIT THIS LINE.
state AESequenceDC::Job.AssessingIntraJobInvariants () is
expectedIntraJobInvDefns : set of instance of IntraJobInvariantDefn;
theExpectedIntraJobInvDefn : instance of IntraJobInvariantDefn;
theJobsAuditEvents : set of instance of AuditEvent;
theInvariantAuditEvents : set of instance of AuditEvent;
theJobsInvariantAuditEvents : set of instance of AuditEvent;
theIntraJobInvariant : instance of TransientInvariant;
intraJobInvariantCheckPassed : boolean;
matched : boolean;
invariantValue : string := "";
failureReason : string;
logMessage : string;

begin
// Checking Intra Job Invariants if any
      intraJobInvariantCheckPassed := true;
      theJobsAuditEvents := this -> R3;
      expectedIntraJobInvDefns := this -> R3 -> R13 -> R19;
      for theExpectedIntraJobInvDefn in expectedIntraJobInvDefns loop
        theInvariantAuditEvents := theExpectedIntraJobInvDefn -> R19 -> R13;
        // This finds the set of audit events that are expected to have invariants attached
        theJobsInvariantAuditEvents :=  theJobsAuditEvents intersection theInvariantAuditEvents;
        for eachJobsInvariantAuditEvent in theJobsInvariantAuditEvents loop
          theIntraJobInvariant := eachJobsInvariantAuditEvent -> R23;
          if theIntraJobInvariant /= null then
            if invariantValue = "" then
              invariantValue := theIntraJobInvariant.invariantValue;
            else  
              if invariantValue /= theIntraJobInvariant.invariantValue then
                intraJobInvariantCheckPassed := false;
              end if;
            end if;    
          else
            // No invariant provided with the audit event when expected
            intraJobInvariantCheckPassed := false;
          end if;  
        end loop;
      end loop;
      
      if intraJobInvariantCheckPassed then
        logMessage := "AESequenceDC::Job.AssessingIntraJobInvariants : Intra-Job Invariant check passed for - jobId = " & this.jobID;
        Logger::log(Logger::Debug, "AESequenceDC", logMessage);
        generate Job.intraJobInvariantCheckSuccessful() to this;
      else
        failureReason := "Check of Intra-Job Invariants Failed";
        generate Job.jobFailed(failureReason) to this;
      end if;  
  
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd011774c-53f3-4995-b8bf-9a4879033d00' 'f09c7295-aae5-4cb4-b76a-0bac7eb5fe52' DO NOT EDIT THIS LINE.
state AESequenceDC::Job.AwaitingPersistenceService () is
theSystemSpec : instance of SystemSpecification;
failureReason : string;
logMessage : string;

begin

  //TODO Remove debug message
  logMessage := "AESequenceDC::Job.AwaitingPersistenceService : Entered state Awaiting Persistence Service for - jobId = " & this.jobID;
  Logger::log(Logger::Debug, "AESequenceDC", logMessage);
  
  theSystemSpec := find_one SystemSpecification ();
  failureReason := " Request for invariants from the persistence store has timed out meaning the Extra Job Invariant Check has failed " & this.jobID;
  schedule this.jobInvariantSyncTimer generate Job.persistenceSyncTimedOut(failureReason) to this delay theSystemSpec.persistentInvariantRestoreTimeoutPeriod;
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd011774c-53f3-4995-b8bf-9a4879033d00' '1a48b626-651f-4dfb-b43e-fa7e296da623' DO NOT EDIT THIS LINE.
state AESequenceDC::Job.AssessingLocalExtraJobInvariants () is
expectedUserExtraJobInvDefns : set of instance of ExtraJobInvariantDefn;
theExpectedUserExtraJobInvDefn : instance of ExtraJobInvariantDefn;
theJobsAuditEvents : set of instance of AuditEvent;
theInvariantAuditEvents : set of instance of AuditEvent;
theJobsInvariantAuditEvents : set of instance of AuditEvent;
theTransientExtraJobInvariant : instance of TransientInvariant;
thePersistedExtraJobInvariant : instance of PersistedInvariant;
theRestoredPersistentInvariant : instance of PersistedInvariant;
thePersistedExtraJobInvariants : set of instance of PersistedInvariant;
theInForcePersistedExtraJobInvariants : set of instance of PersistedInvariant;
restoredInvariant : persistedInvariantStructure;
extraJobInvariantCheckPassed : boolean;
matched : boolean;
invariantValue : string := "";
failureReason : string;
logMessage : string;

begin      
  // Checking Extra Job Invariants
      matched := false;
      extraJobInvariantCheckPassed := true;
      theJobsAuditEvents := this -> R3;
      expectedUserExtraJobInvDefns := this -> R3 -> R13 -> R21;
      for theExpectedUserExtraJobInvDefn in expectedUserExtraJobInvDefns loop
        theInvariantAuditEvents := theExpectedUserExtraJobInvDefn -> R21 -> R13;
        // This finds the set of audit events that are expected to have invariants attached
        theJobsInvariantAuditEvents :=  theJobsAuditEvents intersection theInvariantAuditEvents;
        for eachInvariantAuditEvent in theJobsInvariantAuditEvents loop
          // Iterate over each Audit Event which is expected to have a user extra job invariant attached
          theTransientExtraJobInvariant := eachInvariantAuditEvent -> R23;
          thePersistedExtraJobInvariants := theTransientExtraJobInvariant -> R28 -> R24;
          // The following allows for more than one instance of a persisted extra job invariant to be in force at the same time
          // If any one of them matches the value of the transient invariant then the transient invariant is valid
          theInForcePersistedExtraJobInvariants := find thePersistedExtraJobInvariants (inForce = true);
          for eachInForceInvariant in theInForcePersistedExtraJobInvariants loop
            if eachInForceInvariant.invariantValue = theTransientExtraJobInvariant.invariantValue then
              matched := true;
              exit;
            else
              matched := false;
            end if;  
          end loop;

          if not matched then
            // Check to see if there is a stored persistent invariant 
            Persistence_Req_IF~>RestoreNamedInvariant(theTransientExtraJobInvariant.extraJobInvName,
            	                               theTransientExtraJobInvariant.invariantValue);
            generate Job.WaitForStoredInvariants() to this;   
            extraJobInvariantCheckPassed := false;
            exit;
          end if;      
                      
        end loop;
      end loop;


      if extraJobInvariantCheckPassed then
        logMessage := "AESequenceDC::Job.AssessingLocalExtraJobInvariants : Extra-Job Invariant check passed for - jobId = " & this.jobID;
        Logger::log(Logger::Debug, "AESequenceDC", logMessage);
        generate Job.extraJobInvariantCheckSuccessful() to this;
      else
        logMessage := "AESequenceDC::Job.AssessingLocalExtraJobInvariants : Local Extra-Job Invariants insufficient so checking stored value for - jobId = " & this.jobID;
        Logger::log(Logger::Debug, "AESequenceDC", logMessage);
      end if;  
  
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd011774c-53f3-4995-b8bf-9a4879033d00' 'fdf1deba-061a-4def-b29a-75ec05c72679' DO NOT EDIT THIS LINE.
state AESequenceDC::Job.ReassessingExtraJobInvariants () is
expectedUserExtraJobInvDefns : set of instance of ExtraJobInvariantDefn;
theExpectedUserExtraJobInvDefn : instance of ExtraJobInvariantDefn;
theJobsAuditEvents : set of instance of AuditEvent;
theInvariantAuditEvents : set of instance of AuditEvent;
theJobsInvariantAuditEvents : set of instance of AuditEvent;
theTransientExtraJobInvariant : instance of TransientInvariant;
thePersistedExtraJobInvariant : instance of PersistedInvariant;
thePersistedExtraJobInvariants : set of instance of PersistedInvariant;
theInForcePersistedExtraJobInvariants : set of instance of PersistedInvariant;
extraJobInvariantCheckPassed : boolean;
matched : boolean;
failureReason : string;
logMessage : string;

begin  
  // Clear the time
  cancel this.jobInvariantSyncTimer;    
  // Checking Extra Job Invariants including those recovered from the persistent invariant store
      matched := false;
      extraJobInvariantCheckPassed := true;
      theJobsAuditEvents := this -> R3;
      expectedUserExtraJobInvDefns := this -> R3 -> R13 -> R21;
      for theExpectedUserExtraJobInvDefn in expectedUserExtraJobInvDefns loop
        theInvariantAuditEvents := theExpectedUserExtraJobInvDefn -> R21 -> R13;
        // This finds the set of audit events that are expected to have invariants attached
        theJobsInvariantAuditEvents :=  theJobsAuditEvents intersection theInvariantAuditEvents;
        for eachInvariantAuditEvent in theJobsInvariantAuditEvents loop
          // Iterate over each Audit Event which is expected to have a user extra job invariant attached
          theTransientExtraJobInvariant := eachInvariantAuditEvent -> R23;
          thePersistedExtraJobInvariants := theTransientExtraJobInvariant -> R28 -> R24;
          // The following allows for more than one instance of a persisted extra job invariant to be in force at the same time
          // If any one of them matches the value of the transient invariant then the transient invariant is valid
          theInForcePersistedExtraJobInvariants := find thePersistedExtraJobInvariants (inForce = true);
          for eachInForceInvariant in theInForcePersistedExtraJobInvariants loop
            if eachInForceInvariant.invariantValue = theTransientExtraJobInvariant.invariantValue then
              matched := true;
              exit;
            else
              matched := false;
            end if;  
          end loop;

          if not matched then
            extraJobInvariantCheckPassed := false;
            exit;
          end if;      
                      
        end loop;
      end loop;


      if extraJobInvariantCheckPassed then
        logMessage := "AESequenceDC::Job.ReassessingExtraJobInvariants : Extra-Job Invariant check passed for - jobId = " & this.jobID;
        Logger::log(Logger::Debug, "AESequenceDC", logMessage);
        generate Job.extraJobInvariantCheckSuccessful() to this;
      else
        failureReason := "Extra-Job Invariant check failed including checking stored invariants";
        generate Job.jobFailed (failureReason) to this;
      end if;  
  
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

