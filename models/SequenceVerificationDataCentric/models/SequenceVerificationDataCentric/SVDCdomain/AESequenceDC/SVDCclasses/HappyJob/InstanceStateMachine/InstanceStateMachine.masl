//! ACTIVITY BEGIN. '79ee457c-fada-4ebb-8735-1e0b3b4a1284' '7795cd6a-5c92-4b51-bb32-bf049e02c445' DO NOT EDIT THIS LINE.
state AESequenceDC::HappyJob.JobInProgress () is
theJob : instance of Job;
theJobDef : instance of JobDefinition;
newSeqEvent : instance of SequencedAuditEvent;
newEvent : instance of AuditEvent;
existingEvent : instance of AuditEvent;
theEventType : instance of SequencedAuditEventDefinition;
possibleEventTypes : set of instance of SequencedAuditEventDefinition;
theUnseqEventType : instance of UnsequencedAuditEventDefinition;
prevEvent : instance of SequencedAuditEvent;
prevEvt : instance of AuditEvent;
prevEventIsValid : boolean;
theAeSequenceDef : instance of AESequenceDefinition;
theAeOccInSequenceDef : instance of AEOccurrenceInSequenceDefinition;
theAeOccurrencesInSequenceDef : set of instance of AEOccurrenceInSequenceDefinition;
prevAeOccInSequenceDef : instance of AEOccurrenceInSequenceDefinition;
expectedAeOccsInSequenceDef : set of instance of AEOccurrenceInSequenceDefinition;
possibleAeOccInSequenceDef : set of instance of AEOccurrenceInSequenceDefinition;
theAeInSequenceDef : instance of AEInSequenceDefinition;
theEventsSequenceDefs : set of instance of AESequenceDefinition;
theJobsSequenceDefs : set of instance of AESequenceDefinition;
aeSequenceDefs : set of instance of AESequenceDefinition;
theSequenceDef : instance of AESequenceDefinition;
theAeInSequencePairDefn : instance of AEInSequencePairDefn;
existingAuditEventPair : instance of SequencedAuditEventPair;
newAuditEventPair : instance of SequencedAuditEventPair;
theAuditEventPairs : set of instance of SequencedAuditEventPair;
allAuditEventPairs : set of instance of SequencedAuditEventPair;
thisJobsAuditEventPairs : set of instance of SequencedAuditEventPair;
newAuditEventLink : instance of AuditEventLink;
currentSequence : instance of Sequence;
newSequence : instance of Sequence;
incompleteSequences : set of instance of Sequence;
incompleteSequence : instance of Sequence;
completeSequences : set of instance of Sequence;
sequencesForJob : set of instance of Sequence;
aeDataElement : auditEventDataStructure;
newIntraJobInvariant : instance of TransientInvariant;
theIntraJobInvariantDefn : instance of IntraJobInvariantDefn;
theSourceExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;
theUserExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;
theSourceExtraJobInvariant : instance of PersistedInvariant;
theUserExtraJobInvariant : instance of TransientInvariant;
theDynamicControlDefn : instance of DynamicControlDefinition;
theDynamicControlDefns : set of instance of DynamicControlDefinition;
theExistingDynamicControls : set of instance of DynamicControl;
newDynamicControl : instance of DynamicControl;
theUserDynamicControlDefn : instance of DynamicControlDefinition;
theCurrentDynamicControlDefn : instance of DynamicControlDefinition;
theUserDynamicControl : instance of DynamicControl;
thisJobsDynamicControl : instance of DynamicControl;
thisJobsDynamicControls : set of instance of DynamicControl;
theDynamicControls : set of instance of DynamicControl;
theSourceDynamicControl : instance of DynamicControl;
theCurrentDynamicControls : set of instance of DynamicControl;
thePrevUserDynamicControlDefn : instance of DynamicControlDefinition;
thePrevSourceDynamicControl : instance of DynamicControl;
thePrevUserDynamicControl : instance of DynamicControl;
thePrevUserDynamicControls : set of instance of DynamicControl;
theCandidatePrevUserDynamicControl : instance of DynamicControl;
theCandidatePrevUserDynamicControlDefn : instance of DynamicControlDefinition;
thePrevUserBranchPoints : set of instance of DynamicControl;
allPrevUserBranchPoints : set of instance of DynamicControl;
emptyPrevUserDynamicControl : instance of DynamicControl;
loopCount : integer;
branchCount : integer;
auditEventDataProcessed : boolean;
empty : sequence of string;
emptyPrevId : sequence of string:= empty & "";
lastPreviousEventId : string;
instanceForkFound : boolean;
logMessage : string;
failureMessage : string;
creationErrorMessage : string;
eventDataCheckHasPassed : boolean;
theSystemSpec : instance of SystemSpecification;
failureReason : string;
auditEventType : string;
auditEventId : string;
jobType : string;
prevAuditEventIds : sequence of string;
auditEventData : sequence of auditEventDataStructure;
eventContent : string;


begin

  //Map the event parameters to local variables
  auditEventType := aeType;
  auditEventId := eventId;
  prevAuditEventIds := prevAEIds;
  auditEventData := aeData;

  theJob := this -> R45;
  	
  // Reset the jobHangingTimer if it is set
  cancel theJob.jobHangingTimer;
  
  existingEvent := find_one AuditEvent (AEId = auditEventId);
  if existingEvent = null then
  
    
    theEventType := find_only SequencedAuditEventDefinition (AEType = auditEventType);
    theUnseqEventType := find_only UnsequencedAuditEventDefinition (UnsequencedAEType = auditEventType);
    
    if theEventType /= null then
      // We have a valid event type
    
      newEvent := create AuditEvent (AEId => auditEventId);
      newSeqEvent := create SequencedAuditEvent (AuditEventId => auditEventId, seenAsPreviousEvent => false, AEId => newEvent.AEId);
      link newSeqEvent R46 newEvent;
      // We need to link all events to the Job in which they are seen even if they are not correctly sequenced
      link theJob R44 newSeqEvent;
      // and to the sequenced event definition
      link newSeqEvent R2 theEventType;

      theJobDef := theJob -> R8;
      possibleEventTypes := theJobDef -> R43.SequencedAuditEventDefinition;

      theEventsSequenceDefs := theEventType -> R1.AESequenceDefinition;
      theJobsSequenceDefs := theJobDef -> R7;
      aeSequenceDefs := theEventsSequenceDefs intersection theJobsSequenceDefs;
      // As in Highlander - There can be only one!
      theSequenceDef := find_one aeSequenceDefs();
      
      theAeInSequenceDef := theSequenceDef with theEventType -> R1.AEInSequenceDefinition;
      theAeOccurrencesInSequenceDef := theAeInSequenceDef -> R12;
      
      // ...and then check that just one of these matches with an event occurrence that is expected for the previous event
      if (prevAuditEventIds /= empty) and (prevAuditEventIds /= emptyPrevId) then
        // Log info: Event has previous event ids
        logMessage := "AESequenceDC::HappyJob.JobInProgress : Follow on event (" & auditEventId & ") for existing Job received with jobId = " & this.jobID & " with Job Name = " & theJob.jobName & ", current event type = " & theEventType.AEType & " with " & prevAuditEventIds'length'image & " previous event ids";
	    Logger::log(Logger::Debug, "AESequenceDC", logMessage);   

        auditEventDataProcessed := false;
        for aPrevEventId in prevAuditEventIds loop 
          // Need to locate the previous event as defined in the event parameter
          prevEvent := find_one SequencedAuditEvent (AuditEventId = aPrevEventId);
          if prevEvent /= null then
            prevAeOccInSequenceDef := prevEvent -> R13;
            // Find the occurrence definitions for the events that are expected to follow that one as our new event should be one of those
            expectedAeOccsInSequenceDef := prevAeOccInSequenceDef -> R6.precedes.AEOccurrenceInSequenceDefinition;
      
            possibleAeOccInSequenceDef := expectedAeOccsInSequenceDef intersection theAeOccurrencesInSequenceDef;

            if (possibleAeOccInSequenceDef'length = 1) then
              theAeOccInSequenceDef := find_one possibleAeOccInSequenceDef ();
              // We have found the occurrence definition class to link with the new event
              if (newSeqEvent -> R13 = null) then
                link theAeOccInSequenceDef R13 newSeqEvent;
              end if;
          
              if theAeOccInSequenceDef.isSequenceStart = false then
	                 
                // We have a follow on event for an existing Job with a valid previous event
                theAeInSequencePairDefn := theAeOccInSequenceDef with prevAeOccInSequenceDef -> R6.follows.AEInSequencePairDefn;
                // Check that the previous event has not already been seen with this event as that would be an error
                existingAuditEventPair := find_one SequencedAuditEventPair (previousAuditEventId = prevEvent.AuditEventId and
                	                                               nextAuditEventId = newSeqEvent.AuditEventId);
               
                if existingAuditEventPair = null then
                  // Link the new event to the previous event to capture the sequence we are seeing
                  newAuditEventPair := create SequencedAuditEventPair (previousAuditEventId => prevEvent.AuditEventId,
                                                              nextAuditEventId => newSeqEvent.AuditEventId);
                  link newSeqEvent R4.has_previous.SequencedAuditEvent prevEvent using newAuditEventPair;
                  link newAuditEventPair R15 theAeInSequencePairDefn;
                  
                  // Also maintain the R47 link which links sequenced and unsequenced events
                  // This is necessary for the critical event check
                  prevEvt := prevEvent -> R46;
                  newAuditEventLink := create AuditEventLink (previousAEId => prevEvt.AEId,
                  	                                         nextAEId => newEvent.AEId);
                  link newEvent R47.has_previous.AuditEvent prevEvt using newAuditEventLink;
                  
                else
                    theJob.sequencingFailed := true;
                    theJob.failJob("The previous event has been repeated with this event which is an error for jobId = " & this.jobID & " with Job Name = " & theJob.jobName & " , current event type = " & theEventType.AEType & " , Event Id = " & newSeqEvent.AuditEventId & " and Previous Event Id = " & prevEvent.AuditEventId );              
                end if;  
             
                // Now test to see if this is a valid event sequence
                newSeqEvent.TestPreviousEventIsValid (prevEvent, prevEventIsValid); 
                if prevEventIsValid then
                  // Previous event is valid 
                  //logMessage := "AESequenceDC::Job.JobInProgress : Previous event is valid - jobId = " & this.jobID & ", audit event sequence = " & theSequenceDef.sequenceDefinitionName & ", current event type = " & theEventType.AEType;
	              //Logger::log(Logger::Debug, "AESequenceDC", logMessage);    
                  // The new event is a follow on event to the previous event so we know it is part of the same sequence as the previous event
                  currentSequence := prevEvent -> R11;
                  if currentSequence /= null then
                    if (newSeqEvent -> R11 = null) then
                      link newSeqEvent R11 currentSequence;
                    end if;  
                    if prevEvent.seenAsPreviousEvent = false then
                      //Implementation of part of the Hanrahan algorithm
                      currentSequence.branchExtent := currentSequence.branchExtent - 1;
                    end if;
                    // Note that the previous Audit Event has now been seen as a previous audit event       
                    prevEvent.seenAsPreviousEvent := true;


                
                    // Process the audit event data for this new event 
                    // checking we haven't already added the audit event data for this event
                    // This approach is a bit clunky but ensures we don't try to add the audit event data more than once
                    if auditEventDataProcessed = false then
                      newSeqEvent.ProcessAuditEventData (auditEventData);
                      auditEventDataProcessed := true;
                    end if;  
                  
                    // Add logic for incrementing Loop Count
                    theUserDynamicControlDefn := theAeOccInSequenceDef -> R31;
                    if theUserDynamicControlDefn /= null then                      
                      thisJobsDynamicControls := theJob -> R35;
                      
                      theUserDynamicControl := find_one thisJobsDynamicControls (dynamicControlName = theUserDynamicControlDefn.dynamicControlName );
                      if theUserDynamicControl /= null and theUserDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.LOOPCOUNT then
                        //MUN2-65 if (theUserDynamicControl -> R36) = null then
                          link theUserDynamicControl R36 newSeqEvent;
                        //MUN2-65 end if;                      
                    
                        if theUserDynamicControl.expectedDynamicControlValue > 0 then
                          if theUserDynamicControl.currentDynamicControlValue < theUserDynamicControl.expectedDynamicControlValue then
                            theUserDynamicControl.currentDynamicControlValue := theUserDynamicControl.currentDynamicControlValue + 1;
                          else
                            theJob.failJob("The loop count will exceed the expected loop count which is an error for jobId = " & this.jobID & " with Job Name = " & theJob.jobName & " , current event type = " & theEventType.AEType & " , Event Id = " & newSeqEvent.AuditEventId ); 
                          end if;
                          logMessage := "AESequenceDC::HappyJob.JobInProgress : The Dynamic Control value must be a positive integer and it is not " & theUserDynamicControlDefn.dynamicControlType'image & " for " & this.jobID & " with Job Name = " & theJob.jobName & " has value = " & theUserDynamicControl.expectedDynamicControlValue'image;
	                      Logger::log(Logger::Debug, "AESequenceDC", logMessage);
                        end if;  
                        
	                  else
                        logMessage := "AESequenceDC::HappyJob.JobInProgress : This event is not carrying a Dynamic Control of type " & theUserDynamicControlDefn.dynamicControlType'image & " for " & this.jobID & " with Job Name = " & theJob.jobName;
	                    Logger::log(Logger::Debug, "AESequenceDC", logMessage);
	                  end if;  
	                  
	                else 
	                  // This event doesn't have a loop count defined on it and so can be ignored
	                end if;  

                    // Check to see if this is a break event causing us to exit a loop and cancel the loop count
                    // TODO Is there a better way to do this now R36 and R37 have been added
                    if theAeOccInSequenceDef.isBreak = true then
                      thisJobsDynamicControls := theJob -> R35;
                      theCurrentDynamicControls := find thisJobsDynamicControls (expectedDynamicControlValue > 0);
                      for theCurrentDynamicControl in theCurrentDynamicControls loop
                        theCurrentDynamicControlDefn := theCurrentDynamicControl -> R29;
                        if theCurrentDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.LOOPCOUNT then
                          theCurrentDynamicControl.expectedDynamicControlValue := 0;
                        end if;
                      end loop;
                    end if;
	                

                    // Add logic for creating user Branch Count on Fork event
                    theUserDynamicControlDefn := theAeOccInSequenceDef -> R31;
                    if theUserDynamicControlDefn /= null and theUserDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.BRANCHCOUNT then                      

                      // We know this event is a fork point so find the corresponding source event to get the number of branches expected

                      theDynamicControls := theUserDynamicControlDefn -> R29;
                      theSourceDynamicControl := find_one theDynamicControls (isUser = false);
                      if theSourceDynamicControl /= null then
 
                        theUserDynamicControl := newSeqEvent -> R36;
                        if theUserDynamicControl = null then
                          // An additional 'usage' DynamicControl that is separate from the 'source' DynamicControl instance is created 
                          // in order to support nested forks.
                          theUserDynamicControl := create unique DynamicControl (expectedDynamicControlValue => theSourceDynamicControl.expectedDynamicControlValue,
                            	                                                 currentDynamicControlValue => 0,
                            	                                                 isUser => true);
                          link theUserDynamicControl R36 newSeqEvent;
                          link theUserDynamicControl R29 theUserDynamicControlDefn;
                          link theUserDynamicControl R35 theJob;

                        else
                          //this.failJob("This event already has a user branch count associated with it for jobId = " & this.jobID & " , current event type = " & theEventType.AEType & " , Event Id = " & newEvent.AuditEventId ); 

                        end if;  
                    
	                  else
                        theJob.failJob("The fork point has been found but no corresponding source branch count is associated with it for jobId = " & this.jobID & " with Job Name = " & theJob.jobName & " , current event type = " & theEventType.AEType & " , Event Id = " & newSeqEvent.AuditEventId ); 
	                  end if;  
	                  
	                else 
	                  // This event doesn't have a branch count defined on it and so can be ignored
	                end if;  

                    // Add logic for incrementing Branch Count - to count branches from a fork we have to look to see if the previous event was the fork event with a branch count on it.

                    thePrevUserDynamicControl := prevEvent -> R36;
                    if thePrevUserDynamicControl /= null and thePrevUserDynamicControl.isUser then
                      thePrevUserDynamicControl.currentDynamicControlValue := thePrevUserDynamicControl.currentDynamicControlValue + 1;
                      
                    end if;


                  
                    // TODO Verify this optional section is required
                    // Don't allow an instance branch unless there is a branch count defined
                    // This is an optional capability that adds extra verification. Without it instance branches
                    // can occur anywhere with any number of branches.
                    
                    theAeInSequencePairDefn := theAeOccInSequenceDef with prevAeOccInSequenceDef -> R6.follows.AEInSequencePairDefn;
                    allAuditEventPairs := theAeInSequencePairDefn -> R15;
                    thisJobsAuditEventPairs := theJob -> R44 -> R4.has_next.SequencedAuditEventPair;
                    theAuditEventPairs := allAuditEventPairs intersection thisJobsAuditEventPairs;
                    if theAuditEventPairs'length > 1 then
                      // There is either an instance fork or a loop so check that the AuditEventPairs have a common previous event to find the instance fork
                      for eachAuditEventPair in theAuditEventPairs loop
                        if eachAuditEventPair.previousAuditEventId = lastPreviousEventId then
                          instanceForkFound := true;
                          exit;
                        end if;  
                        lastPreviousEventId := eachAuditEventPair.previousAuditEventId;
                      end loop;
                      if instanceForkFound then
                      
                        // There is an instance fork so check that the previous event is a user of a branch count
                        thePrevUserDynamicControl := prevEvent -> R36;
                        if thePrevUserDynamicControl /= null and thePrevUserDynamicControl.isUser then                        
                          thePrevUserDynamicControlDefn := thePrevUserDynamicControl -> R29;
                          if thePrevUserDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.BRANCHCOUNT and thePrevUserDynamicControl.expectedDynamicControlValue > 0 then
                            logMessage := "AESequenceDC::HappyJob.JobInProgress : Valid Branch Count found on instance fork in Job = " & this.jobID & " with Job Name = " & theJob.jobName & " at Event Type = " & (prevEvent -> R2).AEType;
	                        Logger::log(Logger::Debug, "AESequenceDC", logMessage);                       
                          else
                            theJob.failJob("There is no Branch Count defined for this fork point in Job = " & this.jobID & " with Job Name = " & theJob.jobName & " at Event Type = " & (prevEvent -> R2).AEType);                         
                          end if;

                        else
                          // An instance fork has occurred but the Job Definition does not expect this to occur at this point in the sequence.
                          theJob.failJob("There is no Branch Count defined for this fork point in Job = " & this.jobID & " with Job Name = " & theJob.jobName & " at Event Type = " & (prevEvent -> R2).AEType);
                        end if;
                      else
                        // There is no instance fork here so carry on
                      end if;
                    else
                      // There is no instance fork here so carry on
                    end if;  
                    // End of optional section which adds a constraint that instance forks are not allowed if there is no branch count on the fork event

                    // Add logic for setting Merge Count
                    theUserDynamicControlDefn := theAeOccInSequenceDef -> R31;
                    if theUserDynamicControlDefn /= null and theUserDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.MERGECOUNT then                      
                      thisJobsDynamicControls := theJob -> R35;
                      
                      theUserDynamicControl := find_one thisJobsDynamicControls (dynamicControlName = theUserDynamicControlDefn.dynamicControlName);
                      if theUserDynamicControl /= null then
                        // TODO An additional 'usage' DynamicControl will need to be created to support nested merge points (similar to BRANCHCOUNT processing above)
                        
                        // The following test is necessary because this logic is executed 
                        // for EACH previous event of which there will be many at a merge point.
                        if (theUserDynamicControl -> R36) = null then
                          link theUserDynamicControl R36 newSeqEvent;
                        end if;                      
                        if theUserDynamicControl.expectedDynamicControlValue > 0 then
                          // The current Merge count value is set to the number of previous event ids
                          theUserDynamicControl.currentDynamicControlValue := prevAuditEventIds'length;                                           
                        end if;  
	                  else
                        logMessage := "AESequenceDC::HappyJob.JobInProgress : There is no event using a Dynamic Control of type " & theUserDynamicControlDefn.dynamicControlType'image & " for " & this.jobID & " with Job Name = " & theJob.jobName;
	                    Logger::log(Logger::Debug, "AESequenceDC", logMessage);
	                  end if;  

	                  
	                else 
	                  // This event doesn't have an event that has a loop count defined on it and so can be ignored
	                end if;  
                    
                  else
                    //Log Job failure: Previous event is valid but is part of a broken sequence
                    theJob.sequencingFailed := true;
                    theJob.failJob("The previous event is valid but is part of a broken sequence - Event Type = " & (prevEvent -> R2).AEType);
                  end if;  
          
                else
                  //Log Job failure: Previous event is not valid for this sequence
                  theJob.sequencingFailed := true;
                  theJob.failJob("The type of a previous event provided is not known or not valid - Event Id = " & aPrevEventId);
         
                end if;
              else
                // The received event is a sequence start event but it has a previous event with it. This is an error condition
                theJob.sequencingFailed := true;
                theJob.failJob("This is a sequence start event with a previous event which can't happen - in Job = " & this.jobID & " with Job Name = " & theJob.jobName & ", current event type = " & theEventType.AEType & ". event id = " & newSeqEvent.AuditEventId);
              end if;  
            elsif possibleAeOccInSequenceDef'length = 0 then
              // There is no available definition for this situation so the sequence is broken.
              theJob.sequencingFailed := true;
              theJob.failJob("The previous event is valid but is part of a broken sequence - Event Type = " & (prevEvent -> R2).AEType);
        
            else
              // There are multiple possible Audit Event Occurrences In the Sequence Definition 
              // TODO What does this circumstance imply and what can we do about it.
              theJob.sequencingFailed := true;
              theJob.failJob("There are multiple possible outcomes so this situation was not foreseen - in Job = " & this.jobID & " with Job Name = " & theJob.jobName & ", current event type = " & theEventType.AEType & ". event id = " & newSeqEvent.AuditEventId);
            end if;
          else
            // The previous event id provided in the audit event data is not recognised as a previous event 
            theJob.sequencingFailed := true;
            theJob.failJob("The previous event id provided in the audit event data is not recognised as a previous event - in Job = " & this.jobID & " with Job Name = " & theJob.jobName & " provided previous event id = " & aPrevEventId);
            
          end if;
        end loop; //End of loop over each previous event id  
        
        //MUN2-65 Addition
        // ...and now check that the received audit event data matches that which is expected
        newSeqEvent.CheckEventCarriesExpectedEventData (eventDataCheckHasPassed, failureReason); 
        if eventDataCheckHasPassed /= true then
          theJob.failJob(failureReason);
        end if;   
        // End of MUN2-65 Addition
                    
        // Need to increment the branch extent for this sequence for this new event as part of the Hanrahan algorithm  
        currentSequence := newSeqEvent -> R11;
        if currentSequence /= null then
          currentSequence.branchExtent := currentSequence.branchExtent + 1;
              
        else
          //Log Job failure: Previous event is valid but is part of a broken sequence
          theJob.sequencingFailed := true;
          theJob.failJob("No current sequence has been found for this audit event - Event Type = " & (newSeqEvent -> R2).AEType);
        end if;  

      else
        // There is no previous event so check for a single AEOccurrenceInSequenceDef that marks a sequence start
        theAeOccInSequenceDef := find_one theAeOccurrencesInSequenceDef (isSequenceStart = true);

        if theAeOccInSequenceDef /= null then
          // The new event type is one that starts a sequence even though it's for an existing Job. This indicates a follow on sequence for an existing Job
          // This is expected when a start event is seen for a new sequence in an existing Job
          link newSeqEvent R13 theAeOccInSequenceDef;
          //TODO Validate the new sequence is in the correct order
          // Check that no other sequences for the same Job are still in progress
          sequencesForJob := theJob -> R10;
          incompleteSequences := find sequencesForJob (isComplete = false);
          if incompleteSequences'length = 0 then
            // Log info: Received a new sequence start event for an existing Job but other sequences are complete
	        logMessage := "AESequenceDC::HappyJob.JobInProgress : A further new sequence has been started for - jobId = " & this.jobID & " with Job Name = " & theJob.jobName & ", with audit event = " & theEventType.AEType;
	        Logger::log(Logger::Debug, "AESequenceDC", logMessage);
	        
	        // This must be the first start event seen for a new sequence so create and link the sequence
	        newSequence := create unique Sequence (isComplete => theAeOccInSequenceDef.isSequenceEnd, branchExtent => 1);
	        link newSequence R10 theJob;
	        link newSequence R11 newSeqEvent;
	        link newSequence R14 theSequenceDef;
	        
	      else
            // Log info: Received a new sequence start event for an existing Job - but other sequences are still in progress
	        logMessage := "AESequenceDC::HappyJob.JobInProgress : A new sequence start event has been seen with other sequences incomplete for - jobId = " & this.jobID & " with Job Name = " & theJob.jobName & ", with audit event = " & theEventType.AEType;
	        Logger::log(Logger::Debug, "AESequenceDC", logMessage);
	        
	        // Need to check if an incomplete sequence is one of the right type for this event
	        for incompleteSequence in incompleteSequences loop
	          if (incompleteSequence -> R14) = theSequenceDef then
	            // We have an incomplete sequence of the same type as the new event belongs to so this must be another start event for that sequence
	            link incompleteSequence R11 newSeqEvent;
	            // So increment the branch extent
	            incompleteSequence.branchExtent := incompleteSequence.branchExtent + 1;
                // Log info: Received a new sequence start event that is an additional start event for an existing sequence
	            logMessage := "AESequenceDC::HappyJob.JobInProgress : An additional sequence start event has been seen for an existing sequence for - jobId = " & this.jobID & " with Job Name = " & theJob.jobName & ", in sequence = " & incompleteSequence.AESequenceId'image & "with audit event type = " & theEventType.AEType;
	            Logger::log(Logger::Debug, "AESequenceDC", logMessage);
	            
	          end if;
	        end loop;
	        // If the new start sequence event didn't match any existing sequences then it must be a new sequence
	        if (newSeqEvent -> R11) = null then
	          // This must be the first start event seen for a new sequence so create and link the sequence
	          newSequence := create unique Sequence (isComplete => theAeOccInSequenceDef.isSequenceEnd, branchExtent => 1);
	          link newSequence R10 theJob;
	          link newSequence R11 newSeqEvent;
	          link newSequence R14 theSequenceDef;          
	        end if;
	      end if;  



          // Process the audit event data for this new event
          newSeqEvent.ProcessAuditEventData (auditEventData);
          
          // ...and then check that the received audit event data matches that which is expected
          newSeqEvent.CheckEventCarriesExpectedEventData (eventDataCheckHasPassed, failureReason); 
          if eventDataCheckHasPassed /= true then
            theJob.failJob(failureReason);
          end if;
          
        else
          // We have a valid new event type and no previous event. This should indicate the start of
          // a new sequence within a Job yet the definition is ambiguous about which start event it is
          // TODO Check: Can this ever happen and if so what can we do about it?
          theJob.sequencingFailed := true;
          theJob.failJob("An event starting a new sequence has been received but there is no matching start event definition for Job = " & this.jobID & " with Job Name = " & theJob.jobName & ", with audit event type = " & theEventType.AEType);
        end if; 
      end if;    
 
       
      // Check to see if the received event marks an end point in the current sequence and if so check whether or
      // not it completes the sequence (note that sequences can have multiple end points due to branching)
      if (theAeOccInSequenceDef /= null) and (theAeOccInSequenceDef.isSequenceEnd) = true then
        currentSequence := newSeqEvent -> R11;
        if currentSequence /= null then
          // Check to to see if the 'end point' event in the sequence also marks the sequence end.
          generate Job.endEventInSequenceDetected(currentSequence) to this;
        else
          //Log Job failure: This event marks the end of a sequence but is part of a broken sequence
          theJob.sequencingFailed := true;
          theJob.failJob("This event marks the end of a sequence but is part of a broken sequence - Event Type = " & theEventType.AEType);
        end if;
  
      end if;
      
    elsif theUnseqEventType /= null then
      // We've seen an unsequenced event type
      // Migrate from HappyJob to UnhappyJob
      theJob.migrateToUnhappyJob(auditEventId, prevAuditEventIds, auditEventType, auditEventData);
                 
    else
      // Log error: unrecognised event type received
      theJob.sequencingFailed := true;
      theJob.failJob("An unrecognised event type - " & auditEventType & "has been received for - jobId = " & this.jobID & " with Job Name = " & theJob.jobName);
    //
    end if;
    //  
   // Set a timer to timeout if the job hangs waiting for another event
    theSystemSpec := find_one SystemSpecification();
    schedule theJob.jobHangingTimer generate Job.jobTimedOut() to theJob delay theSystemSpec.jobHangingTimeoutPeriod; 
    
  else
    theJob.sequencingFailed := true;
    theJob.failJob("This event has an identifier that's been seen before. Identifiers must be unique for a Job to be valid - Event Type = " & auditEventType);
    eventContent := "JobId = " & theJob.jobID & " with Job Name = " & theJob.jobName & " : FailureReason = The audit event has been seen before"  & " : EventId = " & auditEventId & " : EventType = " & auditEventType;
	Reporting~>reportEvent(Logger::Error, "svdc_job_failed", eventContent);  
  
  end if;     
  
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '79ee457c-fada-4ebb-8735-1e0b3b4a1284' 'eb73ac80-8d84-4fc3-8026-5f5e09a088b2' DO NOT EDIT THIS LINE.
state AESequenceDC::HappyJob.AssessingJobConstraints () is
theJob : instance of Job;
eachAuditEventPair : instance of SequencedAuditEventPair;
theAuditEventPairs : sequence of instance of SequencedAuditEventPair;
theConstraintDefn : instance of ConstraintDefinition;
theConstraintDefns : sequence of instance of ConstraintDefinition;
theConstrainedSeqPairDefns : sequence of instance of AEInSequencePairDefn;
eachConstrainedSeqPairDefn : instance of AEInSequencePairDefn;
theConstrainedAuditEventPairs : sequence of instance of SequencedAuditEventPair;
thePreviousAuditEvents : set of instance of SequencedAuditEvent;
theFollowingAuditEventPairs : sequence of instance of SequencedAuditEventPair;
theForkAuditEvent : instance of SequencedAuditEvent;
theBranchedEvents : set of instance of SequencedAuditEvent;
validatedConstraint : boolean;
validatedDynamicControl : boolean;
logMessage : string;
failureReason : string;
instrumentationEventId : string;
instrumentationEventType : string;


begin
  // Report that job sequencing has completed and constraint checking is about to begin as part of the 
  // verification of the Protocol Verifier itself.
  instrumentationEventId := "Unused";
  instrumentationEventType := "SVDC_PVEventProcessingComplete";
  BehaviourVerification~>sendInstrumentationEvent("ProtocolVerifier", this.jobID, instrumentationEventId, instrumentationEventType);
        
  // Need to check that constraints are honoured
  theJob := this -> R45;	
  theAuditEventPairs := theJob -> R10 -> R11 -> R4.has_next.SequencedAuditEventPair;
  validatedConstraint := true;
  for eachAuditEventPair in theAuditEventPairs loop
    theConstraintDefn := eachAuditEventPair -> R15 -> R16;
    if theConstraintDefn /= null then
      if theConstraintDefn.constraintType = AND then
        // AND Constraint Logic
        theConstrainedSeqPairDefns := theConstraintDefn -> R16.AEInSequencePairDefn;
        for eachConstrainedSeqPairDefn in theConstrainedSeqPairDefns loop
          // Check that every element within the AND constraint is present
          if ((eachConstrainedSeqPairDefn -> R15) intersection theAuditEventPairs)'length = 0 then
            validatedConstraint := false;
          end if;
        end loop;
      elsif theConstraintDefn.constraintType = XOR then
        //XOR Constraint logic
        theConstrainedSeqPairDefns := theConstraintDefn -> R16.AEInSequencePairDefn;
        // Find the constrained event pairs - the graph edges after the XOR node - in this Job
        theConstrainedAuditEventPairs := (theConstrainedSeqPairDefns -> R15) intersection theAuditEventPairs;
        // Find the preceding XOR graph nodes
        thePreviousAuditEvents := theConstrainedAuditEventPairs -> R4.has_previous.SequencedAuditEvent;
        // Check that after an XOR fork event there is a single branch.      
        // This is a sound check since exactly one branch will follow each XOR fork audit event.
        for thePreviousAuditEvent in thePreviousAuditEvents loop
          theFollowingAuditEventPairs := thePreviousAuditEvent -> R4.has_next.SequencedAuditEventPair;
          if theFollowingAuditEventPairs'length /= 1 then
            validatedConstraint := false;
            logMessage := "AESequenceDC::HappyJob.AssessingJobConstraints : XOR Constraint failed for Job = " & this.jobID & " with Job Name = " & theJob.jobName & " at event " & (thePreviousAuditEvent -> R2).AEType & " with " & theFollowingAuditEventPairs'length'image & " branches following the XOR node";
            Logger::log(Logger::Debug, "AESequenceDC", logMessage);   
          end if;
        end loop;  
      else
        logMessage := "AESequenceDC::HappyJob.AssessingJobConstraints : Unsupported Constraint Type for Job = " & this.jobID & " with Job Name = " & theJob.jobName;
        Logger::log(Logger::Debug, "AESequenceDC", logMessage);    
      end if;
    end if;  
  end loop;
  
  // Also check that loop constraints are satisfied
  declare
    theDynamicControls : set of instance of DynamicControl;
    theDynamicControlDefn : instance of DynamicControlDefinition;
    
  begin
    validatedDynamicControl := true;
    theDynamicControls := theJob -> R35;
    for theDynamicControl in theDynamicControls loop
      theDynamicControlDefn := theDynamicControl -> R29;
      if theDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.LOOPCOUNT then
        if (theDynamicControl.expectedDynamicControlValue > 0) and (theDynamicControl.expectedDynamicControlValue /= theDynamicControl.currentDynamicControlValue) then
          validatedDynamicControl := false;          
          logMessage := "AESequenceDC::HappyJob.AssessingJobConstraints : Loop Count check failed for Job = " & this.jobID & " with Job Name = " & theJob.jobName & " Expected Loop Count = " & theDynamicControl.expectedDynamicControlValue'image & " Current Loop Count = " & theDynamicControl.currentDynamicControlValue'image;
          Logger::log(Logger::Debug, "AESequenceDC", logMessage);    
        else
          logMessage := "AESequenceDC::HappyJob.AssessingJobConstraints : Loop Count check passed for Job = " & this.jobID & " with Job Name = " & theJob.jobName & " Expected Loop Count = " & theDynamicControl.expectedDynamicControlValue'image & " Current Loop Count = " & theDynamicControl.currentDynamicControlValue'image;
          Logger::log(Logger::Debug, "AESequenceDC", logMessage);              
        end if;
      elsif theDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.BRANCHCOUNT then
//        if (theDynamicControl.expectedDynamicControlValue > 0) and (theDynamicControl.expectedDynamicControlValue /= theDynamicControl.currentDynamicControlValue) then
//MUN2-65        theForkAuditEvent := theDynamicControl -> R36;

        if theDynamicControl -> R36 /= null then
        // We have a user dynamic control so check its values
          if (theDynamicControl.expectedDynamicControlValue > 0) and (theDynamicControl.currentDynamicControlValue /= theDynamicControl.expectedDynamicControlValue) then
            validatedDynamicControl := false;          
            logMessage := "AESequenceDC::HappyJob.AssessingJobConstraints : Branch Count check failed for Job = " & this.jobID & " with Job Name = " & theJob.jobName & " Expected Branch Count = " & theDynamicControl.expectedDynamicControlValue'image & " Current Branch Count = " & theBranchedEvents'length'image;
            Logger::log(Logger::Debug, "AESequenceDC", logMessage);    
          else
            logMessage := "AESequenceDC::HappyJob.AssessingJobConstraints : Branch Count check passed for Job = " & this.jobID & " with Job Name = " & theJob.jobName & " Expected Branch Count = " & theDynamicControl.expectedDynamicControlValue'image & " Current Branch Count = " & theBranchedEvents'length'image;
            Logger::log(Logger::Debug, "AESequenceDC", logMessage);              
          end if;
        else
          // This is the source branch count which isn't checked
        end if;    
      elsif theDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.MERGECOUNT then
        if theDynamicControl -> R36 /= null then
        // We have a user dynamic control so check its values
          if (theDynamicControl.expectedDynamicControlValue > 0) and (theDynamicControl.expectedDynamicControlValue /= theDynamicControl.currentDynamicControlValue) then
            validatedConstraint := false;    
            // TODO Remove debug log message      
            logMessage := "AESequenceDC::HappyJob.AssessingJobConstraints : Merge Count check failed for Job = " & this.jobID & " with Job Name = " & theJob.jobName & " Expected Merge Count = " & theDynamicControl.expectedDynamicControlValue'image & " Current Merge Count = " & theDynamicControl.currentDynamicControlValue'image;
            Logger::log(Logger::Debug, "AESequenceDC", logMessage);    
          else
            logMessage := "AESequenceDC::HappyJob.AssessingJobConstraints : Merge Count check passed for Job = " & this.jobID & " with Job Name = " & theJob.jobName & " Expected Merge Count = " & theDynamicControl.expectedDynamicControlValue'image & " Current Merge Count = " & theDynamicControl.currentDynamicControlValue'image;
            Logger::log(Logger::Debug, "AESequenceDC", logMessage);              
          end if;
        else
          // An event with the merge count has not been encountered so no need to check
        end if;
      end if;
    end loop;
  end;
  
  if (validatedConstraint = false) or (validatedDynamicControl = false) then
    // One or more of the checks has failed - determine which ones and act accordingly
    if (validatedConstraint = false) and (validatedDynamicControl = true) then
      // Only the constraint checks have failed
      failureReason := "one or more constraint checks have failed";
      generate Job.jobFailed(failureReason) to theJob;
    else
      if (validatedConstraint = true) and (validatedDynamicControl = false) then
        // Only the dynamic control checks have failed
        failureReason := "one or more dynamic control checks have failed";
        generate Job.jobFailed(failureReason) to theJob;
      else
        // Both checks must have failed
        failureReason := "one or more constraint checks AND one or more dynamic control checks have failed";
        generate Job.jobFailed(failureReason) to theJob;
      end if;
    end if;
  else
    // All constraint and dynamic control checks have passed for this Job
    logMessage := "AESequenceDC::HappyJob.AssessingJobConstraints : Constraint and dynamic control checks passed for - jobId = " & this.jobID & " with Job Name = " & theJob.jobName;
    Logger::log(Logger::Debug, "AESequenceDC", logMessage);
    generate Job.constraintCheckSuccessful() to theJob;
  end if;
  
//  if validatedConstraint = false then
//    failureReason := "Constraint Failed";
//    generate Job.jobFailed(failureReason) to this;
//  else
//    logMessage := "Constraint check passed for - jobId = " & this.jobID;
//    Logger::log(Logger::Information, "AESequenceDC", logMessage);
//    generate Job.constraintCheckSuccessful() to this;
//  end if;
//
end state;
//
//
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '79ee457c-fada-4ebb-8735-1e0b3b4a1284' '5d25c0e7-d344-4ec7-99f5-a1c1660a3d52' DO NOT EDIT THIS LINE.
state AESequenceDC::HappyJob.JobFailed () is
logMessage : string;
theSystemSpec : instance of SystemSpecification;
theJob : instance of Job;
eventContent : string;
instrumentationEventId : string;
instrumentationEventType : string;


begin
  // Report that SVDC considers that the respective Job has failed as part of the 
  // verification of the Protocol Verifier itself.
  instrumentationEventId := "Unused";
  instrumentationEventType := "SVDC_PVJobFails";
  BehaviourVerification~>sendInstrumentationEvent("ProtocolVerifier", this.jobID, instrumentationEventId, instrumentationEventType);
  
  theJob := this -> R45;
  // Cancel the jobDeletionTimer (that may have been set in previous states) in preparation
  // for being set again within this state.
  cancel theJob.jobDeletionTimer;
  
  // The following line is necessary because it is possible for JobFailed to be received when the Job has completed
  // Current policy is that FailJob from AEOrdering trumps all behaviour in SVDC and so even a completed Job will be
  // set to JobFailed in this situation. Consequently it seems appropriate to clear the jobCompleted boolean
  theJob.jobCompleted := false;
  
  // Log info: Audit Event Sequence Verification has been informed of Job failure
  logMessage := "AESequenceDC::HappyJob.JobFailed : Job Failed - jobId = " & this.jobID & " with Job Name = " & theJob.jobName & " due to: " & failureReason;
  Logger::log(Logger::Error, "AESequenceDC", logMessage);
  eventContent := "FailureReason = " & failureReason & " : JobId = " & this.jobID & " with Job Name = " & theJob.jobName;
  Reporting~>reportEvent(Logger::Error, "svdc_job_failed", eventContent);
  for evt in theJob->R10->R11.SequencedAuditEvent loop
	  eventContent := "EventId = " & evt.AuditEventId;
	  Reporting~>reportEvent(Logger::Information, "svdc_event_processed", eventContent);
  end loop;
  
  // The Job is near the end of it's useful life - wait a bit longer and then trigger its final demise.
  theSystemSpec := find_one SystemSpecification();
  schedule theJob.jobDeletionTimer generate Job.endOfLifeReached() to this delay theSystemSpec.jobDeletionWaitPeriod;
  //          
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '79ee457c-fada-4ebb-8735-1e0b3b4a1284' '4e4b96fc-df65-404d-84f8-984664efcbb7' DO NOT EDIT THIS LINE.
state AESequenceDC::HappyJob.JobGoneHorriblyWrong () is
theJob : instance of Job;
logMessage : string;
theSystemSpec : instance of SystemSpecification;
eventContent : string;
instrumentationEventId : string;
instrumentationEventType : string;


begin
  // Report that SVDC considers that the respective Job has gone horribly wrong as part of the 
  // verification of the Protocol Verifier itself.
  instrumentationEventId := "Unused";
  instrumentationEventType := "SVDC_PVJobGoneHorriblyWrong";
  BehaviourVerification~>sendInstrumentationEvent("ProtocolVerifier", this.jobID, instrumentationEventId, instrumentationEventType);
 
  theJob := this -> R45;
  // Cancel the jobDeletionTimer (that may have been set in previous states) in preparation
  // for being set again within this state.
  cancel theJob.jobDeletionTimer;
  
  // The following line is necessary because it seems appropriate to clear the jobCompleted boolean if further
  // events are received after the Job completed
  theJob.jobCompleted := false;

  // Log error: new follow on event received for completed or failed Job
      // Log info: Audit Event Sequence Verification has been informed of Job completion
  logMessage := "AESequenceDC::HappyJob.JobGoneHorriblyWrong : Job gone horribly wrong - a follow on event for a completed or failed job has been received - jobId = " & this.jobID & " with Job Name = " & theJob.jobName;
  Logger::log(Logger::Error, "AESequenceDC", logMessage);
  eventContent := "FailureReason = Job gone horribly wrong - a follow on event for a completed or failed job has been received" & " : JobId = " & this.jobID & " with Job Name = " & theJob.jobName;
  Reporting~>reportEvent(Logger::Error, "svdc_job_failed", eventContent);

  // The Job is near the end of it's useful life - wait a bit longer and then trigger its final demise.
  theSystemSpec := find_one SystemSpecification();
  schedule theJob.jobDeletionTimer generate Job.endOfLifeReached() to theJob delay theSystemSpec.jobDeletionWaitPeriod;
  //
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '79ee457c-fada-4ebb-8735-1e0b3b4a1284' '7fc9a805-6528-448d-a328-03229cfaef6a' DO NOT EDIT THIS LINE.
state AESequenceDC::HappyJob.AssessingSequenceCompletion () is
theJob : instance of Job;
aeSequenceDefs : set of instance of AESequenceDefinition;
completeSequences : set of instance of Sequence;
sequencesForJob : set of instance of Sequence;
theSystemSpec : instance of SystemSpecification;
logMessage : string;
 
begin
  theJob := this -> R45;
  // Log info: Audit Event Sequence Verification is checking for completion of a Sequence or Job
  logMessage := "AESequenceDC::HappyJob.AssessingSequenceCompletion : Checking for completion of a Sequence or Job - jobId = " & this.jobID & " with Job Name = " & theJob.jobName & " ,sequenceId = " & thePotentiallyCompletedSequence.sequenceId'image & " and branch extent = " & thePotentiallyCompletedSequence.branchExtent'image;
  Logger::log(Logger::Debug, "AESequenceDC", logMessage); 

  // Test to see if this is the last 'end' event for the current sequence
  thePotentiallyCompletedSequence.branchExtent := thePotentiallyCompletedSequence.branchExtent - 1;
  if thePotentiallyCompletedSequence.branchExtent = 0 then
    thePotentiallyCompletedSequence.isComplete := true; 
  else
    thePotentiallyCompletedSequence.isComplete := false;
  end if;  
   
  // Then check to see if the job is complete
  aeSequenceDefs := theJob -> R8 -> R7;
  sequencesForJob := theJob -> R10;
  completeSequences := find sequencesForJob (isComplete = true);
  theSystemSpec := find_one SystemSpecification();
  if aeSequenceDefs'length = completeSequences'length then
    // All sequences for the Job appear to be complete - but just in case there's a late delivery of the first
    // event in a previously unseen optional branch of one of those sequences then give a short period for it to 
    // arrive before moving the Job into the JobCompleted state.
    schedule theJob.jobEventTimer generate Job.jobComplete() to theJob delay theSystemSpec.intraSequenceEventTimeoutPeriod;
  else
    // The job or sequence is waiting for another event to arrive but one doesn't happen
    schedule theJob.jobHangingTimer generate Job.jobTimedOut() to theJob delay theSystemSpec.jobHangingTimeoutPeriod;    
  end if;
        
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '79ee457c-fada-4ebb-8735-1e0b3b4a1284' '6d43c29d-8299-4bda-a0b3-12cd5f4c9475' DO NOT EDIT THIS LINE.
state AESequenceDC::HappyJob.JobTimeoutReported () is
theJob : instance of Job;
logMessage : string;
begin
  // TODO: Can a jobFailed event occur once this state is reached?
  theJob := this -> R45;  
  logMessage := "AESequenceDC::HappyJob.JobTimeoutReported : The Job has been reported having timed out - jobId = " & this.jobID & " with Job Name = " & theJob.jobName;
  Logger::log(Logger::Debug, "AESequenceDC", logMessage);
  
  
  theJob.sequencingFailed := true;
  theJob.failJob("The job has timed out because it hasn't seen a complete expected sequence of events within the Job Hanging Timeout Period or because of a blocked event timeout for jobId = " & this.jobID & " with Job Name = " & theJob.jobName);              
  
  // TODO: Consider adding a jobTimedOut (boolean) attribute to Job and set this to true on
  //       entry to this state such that it can be used in test assertions (because you cannot
  //       currently check the value of the current_state 'attribute'.

end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '79ee457c-fada-4ebb-8735-1e0b3b4a1284' 'e330d1ec-f909-4af3-89c1-efc70dafd792' DO NOT EDIT THIS LINE.
state AESequenceDC::HappyJob.JobSuccessful () is
theJob : instance of Job;
logMessage : string;
theSystemSpec : instance of SystemSpecification;
eventContent : string;
jobDefinition : instance of JobDefinition;
instrumentationEventId : string;
instrumentationEventType : string;


begin
  // Report that SVDC considers that the respective Job has completed successfully as part of the 
  // verification of the Protocol Verifier itself.
  instrumentationEventId := "Unused";
  instrumentationEventType := "SVDC_PVJobSuccessful";
  BehaviourVerification~>sendInstrumentationEvent("ProtocolVerifier", this.jobID, instrumentationEventId, instrumentationEventType);
  
  // Job is considered to have completed - Record and log this fact.
  theJob := this -> R45;
  theJob.jobCompleted := true;
  jobDefinition := theJob -> R8.JobDefinition;
  // Log info: Audit Event Sequence Verification has determined that the Job is Complete
  logMessage := "AESequenceDC::HappyJob.JobSuccessful : Sequence Verification determines that the Job - jobId = " & this.jobID & " with Job Name = " & theJob.jobName & " is complete.";
  Logger::log(Logger::Debug, "Monitored System Status", logMessage);
  eventContent := "JobId = " & this.jobID & " : JobName = " & jobDefinition.jobName;
  Reporting~>reportEvent(Logger::Information, "svdc_job_success", eventContent);
  for evt in theJob->R10->R11.SequencedAuditEvent loop
	  eventContent := "EventId = " & evt.AuditEventId;
	  Reporting~>reportEvent(Logger::Information, "svdc_event_processed", eventContent);
  end loop;
  
  // The Job is thus near the end of it's useful life - wait a bit longer and then trigger its final demise.
  theSystemSpec := find_one SystemSpecification();
  schedule theJob.jobDeletionTimer generate Job.endOfLifeReached() to theJob delay theSystemSpec.jobDeletionWaitPeriod;
  //
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '79ee457c-fada-4ebb-8735-1e0b3b4a1284' 'bde8a97d-01da-4c64-83e4-ea4be6c0c87f' DO NOT EDIT THIS LINE.
state AESequenceDC::HappyJob.Deleted () is
theJob : instance of Job;
logMessage : string;
theJobID : string;
jobName : string;

begin
  theJob := this -> R45;
  // The Job has reached the end of its useful life and can be deleted.
  theJobID := this.jobID;
  jobName := theJob.jobName;
  theJob.deleteJob();
  
  // Synchronise the deletion of any counterpart Job instances in other domains.
  JobAdmin~>deleteJob(theJobID);

  logMessage := "AESequenceDC::HappyJob.Deleted : Job with jobID: " & theJobID & " with Job Name = " & jobName & " has been deleted";
  Logger::log(Logger::Debug, "AESequenceDC", logMessage);
  //
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '79ee457c-fada-4ebb-8735-1e0b3b4a1284' 'b1695a3a-5485-425b-893d-ac6635dfe8bf' DO NOT EDIT THIS LINE.
state AESequenceDC::HappyJob.AssessingIntraJobInvariants () is
theJob : instance of Job;
expectedIntraJobInvDefns : set of instance of IntraJobInvariantDefn;
theExpectedIntraJobInvDefn : instance of IntraJobInvariantDefn;
theJobsAuditEvents : set of instance of SequencedAuditEvent;
theInvariantAuditEvents : set of instance of SequencedAuditEvent;
theJobsInvariantAuditEvents : set of instance of SequencedAuditEvent;
theIntraJobInvariant : instance of TransientInvariant;
intraJobInvariantCheckPassed : boolean;
matched : boolean;
invariantValue : string := "";
failureReason : string;
logMessage : string;
instrumentationEventId : string;
instrumentationEventType : string;


begin
  // Report that job constraint checking has passed and invariant checking is about to begin as part of the 
  // verification of the Protocol Verifier itself.
  instrumentationEventId := "Unused";
  instrumentationEventType := "SVDC_PVConstraintCheckPassed";
  BehaviourVerification~>sendInstrumentationEvent("ProtocolVerifier", this.jobID, instrumentationEventId, instrumentationEventType);
        
  
// Checking Intra Job Invariants if any
      theJob := this -> R45;
      intraJobInvariantCheckPassed := true;
      theJobsAuditEvents := theJob -> R10 -> R11;
      expectedIntraJobInvDefns := theJob -> R10 -> R11 -> R13 -> R19;
      for theExpectedIntraJobInvDefn in expectedIntraJobInvDefns loop
        theInvariantAuditEvents := theExpectedIntraJobInvDefn -> R19 -> R13;
        // This finds the set of audit events that are expected to have invariants attached
        theJobsInvariantAuditEvents :=  theJobsAuditEvents intersection theInvariantAuditEvents;
        for eachJobsInvariantAuditEvent in theJobsInvariantAuditEvents loop
          theIntraJobInvariant := eachJobsInvariantAuditEvent -> R23;
          if theIntraJobInvariant /= null then
            if invariantValue = "" then
              invariantValue := theIntraJobInvariant.invariantValue;
            else  
              if invariantValue /= theIntraJobInvariant.invariantValue then
                intraJobInvariantCheckPassed := false;
              end if;
            end if;    
          else
            // No invariant provided with the audit event when expected
            intraJobInvariantCheckPassed := false;
          end if;  
        end loop;
      end loop;
      
      if intraJobInvariantCheckPassed then
        logMessage := "AESequenceDC::HappyJob.AssessingIntraJobInvariants : Intra-Job Invariant check passed for - jobId = " & this.jobID & " with Job Name = " & theJob.jobName;
        Logger::log(Logger::Debug, "AESequenceDC", logMessage);
        generate Job.intraJobInvariantCheckSuccessful() to theJob;
      else
        failureReason := "Check of Intra-Job Invariants Failed";
        generate Job.jobFailed(failureReason) to theJob;
      end if;  
  
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '79ee457c-fada-4ebb-8735-1e0b3b4a1284' '1e0057c2-1880-4079-b507-85b7783e4850' DO NOT EDIT THIS LINE.
state AESequenceDC::HappyJob.AwaitingPersistenceService () is
theJob : instance of Job;
theSystemSpec : instance of SystemSpecification;
failureReason : string;
logMessage : string;

begin
  theJob := this -> R45;

  //TODO Remove debug message
  logMessage := "AESequenceDC::HappyJob.AwaitingPersistenceService : Entered state Awaiting Persistence Service for - jobId = " & this.jobID & " with Job Name = " & theJob.jobName;
  Logger::log(Logger::Debug, "AESequenceDC", logMessage);
  
  theSystemSpec := find_one SystemSpecification ();
  failureReason := " Request for invariants from the persistence store has timed out meaning the Extra Job Invariant Check has failed " & this.jobID & " with Job Name = " & theJob.jobName;
  schedule theJob.jobInvariantSyncTimer generate Job.persistenceSyncTimedOut(failureReason) to theJob delay theSystemSpec.persistentInvariantRestoreTimeoutPeriod;
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '79ee457c-fada-4ebb-8735-1e0b3b4a1284' 'e21775f1-ae02-47a7-aa98-3e0a45778288' DO NOT EDIT THIS LINE.
state AESequenceDC::HappyJob.AssessingLocalExtraJobInvariants () is
theJob : instance of Job;
expectedUserExtraJobInvDefns : set of instance of ExtraJobInvariantDefn;
theExpectedUserExtraJobInvDefn : instance of ExtraJobInvariantDefn;
theJobsAuditEvents : set of instance of SequencedAuditEvent;
theInvariantAuditEvents : set of instance of SequencedAuditEvent;
theJobsInvariantAuditEvents : set of instance of SequencedAuditEvent;
theTransientExtraJobInvariant : instance of TransientInvariant;
thePersistedExtraJobInvariant : instance of PersistedInvariant;
theRestoredPersistentInvariant : instance of PersistedInvariant;
thePersistedExtraJobInvariants : set of instance of PersistedInvariant;
theInForcePersistedExtraJobInvariants : set of instance of PersistedInvariant;
restoredInvariant : persistedInvariantStructure;
extraJobInvariantCheckPassed : boolean;
matched : boolean;
invariantValue : string := "";
failureReason : string;
logMessage : string;

begin      
  // Checking Extra Job Invariants
      theJob := this -> R45;
      matched := false;
      extraJobInvariantCheckPassed := true;
      theJobsAuditEvents := theJob -> R10 -> R11;
      expectedUserExtraJobInvDefns := theJob -> R10 -> R11 -> R13 -> R21;
      for theExpectedUserExtraJobInvDefn in expectedUserExtraJobInvDefns loop
        theInvariantAuditEvents := theExpectedUserExtraJobInvDefn -> R21 -> R13;
        // This finds the set of audit events that are expected to have invariants attached
        theJobsInvariantAuditEvents :=  theJobsAuditEvents intersection theInvariantAuditEvents;
        for eachInvariantAuditEvent in theJobsInvariantAuditEvents loop
          // Iterate over each Audit Event which is expected to have a user extra job invariant attached
          theTransientExtraJobInvariant := eachInvariantAuditEvent -> R23;
          thePersistedExtraJobInvariants := theTransientExtraJobInvariant -> R28 -> R24;
          // The following allows for more than one instance of a persisted extra job invariant to be in force at the same time
          // If any one of them matches the value of the transient invariant then the transient invariant is valid
          theInForcePersistedExtraJobInvariants := find thePersistedExtraJobInvariants (inForce = true);
          for eachInForceInvariant in theInForcePersistedExtraJobInvariants loop
            if eachInForceInvariant.invariantValue = theTransientExtraJobInvariant.invariantValue then
              matched := true;
              exit;
            else
              matched := false;
            end if;  
          end loop;

          if not matched then
            // Check to see if there is a stored persistent invariant 
            Persistence_Req_IF~>RestoreNamedInvariant(theTransientExtraJobInvariant.extraJobInvName,
            	                               theTransientExtraJobInvariant.invariantValue);
            generate Job.WaitForStoredInvariants() to theJob;   
            extraJobInvariantCheckPassed := false;
            exit;
          end if;      
                      
        end loop;
      end loop;


      if extraJobInvariantCheckPassed then
        logMessage := "AESequenceDC::HappyJob.AssessingLocalExtraJobInvariants : Extra-Job Invariant check passed for - jobId = " & this.jobID & " with Job Name = " & theJob.jobName;
        Logger::log(Logger::Debug, "AESequenceDC", logMessage);
        generate Job.extraJobInvariantCheckSuccessful() to theJob;
      else
        logMessage := "AESequenceDC::HappyJob.AssessingLocalExtraJobInvariants : Local Extra-Job Invariants insufficient so checking stored value for - jobId = " & this.jobID & " with Job Name = " & theJob.jobName;
        Logger::log(Logger::Debug, "AESequenceDC", logMessage);
      end if;  
  
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '79ee457c-fada-4ebb-8735-1e0b3b4a1284' 'a1247002-df49-43ba-b6ab-1451bb29631c' DO NOT EDIT THIS LINE.
state AESequenceDC::HappyJob.ReassessingExtraJobInvariants () is
theJob : instance of Job;
expectedUserExtraJobInvDefns : set of instance of ExtraJobInvariantDefn;
theExpectedUserExtraJobInvDefn : instance of ExtraJobInvariantDefn;
theJobsAuditEvents : set of instance of SequencedAuditEvent;
theInvariantAuditEvents : set of instance of SequencedAuditEvent;
theJobsInvariantAuditEvents : set of instance of SequencedAuditEvent;
theTransientExtraJobInvariant : instance of TransientInvariant;
thePersistedExtraJobInvariant : instance of PersistedInvariant;
thePersistedExtraJobInvariants : set of instance of PersistedInvariant;
theInForcePersistedExtraJobInvariants : set of instance of PersistedInvariant;
extraJobInvariantCheckPassed : boolean;
matched : boolean;
failureReason : string;
logMessage : string;

begin  
  // Clear the time
  theJob := this -> R45;
  cancel theJob.jobInvariantSyncTimer;    
  // Checking Extra Job Invariants including those recovered from the persistent invariant store
      matched := false;
      extraJobInvariantCheckPassed := true;
      theJobsAuditEvents := theJob -> R10 -> R11;
      expectedUserExtraJobInvDefns := theJob -> R10 -> R11 -> R13 -> R21;
      for theExpectedUserExtraJobInvDefn in expectedUserExtraJobInvDefns loop
        theInvariantAuditEvents := theExpectedUserExtraJobInvDefn -> R21 -> R13;
        // This finds the set of audit events that are expected to have invariants attached
        theJobsInvariantAuditEvents :=  theJobsAuditEvents intersection theInvariantAuditEvents;
        for eachInvariantAuditEvent in theJobsInvariantAuditEvents loop
          // Iterate over each Audit Event which is expected to have a user extra job invariant attached
          theTransientExtraJobInvariant := eachInvariantAuditEvent -> R23;
          thePersistedExtraJobInvariants := theTransientExtraJobInvariant -> R28 -> R24;
          // The following allows for more than one instance of a persisted extra job invariant to be in force at the same time
          // If any one of them matches the value of the transient invariant then the transient invariant is valid
          theInForcePersistedExtraJobInvariants := find thePersistedExtraJobInvariants (inForce = true);
          for eachInForceInvariant in theInForcePersistedExtraJobInvariants loop
            if eachInForceInvariant.invariantValue = theTransientExtraJobInvariant.invariantValue then
              matched := true;
              exit;
            else
              matched := false;
            end if;  
          end loop;

          if not matched then
            extraJobInvariantCheckPassed := false;
            exit;
          end if;      
                      
        end loop;
      end loop;


      if extraJobInvariantCheckPassed then
        logMessage := "AESequenceDC::HappyJob.ReassessingExtraJobInvariants : Extra-Job Invariant check passed for - jobId = " & this.jobID & " with Job Name = " & theJob.jobName;
        Logger::log(Logger::Debug, "AESequenceDC", logMessage);
        generate Job.extraJobInvariantCheckSuccessful() to theJob;
      else
        failureReason := "Extra-Job Invariant check failed including checking stored invariants";
        generate Job.jobFailed (failureReason) to theJob;
      end if;  
  
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

