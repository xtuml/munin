// BP 7.1.6 content: ModelClass syschar: 3 persistence-version: 7.1.6

within SequenceVerificationDataCentric::SVDCdomain::AESequenceDC::SVDCclasses is

  //! An Audit Event received from the monitored system. It contains sufficient information:
  //! to associate it with a single Job,
  //! to link it to a single Audit Event Definition
  //! and to identify its previous audit events (if any)
  @key_letters("AE");
  @class_num(5);
  class AuditEvent is

    AuditEventId: string;

    @ref_mode("referred_to");
    jobID: referential (R3.Job.jobID) string;

    @ref_mode("referred_to");
    sequenceId: referential (R11.Sequence.sequenceId) integer;

    //! Set true seen as a previous event in a sequence. Used to calculate branch extent.
    seenAsPreviousEvent: boolean;

    @ref_mode("referred_to");
    AESequenceId: referential (R13.AEOccurrenceInSequenceDefinition.AESequenceId) integer;

    @ref_mode("referred_to");
    AEDefinitionId: referential (R13.AEOccurrenceInSequenceDefinition.AEDefinitionId, R2.AuditEventDefinition.AEDefinitionId) integer;

    @ref_mode("referred_to");
    occurrenceNumberInSequence: referential (R13.AEOccurrenceInSequenceDefinition.occurrenceNumberInSequence) integer;

    preferred identifier is (AuditEventId);

    @operation_num(1);
    class operation AddEventForNewJob(jobId: in string, eventId: in string, prevAEIds: in sequence of string, aeType: in string, aeData: in sequence of auditEventDataStructure) is
      @noparse
      newJob :  instance of Job;
      newEvent : instance of AuditEvent;
      oldEvent : instance of AuditEvent;
      newEventType : instance of AuditEventDefinition;
      prevEvent : instance of AuditEvent;
      theAeSequenceDef : instance of AESequenceDefinition;
      theAeInSequenceDef : instance of AEInSequenceDefinition;
      theAeOccInSequenceDef : instance of AEOccurrenceInSequenceDefinition;
      theAeOccurrencesInSequenceDef : set of instance of AEOccurrenceInSequenceDefinition;
      theJobDef : instance of JobDefinition;
      newSequence : instance of Sequence;
      logMessage : string;
      creationErrorMessage : string;
      
      empty : sequence of string;
      emptyString : sequence of string := empty & ("");
      
      begin
        oldEvent := find_one AuditEvent (AuditEventId = eventId);
        // Check to see if we've seen this event instance before
        if (oldEvent = null) then
          //We have a new job and this event must be a valid initial event for a Job
          newJob := create Job (jobID => jobId, sequencingFailed => false, jobCompleted => false, Current_State => JobInProgress );
          newEvent := create AuditEvent (AuditEventId => eventId);
        
          link newJob R3 newEvent;
          newEventType := find_only AuditEventDefinition (AEType = aeType);
          if (newEventType /= null) and ((prevAEIds = empty) or (prevAEIds = emptyString)) then
        	  //We have a valid event type and no previous events
        	  // So check that it is also the first event of a sequence in that Job
            link newEvent R2 newEventType;
            theAeSequenceDef := newEventType -> R1.AESequenceDefinition;
            theJobDef := theAeSequenceDef -> R7;
            theAeInSequenceDef := theAeSequenceDef with newEventType -> R1.AEInSequenceDefinition;
            theAeOccurrencesInSequenceDef := theAeInSequenceDef -> R12;
            //TODO should the following be a find and then check there is only one since more than one would be a definition error
            theAeOccInSequenceDef := find_one theAeOccurrencesInSequenceDef (isSequenceStart = true);
            if theAeOccInSequenceDef /= null then
              link newEvent R13 theAeOccInSequenceDef;
              newSequence := create unique Sequence(isComplete => theAeOccInSequenceDef.isSequenceEnd, branchExtent => 1);
              link newSequence R10 newJob;
              link newSequence R11 newEvent;
              link newSequence R14 theAeSequenceDef;
         
              link newJob R8 theJobDef;
              //The the first event for this new Job is a valid event type for starting the sequence
              // Log info: new Job and event sequence started
              logMessage := "New Job started - jobId = " & newJob.jobID & ", Initial audit event: " & eventId & " of type " & newEventType.AEType;
      	    Logger::log(Logger::Information, "AESequenceDC", logMessage);
                
           
              // Process the audit event data for this new event      
              newEvent.ProcessAuditEventData (aeData);
            
              
            else
              newJob.failJob("Invalid audit event definition for a start event in job definition = " & theJobDef.jobName & " since the occurrenceNumberInSequence is expected to be 1");    
            end if;  
          else
            //We have an unrecognised event type
            // Log error: unrecognised event type received
            newJob.sequencingFailed := true;
            newJob.failJob("An unrecognised event type has been received - Job Id = " & newJob.jobID & " Event Type = " & newEventType.AEType);
          
          end if;
        else
            // Log error: The audit event id received has been seen before
      	  logMessage := "The audit event has been seen before for jobId = " & jobId & ", Initial audit event = " & aeType;
      	  Logger::log(Logger::Information, "AESequenceDC", logMessage);
         
        end if;  
        //
      end service;
      @endnoparse
    end operation;

    @operation_num(2);
    operation AddEventTBD() is
      @noparse
      newJob :  instance of Job;
      newEvent : instance of AuditEvent;
      newEventType : instance of AuditEventDefinition;
      prevEvent : instance of AuditEvent;
      
      begin
        null;
        //
        //
        //
        //
        //
        //
        //
        //
      end service;
      @endnoparse
    end operation;

    @operation_num(3);
    operation TestPreviousEventIsValid(prevEventInstance: in instance of AuditEvent, previousEventIsValid: out boolean) is
      @noparse
      //The Audit Event instance on which this operation is invoked is newEvent
      // The input parameter is prevEventInstance
      
      //prevEventInstance : instance of AuditEvent;
      theAuditEventDefinition : instance of AuditEventDefinition;
      prevAuditEventDefinition : instance of AuditEventDefinition;
      thisEventInSequence : instance of AEInSequenceDefinition;
      prevEventOccInSequence : instance of AEOccurrenceInSequenceDefinition;
      intersectionEventOccsInSequence : set of instance of AEOccurrenceInSequenceDefinition;
      intersectionEventOccInSequence : instance of AEOccurrenceInSequenceDefinition;
      thisAeOccInSequenceDef : instance of AEOccurrenceInSequenceDefinition;
      theseAeOccurrencesInSequenceDef : set of instance of AEOccurrenceInSequenceDefinition;
      possibleAeOccurrencesInSequenceDef : set of instance of AEOccurrenceInSequenceDefinition;
      theSequenceDef : instance of AESequenceDefinition;
      theJob : instance of Job;
      isValidEventPair : boolean := false;
      
      begin
        theJob := this -> R3;
       
        theAuditEventDefinition := this -> R2;
        prevEventOccInSequence := prevEventInstance -> R13;
        
        if prevEventOccInSequence.isSequenceEnd = false then
          theSequenceDef := theAuditEventDefinition -> R1.AESequenceDefinition;
          thisEventInSequence := theAuditEventDefinition with theSequenceDef -> R1.AEInSequenceDefinition;
          theseAeOccurrencesInSequenceDef := thisEventInSequence -> R12;
          possibleAeOccurrencesInSequenceDef := prevEventOccInSequence -> R6.precedes.AEOccurrenceInSequenceDefinition;
          intersectionEventOccsInSequence := possibleAeOccurrencesInSequenceDef intersection theseAeOccurrencesInSequenceDef;
       
          if intersectionEventOccsInSequence /= null then
            // this is a valid event sequence
            isValidEventPair := true;
          end if;
        end if;
       // 
       // 
        previousEventIsValid := isValidEventPair;
        //
        //
      
      end service;
      @endnoparse
    end operation;

    @operation_num(4);
    operation ProcessAuditEventData(aeData: in sequence of auditEventDataStructure) is
      @noparse
      theJob : instance of Job;
      theEventType : instance of AuditEventDefinition;
      theAeOccInSequenceDef : instance of AEOccurrenceInSequenceDefinition;
      aeDataElement : auditEventDataStructure;
      newIntraJobInvariant : instance of TransientInvariant;
      theIntraJobInvariantDefn : instance of IntraJobInvariantDefn;
      theSourceExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;
      theUserExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;
      theSourceExtraJobInvariant : instance of PersistedInvariant;
      theUserExtraJobInvariant : instance of TransientInvariant;
      theDynamicControlDefn : instance of DynamicControlDefinition;
      theDynamicControlDefns : set of instance of DynamicControlDefinition;
      newDynamicControl : instance of DynamicControl;
      theUserDynamicControlDefn : instance of DynamicControlDefinition;
      theCurrentDynamicControlDefn : instance of DynamicControlDefinition;
      theUserDynamicControl : instance of DynamicControl;
      thisJobsDynamicControl : instance of DynamicControl;
      thisJobsDynamicControls : set of instance of DynamicControl;
      theCurrentDynamicControls : set of instance of DynamicControl;
      thePrevUserDynamicControlDefn : instance of DynamicControlDefinition;
      thePrevUserDynamicControl : instance of DynamicControl;
      loopCount : integer;
      branchCount : integer;    
      mergeCount : integer;
      dynamicControlDefinitionFound : boolean;
      logMessage : string;
      creationErrorMessage : string;
      //TODO Remove Debug declaration
      totalDynamicControls : set of instance of DynamicControl;
          
          begin
            // Capture any audit event data associated with this audit event
            theJob := this -> R3;
            theEventType := this -> R2;
            theAeOccInSequenceDef := this -> R13;
            for aeDataElement in aeData loop
              case aeDataElement.aedKind is
                when aeDataKindEnum.INTRAJOBINV =>  
                  // For this Audit Event Occurrence only the following IntraJobInvarinatDefinition is allowed
                  theIntraJobInvariantDefn := theAeOccInSequenceDef -> R19;
                  // Check that the provided invariant name matches the expected invariant name
                  if theIntraJobInvariantDefn /= null then
                    if theIntraJobInvariantDefn.intraJobInvName = aeDataElement.aedName then
                      //Check that the invariant value is not empty
                      if aeDataElement.aedValue /= "" then
                        newIntraJobInvariant := create TransientInvariant (AuditEventId => this.AuditEventId, invariantName => aeDataElement.aedName, invariantValue => aeDataElement.aedValue);
                        link newIntraJobInvariant R23 this;
                        link newIntraJobInvariant R26 theIntraJobInvariantDefn;
                        // Log info: Audit event data provided with this audit event has been captured
      	              logMessage := "The audit event data type " & aeDataElement.aedName & " provided for jobId = " & theJob.jobID & " has been added for this type of audit event = " & theEventType.AEType & " with value = " & newIntraJobInvariant.invariantValue;
      	              Logger::log(Logger::Information, "AESequenceDC", logMessage); 
      	            else
                        theJob.failJob("Empty Invariant Value provided for this Job = " & theJob.jobID & " and Event Type = " & theEventType.AEType);        
      	            end if;                 
                    else
                      // Log warning: The audit event data type provided with this audit event is of a disallowed type for this type of audit event
      	            logMessage := "The audit event data type " & aeDataElement.aedName & " provided for jobId = " & theJob.jobID & " is disallowed for this type of audit event = " & theEventType.AEType;
      	            Logger::log(Logger::Information, "AESequenceDC", logMessage);                
                      theJob.failJob("Invalid audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                    end if;
                  else
                     theJob.failJob("INTRAJOBINV Audit event data sent on an event type is not the expected audit event data - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);               
                  end if;  
                when aeDataKindEnum.EXTRAJOBINV =>  
                  // For this Audit Event Occurrence only the following ExtraJobInvariantDefinition is allowed
                  theSourceExtraJobInvariantDefn := theAeOccInSequenceDef -> R20;
                  theUserExtraJobInvariantDefn := theAeOccInSequenceDef -> R21;
                  if theSourceExtraJobInvariantDefn /= null then
                    // We have the source event that provided a new Extra Job Invariant
                    // Check the name matches
                    if theSourceExtraJobInvariantDefn.extraJobInvName = aeDataElement.aedName then
                      // We have a match between the name in the definition and the name in the audit event data
                      theSourceExtraJobInvariant := PersistedInvariant.createSourceExtraJobInvariant(theSourceExtraJobInvariantDefn,
                     	                                                                               aeDataElement.aedName,
                     	                                                                               aeDataElement.aedValue,
                     	                                                                               creationErrorMessage );               	                                                                            
                     	if theSourceExtraJobInvariant /= null then                                                                            
                        link theSourceExtraJobInvariant R27 this;
                      else
                        theJob.failJob(creationErrorMessage & " for Job: " & theJob.jobID);
                      end if;    
                    else
                      theJob.failJob("Invalid audit event data - the name of the audit event data does not match that expected - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                          
                    end if;
      
                  elsif theUserExtraJobInvariantDefn /= null then
                    // We have a user event that references an existing Extra Job Invariant
                    if theUserExtraJobInvariantDefn.extraJobInvName = aeDataElement.aedName then
                      // We have a match between the name in the definition and the name in the audit event data
                      if aeDataElement.aedValue /= "" then
                        // TODO: Review whether there are any advantages of checking that the invariant value matches that specified by the source AT THIS POINT 
                        // (noting that it is already checked when the job is deemed to have completed in the state 'AssessingInvariants').
                        theUserExtraJobInvariant := create TransientInvariant (AuditEventId => this.AuditEventId, invariantName => aeDataElement.aedName, invariantValue => aeDataElement.aedValue);
                        link theUserExtraJobInvariant R23 this;
                        link theUserExtraJobInvariant R28 theUserExtraJobInvariantDefn;
                        // Log info: Audit event data provided with this audit event has been captured
      	              logMessage := "The audit event data type " & aeDataElement.aedName & " provided for jobId = " & theJob.jobID & " has been added for this type of audit event = " & theEventType.AEType;
      	              Logger::log(Logger::Information, "AESequenceDC", logMessage); 
      	            else
                        theJob.failJob("Empty Invariant Value provided for this Job = " & theJob.jobID & " and Event Type = " & theEventType.AEType);        
      	            end if; 
      	          else                  
                      // This Invariant not expected to be provided on this audit event
                      theJob.failJob("Extra Job Invariant: " & aeDataElement.aedName & " not expected on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                    end if;
                  
                  else
                    // The definition does not match the audit event data seen so this is an error condition
                    theJob.failJob("EXTRAJOBINV Audit event data sent on the event type is not the expected audit event data - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);               
                      
                  end if;
                  
                  when aeDataKindEnum.LOOPCOUNT =>  
                    // For this Audit Event Occurrence only the following DynamicControlDefinition is allowed
                    theDynamicControlDefns := theAeOccInSequenceDef -> R30;
                    // Initialise exit condition for for loop
                    dynamicControlDefinitionFound := false;
                    // Now check to see if the name of the dynamic control element matches one of the dynamic control definitions
                    for theDynamicControlDefn in theDynamicControlDefns loop 
                      if theDynamicControlDefn.dynamicControlName = aeDataElement.aedName and theDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.LOOPCOUNT then
                        //A matching dynamic control definition has been identified.
                        dynamicControlDefinitionFound := true;
                        //Check that the loop count value is not empty
                        if aeDataElement.aedValue /= "" then
                          // Convert the provided string value to an integer (a non-integer input value causes the Program Error exception caught below)
                          loopCount := integer'parse(aeDataElement.aedValue);
                          newDynamicControl := create unique DynamicControl (expectedDynamicControlValue => loopCount, isUser => false);
                          link newDynamicControl R29 theDynamicControlDefn;
                          link newDynamicControl R35 theJob;
                          link newDynamicControl R37 this;
                          
                        else
                          // No Loop Count value provided
                          theJob.failJob("No valid loop count value provided on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                        end if;
                        exit when dynamicControlDefinitionFound = true;
                      else
                        // The data element name did not match the name of theDynamicControlDefn, try the next allowable one
                      end if;
                    end loop;
                    if dynamicControlDefinitionFound = false then    
                      // This Loop Count not expected to be provided on this audit event
                      theJob.failJob("Loop count not expected on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                    end if;
                   
                  when aeDataKindEnum.BRANCHCOUNT =>  
                    // For this Audit Event Occurrence only the following DynamicControlDefinition is allowed
                    theDynamicControlDefns := theAeOccInSequenceDef -> R30;
                    // Initialise exit condition for for loop
                    dynamicControlDefinitionFound := false;
                    // Now check to see if the name of the dynamic control element matches one of the dynamic control definitions
                    for theDynamicControlDefn in theDynamicControlDefns loop 
                      if theDynamicControlDefn.dynamicControlName = aeDataElement.aedName and theDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.BRANCHCOUNT then
                        //A matching dynamic control definition has been identified and its of the right type.
                        dynamicControlDefinitionFound := true;
                        //Check that the branch count value is not empty
                        if aeDataElement.aedValue /= "" then
                          // Convert the provided string value to an integer (a non-integer input value causes the Program Error exception caught below)
                          branchCount := integer'parse(aeDataElement.aedValue);
                          newDynamicControl := create unique DynamicControl (expectedDynamicControlValue => branchCount, isUser => false);
                          link newDynamicControl R29 theDynamicControlDefn;
                          link newDynamicControl R35 theJob;
                          link newDynamicControl R37 this;
      
                        else
                          // No Branch Count value provided
                          theJob.failJob("No valid branch count value provided on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                        end if;
                        exit when dynamicControlDefinitionFound = true;
                      else
                       // The data element name did not match the name of theDynamicControlDefn, try the next allowable one
                      end if;
                    end loop;  
                    if dynamicControlDefinitionFound = false then    
                      // This Branch Count not expected to be provided on this audit event
                      theJob.failJob("Branch count not expected on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                    end if;
                     
                  when aeDataKindEnum.MERGECOUNT =>  
                    // For this Audit Event Occurrence only the following DynamicControlDefinition is allowed
                    theDynamicControlDefns := theAeOccInSequenceDef -> R30;
                    // Initialise exit condition for for loop
                    dynamicControlDefinitionFound := false;
                    // Now check to see if the name of the dynamic control element matches one of the dynamic control definitions
                    for theDynamicControlDefn in theDynamicControlDefns loop 
                      if theDynamicControlDefn.dynamicControlName = aeDataElement.aedName and theDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.MERGECOUNT then
                        //A matching dynamic control definition has been identified and its of the right type.
                        dynamicControlDefinitionFound := true;
                        //Check that the merge count value is not empty
                        if aeDataElement.aedValue /= "" then
                          // Convert the provided string value to an integer (a non-integer input value causes the Program Error exception caught below)
                          mergeCount := integer'parse(aeDataElement.aedValue);
                          newDynamicControl := create unique DynamicControl (expectedDynamicControlValue => mergeCount, isUser => false);
                          link newDynamicControl R29 theDynamicControlDefn;
                          link newDynamicControl R35 theJob;
                          link newDynamicControl R37 this;
      
                        else
                          // No Merge Count value provided
                          theJob.failJob("No valid merge count value provided on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                        end if;
                        exit when dynamicControlDefinitionFound = true;
                      else
                       // The data element name did not match the name of theDynamicControlDefn, try the next allowable one
                      end if;
                    end loop;  
                    if dynamicControlDefinitionFound = false then    
                      // This Merge Count not expected to be provided on this audit event
                      theJob.failJob("Merge count not expected on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                    end if;
      
                when others =>
                  // Log warning: Unsupported audit event data type
                  theJob.failJob("The audit event data type provided for jobId = " & theJob.jobID & " is an unsupported type of audit event data = " & aeDataElement.aedName'image);               
              end case;  
            end loop;
            
            exception
              when program_error =>
                theJob.failJob("Program Error in AuditEvent.ProcessAuditEventData for " & theJob.jobID & " possibly caused by a non-integer loop or branch count in the audit event data : " & aeDataElement.aedValue);               
                      
            end service;
      //
      //
      @endnoparse
    end operation;

  end class;

end;
