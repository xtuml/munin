//! ACTIVITY BEGIN. '1c910ac3-72cf-4b5c-9022-936017cad0c7' DO NOT EDIT THIS LINE.
public service AESequenceDC::AuditEvent.AddEventForNewJob ( jobId : in string,
                                                           eventId : in string,
                                                           prevAEIds : in sequence of string,
                                                           aeType : in string,
                                                           aeData : in sequence of auditEventDataStructure ) is
newJob :  instance of Job;
newEvent : instance of AuditEvent;
oldEvent : instance of AuditEvent;
newEventType : instance of AuditEventDefinition;
prevEvent : instance of AuditEvent;
theAeSequenceDef : instance of AESequenceDefinition;
theAeInSequenceDef : instance of AEInSequenceDefinition;
theAeOccInSequenceDef : instance of AEOccurrenceInSequenceDefinition;
theAeOccurrencesInSequenceDef : set of instance of AEOccurrenceInSequenceDefinition;
theJobDef : instance of JobDefinition;
newSequence : instance of Sequence;
logMessage : string;
creationErrorMessage : string;
eventDataCheckHasPassed : boolean;
failureReason : string;
eventContent : string;
empty : sequence of string;
emptyString : sequence of string := empty & ("");

begin
  oldEvent := find_one AuditEvent (AuditEventId = eventId);
  // Check to see if we've seen this event instance before
  if (oldEvent = null) then
    //We have a new job and this event must be a valid initial event for a Job
    newJob := create Job (jobID => jobId, sequencingFailed => false, jobCompleted => false, Current_State => JobInProgress );
    newEvent := create AuditEvent (AuditEventId => eventId);
  
    link newJob R3 newEvent;
    newEventType := find_only AuditEventDefinition (AEType = aeType);
    if (newEventType /= null) and ((prevAEIds = empty) or (prevAEIds = emptyString)) then
  	  //We have a valid event type and no previous events
  	  // So check that it is also the first event of a sequence in that Job
      link newEvent R2 newEventType;
      theAeSequenceDef := newEventType -> R1.AESequenceDefinition;
      theJobDef := theAeSequenceDef -> R7;
      theAeInSequenceDef := theAeSequenceDef with newEventType -> R1.AEInSequenceDefinition;
      theAeOccurrencesInSequenceDef := theAeInSequenceDef -> R12;
      //TODO should the following be a find and then check there is only one since more than one would be a definition error
      theAeOccInSequenceDef := find_one theAeOccurrencesInSequenceDef (isSequenceStart = true);
      if theAeOccInSequenceDef /= null then
        link newEvent R13 theAeOccInSequenceDef;
        newSequence := create unique Sequence(isComplete => theAeOccInSequenceDef.isSequenceEnd, branchExtent => 1);
        link newSequence R10 newJob;
        link newSequence R11 newEvent;
        link newSequence R14 theAeSequenceDef;
   
        link newJob R8 theJobDef;
        //The the first event for this new Job is a valid event type for starting the sequence
        // Log info: new Job and event sequence started
        logMessage := "AESequenceDC::AuditEvent.AddEventForNewJob : New Job started - jobId = " & newJob.jobID & ", Initial audit event: " & eventId & " of type " & newEventType.AEType;
	    Logger::log(Logger::Debug, "AESequenceDC", logMessage);
		eventContent := "JobId = " & newJob.jobID & " : EventId = " & eventId & " : EventType = " & newEventType.AEType;
		Reporting~>reportEvent(Logger::Information, "svdc_new_job_started", eventContent);
     
        // Process the audit event data for this new event      
        newEvent.ProcessAuditEventData (aeData);
      
        // ...and then check that the received audit event data matches that which is expected
        newEvent.CheckEventCarriesExpectedEventData (eventDataCheckHasPassed, failureReason); 
        if eventDataCheckHasPassed /= true then
          newJob.failJob(failureReason);
        end if;
        
      else
        newJob.failJob("Invalid audit event definition for a start event in job definition = " & theJobDef.jobName & " since the occurrenceNumberInSequence is expected to be 1");    
      end if;  
    else
      //We have an unrecognised event type
      // Log error: unrecognised event type received
      newJob.sequencingFailed := true;
      newJob.failJob("An unrecognised event type has been received - Job Id = " & newJob.jobID & " Event Type = " & newEventType.AEType);
    
    end if;
  else
      // Log error: The audit event id received has been seen before
	  logMessage := "AESequenceDC::AuditEvent.AddEventForNewJob : The audit event has been seen before for jobId = " & jobId & ", Initial audit event = " & aeType;
	  Logger::log(Logger::Debug, "AESequenceDC", logMessage);
	  eventContent := "JobId = " & " : FailureReason = The audit event has been seen before" & jobId & " : EventId = " & eventId & " : EventType = " & aeType;
	  Reporting~>reportEvent(Logger::Error, "svdc_job_failed", eventContent);
   
  end if;  
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '26822f33-6a72-4785-a400-7c11e5d71d99' DO NOT EDIT THIS LINE.
public instance service AESequenceDC::AuditEvent.AddEventTBD () is
newJob :  instance of Job;
newEvent : instance of AuditEvent;
newEventType : instance of AuditEventDefinition;
prevEvent : instance of AuditEvent;

begin
  null;
  //
  //
  //
  //
  //
  //
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'f6c7376e-a155-480d-8007-f3c3ebc441aa' DO NOT EDIT THIS LINE.
public instance service AESequenceDC::AuditEvent.TestPreviousEventIsValid ( prevEventInstance : in instance of AuditEvent,
                                                                           previousEventIsValid : out boolean ) is
//The Audit Event instance on which this operation is invoked is newEvent
// The input parameter is prevEventInstance

//prevEventInstance : instance of AuditEvent;
theAuditEventDefinition : instance of AuditEventDefinition;
prevAuditEventDefinition : instance of AuditEventDefinition;
thisEventInSequence : instance of AEInSequenceDefinition;
prevEventOccInSequence : instance of AEOccurrenceInSequenceDefinition;
intersectionEventOccsInSequence : set of instance of AEOccurrenceInSequenceDefinition;
intersectionEventOccInSequence : instance of AEOccurrenceInSequenceDefinition;
thisAeOccInSequenceDef : instance of AEOccurrenceInSequenceDefinition;
theseAeOccurrencesInSequenceDef : set of instance of AEOccurrenceInSequenceDefinition;
possibleAeOccurrencesInSequenceDef : set of instance of AEOccurrenceInSequenceDefinition;
theSequenceDef : instance of AESequenceDefinition;
theJob : instance of Job;
isValidEventPair : boolean := false;

begin
  theJob := this -> R3;
 
  theAuditEventDefinition := this -> R2;
  prevEventOccInSequence := prevEventInstance -> R13;
  
  if prevEventOccInSequence.isSequenceEnd = false then
    theSequenceDef := theAuditEventDefinition -> R1.AESequenceDefinition;
    thisEventInSequence := theAuditEventDefinition with theSequenceDef -> R1.AEInSequenceDefinition;
    theseAeOccurrencesInSequenceDef := thisEventInSequence -> R12;
    possibleAeOccurrencesInSequenceDef := prevEventOccInSequence -> R6.precedes.AEOccurrenceInSequenceDefinition;
    intersectionEventOccsInSequence := possibleAeOccurrencesInSequenceDef intersection theseAeOccurrencesInSequenceDef;
 
    if intersectionEventOccsInSequence /= null then
      // this is a valid event sequence
      isValidEventPair := true;
    end if;
  end if;
 // 
 // 
  previousEventIsValid := isValidEventPair;
  //
  //

end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'c6026915-9e48-40be-868c-610fa28ecd6a' DO NOT EDIT THIS LINE.
public instance service AESequenceDC::AuditEvent.ProcessAuditEventData ( aeData : in sequence of auditEventDataStructure ) is
theJob : instance of Job;
theEventType : instance of AuditEventDefinition;
theAeOccInSequenceDef : instance of AEOccurrenceInSequenceDefinition;
aeDataElement : auditEventDataStructure;
newIntraJobInvariant : instance of TransientInvariant;
theIntraJobInvariantDefn : instance of IntraJobInvariantDefn;
theSourceExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;
theUserExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;
theSourceExtraJobInvariant : instance of PersistedInvariant;
theUserExtraJobInvariant : instance of TransientInvariant;
theDynamicControlDefn : instance of DynamicControlDefinition;
theDynamicControlDefns : set of instance of DynamicControlDefinition;
newDynamicControl : instance of DynamicControl;
theUserDynamicControlDefn : instance of DynamicControlDefinition;
theCurrentDynamicControlDefn : instance of DynamicControlDefinition;
theUserDynamicControl : instance of DynamicControl;
thisJobsDynamicControl : instance of DynamicControl;
thisJobsDynamicControls : set of instance of DynamicControl;
theCurrentDynamicControls : set of instance of DynamicControl;
thePrevUserDynamicControlDefn : instance of DynamicControlDefinition;
thePrevUserDynamicControl : instance of DynamicControl;
loopCount : integer;
branchCount : integer;    
mergeCount : integer;
dynamicControlDefinitionFound : boolean;
logMessage : string;
creationErrorMessage : string;
//TODO Remove Debug declaration
totalDynamicControls : set of instance of DynamicControl;
    
    begin
      // Capture any audit event data associated with this audit event
      theJob := this -> R3;
      theEventType := this -> R2;
      theAeOccInSequenceDef := this -> R13;
      for aeDataElement in aeData loop
        case aeDataElement.aedKind is
          when aeDataKindEnum.INTRAJOBINV =>  
            // For this Audit Event Occurrence only the following IntraJobInvarinatDefinition is allowed
            theIntraJobInvariantDefn := theAeOccInSequenceDef -> R19;
            // Check that the provided invariant name matches the expected invariant name
            if theIntraJobInvariantDefn /= null then
              if theIntraJobInvariantDefn.intraJobInvName = aeDataElement.aedName then
                //Check that the invariant value is not empty
                if aeDataElement.aedValue /= "" then
                  newIntraJobInvariant := create TransientInvariant (AuditEventId => this.AuditEventId, invariantName => aeDataElement.aedName, invariantValue => aeDataElement.aedValue);
                  link newIntraJobInvariant R23 this;
                  link newIntraJobInvariant R26 theIntraJobInvariantDefn;
                  // Log info: Audit event data provided with this audit event has been captured
	              logMessage := "AESequenceDC::AuditEvent.AddEventForNewJob : ProcessAuditEventData " & aeDataElement.aedName & " provided for jobId = " & theJob.jobID & " has been added for this type of audit event = " & theEventType.AEType & " with value = " & newIntraJobInvariant.invariantValue;
	              Logger::log(Logger::Debug, "AESequenceDC", logMessage); 
	            else
                  theJob.failJob("Empty Invariant Value provided for this Job = " & theJob.jobID & " and Event Type = " & theEventType.AEType);        
	            end if;                 
              else
                // Log warning: The audit event data type provided with this audit event is of a disallowed type for this type of audit event
	            logMessage := "AESequenceDC::AuditEvent.AddEventForNewJob : The audit event data type " & aeDataElement.aedName & " provided for jobId = " & theJob.jobID & " is disallowed for this type of audit event = " & theEventType.AEType;
	            Logger::log(Logger::Debug, "AESequenceDC", logMessage);                
                theJob.failJob("Invalid audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
              end if;
            else
               theJob.failJob("INTRAJOBINV Audit event data sent on an event type is not the expected audit event data - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);               
            end if;  
          when aeDataKindEnum.EXTRAJOBINV =>  
            // For this Audit Event Occurrence only the following ExtraJobInvariantDefinition is allowed
            theSourceExtraJobInvariantDefn := theAeOccInSequenceDef -> R20;
            theUserExtraJobInvariantDefn := theAeOccInSequenceDef -> R21;
            if theSourceExtraJobInvariantDefn /= null then
              // We have the source event that provided a new Extra Job Invariant
              // Check the name matches
              if theSourceExtraJobInvariantDefn.extraJobInvName = aeDataElement.aedName then
                // We have a match between the name in the definition and the name in the audit event data
                theSourceExtraJobInvariant := PersistedInvariant.createSourceExtraJobInvariant(theSourceExtraJobInvariantDefn,
               	                                                                               aeDataElement.aedName,
               	                                                                               aeDataElement.aedValue,
               	                                                                               creationErrorMessage );               	                                                                            
               	if theSourceExtraJobInvariant /= null then                                                                            
                  link theSourceExtraJobInvariant R27 this;
                else
                  theJob.failJob(creationErrorMessage & " for Job: " & theJob.jobID);
                end if;    
              else
                theJob.failJob("Invalid audit event data - the name of the audit event data does not match that expected - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                    
              end if;

            elsif theUserExtraJobInvariantDefn /= null then
              // We have a user event that references an existing Extra Job Invariant
              if theUserExtraJobInvariantDefn.extraJobInvName = aeDataElement.aedName then
                // We have a match between the name in the definition and the name in the audit event data
                if aeDataElement.aedValue /= "" then
                  // TODO: Review whether there are any advantages of checking that the invariant value matches that specified by the source AT THIS POINT 
                  // (noting that it is already checked when the job is deemed to have completed in the state 'AssessingInvariants').
                  theUserExtraJobInvariant := create TransientInvariant (AuditEventId => this.AuditEventId, invariantName => aeDataElement.aedName, invariantValue => aeDataElement.aedValue);
                  link theUserExtraJobInvariant R23 this;
                  link theUserExtraJobInvariant R28 theUserExtraJobInvariantDefn;
                  // Log info: Audit event data provided with this audit event has been captured
	              logMessage := "AESequenceDC::AuditEvent.AddEventForNewJob : The audit event data type " & aeDataElement.aedName & " provided for jobId = " & theJob.jobID & " has been added for this type of audit event = " & theEventType.AEType;
	              Logger::log(Logger::Debug, "AESequenceDC", logMessage); 
	            else
                  theJob.failJob("Empty Invariant Value provided for this Job = " & theJob.jobID & " and Event Type = " & theEventType.AEType);        
	            end if; 
	          else                  
                // This Invariant not expected to be provided on this audit event
                theJob.failJob("Extra Job Invariant: " & aeDataElement.aedName & " not expected on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
              end if;
            
            else
              // The definition does not match the audit event data seen so this is an error condition
              theJob.failJob("EXTRAJOBINV Audit event data sent on the event type is not the expected audit event data - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);               
                
            end if;
            
            when aeDataKindEnum.LOOPCOUNT =>  
              // For this Audit Event Occurrence only the following DynamicControlDefinition is allowed
              theDynamicControlDefns := theAeOccInSequenceDef -> R30;
              // Initialise exit condition for for loop
              dynamicControlDefinitionFound := false;
              // Now check to see if the name of the dynamic control element matches one of the dynamic control definitions
              for theDynamicControlDefn in theDynamicControlDefns loop 
                if theDynamicControlDefn.dynamicControlName = aeDataElement.aedName and theDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.LOOPCOUNT then
                  //A matching dynamic control definition has been identified.
                  dynamicControlDefinitionFound := true;
                  //Check that the loop count value is not empty
                  if aeDataElement.aedValue /= "" then
                    // Convert the provided string value to an integer (a non-integer input value causes the Program Error exception caught below)
                    loopCount := integer'parse(aeDataElement.aedValue);
                    newDynamicControl := create unique DynamicControl (expectedDynamicControlValue => loopCount, isUser => false);
                    link newDynamicControl R29 theDynamicControlDefn;
                    link newDynamicControl R35 theJob;
                    link newDynamicControl R37 this;
                    
                  else
                    // No Loop Count value provided
                    theJob.failJob("No valid loop count value provided on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                  end if;
                  exit when dynamicControlDefinitionFound = true;
                else
                  // The data element name did not match the name of theDynamicControlDefn, try the next allowable one
                end if;
              end loop;
              if dynamicControlDefinitionFound = false then    
                // This Loop Count not expected to be provided on this audit event
                theJob.failJob("Loop count not expected on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
              end if;
             
            when aeDataKindEnum.BRANCHCOUNT =>  
              // For this Audit Event Occurrence only the following DynamicControlDefinition is allowed
              theDynamicControlDefns := theAeOccInSequenceDef -> R30;
              // Initialise exit condition for for loop
              dynamicControlDefinitionFound := false;
              // Now check to see if the name of the dynamic control element matches one of the dynamic control definitions
              for theDynamicControlDefn in theDynamicControlDefns loop 
                if theDynamicControlDefn.dynamicControlName = aeDataElement.aedName and theDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.BRANCHCOUNT then
                  //A matching dynamic control definition has been identified and its of the right type.
                  dynamicControlDefinitionFound := true;
                  //Check that the branch count value is not empty
                  if aeDataElement.aedValue /= "" then
                    // Convert the provided string value to an integer (a non-integer input value causes the Program Error exception caught below)
                    branchCount := integer'parse(aeDataElement.aedValue);
                    newDynamicControl := create unique DynamicControl (expectedDynamicControlValue => branchCount, isUser => false);
                    link newDynamicControl R29 theDynamicControlDefn;
                    link newDynamicControl R35 theJob;
                    link newDynamicControl R37 this;

                  else
                    // No Branch Count value provided
                    theJob.failJob("No valid branch count value provided on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                  end if;
                  exit when dynamicControlDefinitionFound = true;
                else
                 // The data element name did not match the name of theDynamicControlDefn, try the next allowable one
                end if;
              end loop;  
              if dynamicControlDefinitionFound = false then    
                // This Branch Count not expected to be provided on this audit event
                theJob.failJob("Branch count not expected on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
              end if;
               
            when aeDataKindEnum.MERGECOUNT =>  
              // For this Audit Event Occurrence only the following DynamicControlDefinition is allowed
              theDynamicControlDefns := theAeOccInSequenceDef -> R30;
              // Initialise exit condition for for loop
              dynamicControlDefinitionFound := false;
              // Now check to see if the name of the dynamic control element matches one of the dynamic control definitions
              for theDynamicControlDefn in theDynamicControlDefns loop 
                if theDynamicControlDefn.dynamicControlName = aeDataElement.aedName and theDynamicControlDefn.dynamicControlType = dynamicControlTypeEnum.MERGECOUNT then
                  //A matching dynamic control definition has been identified and its of the right type.
                  dynamicControlDefinitionFound := true;
                  //Check that the merge count value is not empty
                  if aeDataElement.aedValue /= "" then
                    // Convert the provided string value to an integer (a non-integer input value causes the Program Error exception caught below)
                    mergeCount := integer'parse(aeDataElement.aedValue);
                    newDynamicControl := create unique DynamicControl (expectedDynamicControlValue => mergeCount, isUser => false);
                    link newDynamicControl R29 theDynamicControlDefn;
                    link newDynamicControl R35 theJob;
                    link newDynamicControl R37 this;

                  else
                    // No Merge Count value provided
                    theJob.failJob("No valid merge count value provided on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
                  end if;
                  exit when dynamicControlDefinitionFound = true;
                else
                 // The data element name did not match the name of theDynamicControlDefn, try the next allowable one
                end if;
              end loop;  
              if dynamicControlDefinitionFound = false then    
                // This Merge Count not expected to be provided on this audit event
                theJob.failJob("Merge count not expected on this audit event data type for - Job Id = " & theJob.jobID & " and Event Type = " & theEventType.AEType);
              end if;

          when others =>
            // Log warning: Unsupported audit event data type
            theJob.failJob("The audit event data type provided for jobId = " & theJob.jobID & " is an unsupported type of audit event data = " & aeDataElement.aedName'image);               
        end case;  
      end loop;
      
exception
    when program_error =>
      theJob.failJob("Program Error in AuditEvent.ProcessAuditEventData for " & theJob.jobID & " possibly caused by a non-integer loop or branch count in the audit event data : " & aeDataElement.aedValue);               
            
end service;
//
//
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'e261f65f-eac2-47c7-beee-253b667a440a' DO NOT EDIT THIS LINE.
public instance service AESequenceDC::AuditEvent.CheckEventCarriesExpectedEventData ( checkHasPassed : out boolean,
                                                                                     failureReason : out string ) is
theEventOccurrenceInSeqDef : instance of AEOccurrenceInSequenceDefinition;
theExpectedSourceDynamicControlDefs : set of instance of DynamicControlDefinition;
theExpectedUsageDynamicControlDef : instance of DynamicControlDefinition;
theExpectedSourceExtraJobInvariantDef : instance of ExtraJobInvariantDefn;
theExpectedUsageExtraJobInvariantDef : instance of ExtraJobInvariantDefn;
theExpectedCarriedIntraJobInvariantDef : instance of IntraJobInvariantDefn;

theReceivedSourceDynamicControlDefs : set of instance of DynamicControlDefinition;
theReceivedUsageDynamicControlDef : instance of DynamicControlDefinition;
theReceivedProvidedExtraJobInvariantDef : instance of ExtraJobInvariantDefn;
theReceivedCarriedExtraJobInvariantDef : instance of ExtraJobInvariantDefn;
theReceivedCarriedExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;
theReceivedCarriedIntraJobInvariantDef : instance of IntraJobInvariantDefn;
theReceivedCarriedIntraJobInvariantDefn : instance of IntraJobInvariantDefn;
logMessage : string;

begin
  // TODO: Remove the following log message - just for debug
  logMessage := "Checking received event data against definition";
  Logger::log(Logger::Debug, "AESequenceDC", logMessage);
	
  // Initialise return parameters
  checkHasPassed := true;
  failureReason := "";
  
  // Find the definitions for the EXPECTED and RECEIVED DynamicControls, ExtraJobInvariants and IntraJobInvariants associated with this received event.
  theEventOccurrenceInSeqDef := this -> R13;
  
  theExpectedSourceDynamicControlDefs := theEventOccurrenceInSeqDef -> R30;
  theExpectedUsageDynamicControlDef := theEventOccurrenceInSeqDef -> R31;
  theExpectedSourceExtraJobInvariantDef := theEventOccurrenceInSeqDef -> R20;
  theExpectedUsageExtraJobInvariantDef := theEventOccurrenceInSeqDef -> R21;
  theExpectedCarriedIntraJobInvariantDef := theEventOccurrenceInSeqDef -> R19;
  
  theReceivedSourceDynamicControlDefs := this -> R37 -> R29;
  theReceivedUsageDynamicControlDef := this -> R36 -> R29;
  theReceivedProvidedExtraJobInvariantDef := this -> R27 -> R24;
  theReceivedCarriedExtraJobInvariantDefn := this -> R23 -> R28;
  theReceivedCarriedIntraJobInvariantDefn := this -> R23 -> R26;
  
  if theExpectedSourceDynamicControlDefs /= theReceivedSourceDynamicControlDefs then
    checkHasPassed := false;
    failureReason := "The dynamic controls provided as sources on received on event: " & this.AuditEventId & " do not match what was expected in the definition";
  elsif theExpectedUsageDynamicControlDef /= theReceivedUsageDynamicControlDef then
    checkHasPassed := false;
    failureReason := "The dynamic control usage received on event: " & this.AuditEventId & " does not match what was expected in the definition";
  elsif theExpectedSourceExtraJobInvariantDef /= theReceivedProvidedExtraJobInvariantDef then
    checkHasPassed := false;
    failureReason := "The PROVIDED extra job invariant expected on received event: " & this.AuditEventId & " does not match what was expected in the definition";
  elsif theExpectedUsageExtraJobInvariantDef /= theReceivedCarriedExtraJobInvariantDefn then
    checkHasPassed := false;
    failureReason := "The CARRIED extra-job invariant expected on received event: " & this.AuditEventId & " does not match what was expected in the definition";
  elsif theExpectedCarriedIntraJobInvariantDef /= theReceivedCarriedIntraJobInvariantDefn then
    checkHasPassed := false;
    failureReason := "The CARRIED intra-job invariant expected on received event: " & this.AuditEventId & " does not match what was expected in the definition";
  end if;
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

