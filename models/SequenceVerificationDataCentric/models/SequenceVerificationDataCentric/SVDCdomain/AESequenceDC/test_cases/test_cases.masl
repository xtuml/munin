//! ACTIVITY BEGIN. '78e86022-548d-4323-94da-df1473308e24' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test01NormalPath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
  // This test does not reveal any erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
//
  Test::service_event_queue();
//
  // Auth Job with single sequence but repeating event types
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '80a14a8d-1229-460b-a58b-b1c4c6fbe7ce' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test02NormalPath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers one Job with the same 3 sequences as NormalPathTest01 but with the sequences in the opposite order.
  // This test does not reveal any erroneous behaviour of the twin
  //
  // Far Side Sequence
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
  // Mid Sequence
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  //
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theJob := theJobs'any;
  theSequences := theJob -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 3, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 17, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete");
  Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed");
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'dd9dcddc-3b36-4eec-a822-c2e6e2c047ab' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test03NormalPath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers one Job with 3 sequences and the events for a given sequence are in the correct order
  // but the events of different sequences are interleaved
  // This test does not reveal any erroneous behaviour of the twin
  //
  // Bank Transfer Sequence starts here
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  // Far side Sequence starts here
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  // Mid Sequence starts here
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  // Mid sequence ends here
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  // Far side sequence ends here
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  // This next event is an end point which occurs before the branch has been seen so is a potential error condition
  // The Job should not complete at this point despite an end point in all 3 sequences being reached
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  // This is the only event on the other branch and in this case it completes the Job
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theJob := theJobs'any;
  theSequences := theJob -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 3, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 17, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete");
  Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed");
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '7e6740eb-8323-4bba-9687-5f0a96c11398' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test04NormalCyclicPath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Jobs with 1 sequences based on a looped path definition - no iterations of the loop
  // This test does not reveal any erroneous behaviour of the twin
  //
  acceptOrderedEvent ("1620920000","A","Job_Cyclo","","Ev301",theAuditEventData);
  acceptOrderedEvent ("1620920001","B","Job_Cyclo","Ev301","Ev302",theAuditEventData);
  acceptOrderedEvent ("1620920002","C","Job_Cyclo","Ev302","Ev303",theAuditEventData);
  acceptOrderedEvent ("1620920003","D","Job_Cyclo","Ev303","Ev304",theAuditEventData);
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 4, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '59964547-3d86-48fa-8e0d-6d472e2c8731' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test05NormalCyclicPath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Jobs with 1 sequences based on a looped path definition - 1 iteration of the loop
  // This test does not reveal any erroneous behaviour of the twin
  //
  acceptOrderedEvent ("1620920000","A","Job_Cyclo","","Ev301",theAuditEventData);
  acceptOrderedEvent ("1620920001","B","Job_Cyclo","Ev301","Ev302",theAuditEventData);
  acceptOrderedEvent ("1620920002","C","Job_Cyclo","Ev302","Ev303",theAuditEventData);
  acceptOrderedEvent ("1620920003","B","Job_Cyclo","Ev303","Ev304",theAuditEventData);
  acceptOrderedEvent ("1620920004","C","Job_Cyclo","Ev304","Ev305",theAuditEventData);
  acceptOrderedEvent ("1620920005","D","Job_Cyclo","Ev305","Ev306",theAuditEventData);
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 6, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'f39a4d9a-5fee-4e24-a57d-bf515180c30f' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test06NormalCyclicPath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Jobs with 1 sequences based on a looped path definition - 2 iterations of the loop
  // This test does not reveal any erroneous behaviour of the twin
  //
  acceptOrderedEvent ("1620920000","A","Job_Cyclo","","Ev301",theAuditEventData);
  acceptOrderedEvent ("1620920001","B","Job_Cyclo","Ev301","Ev302",theAuditEventData);
  acceptOrderedEvent ("1620920002","C","Job_Cyclo","Ev302","Ev303",theAuditEventData);
  acceptOrderedEvent ("1620920003","B","Job_Cyclo","Ev303","Ev304",theAuditEventData);
  acceptOrderedEvent ("1620920004","C","Job_Cyclo","Ev304","Ev305",theAuditEventData);
  acceptOrderedEvent ("1620920005","B","Job_Cyclo","Ev305","Ev306",theAuditEventData);
  acceptOrderedEvent ("1620920006","C","Job_Cyclo","Ev306","Ev307",theAuditEventData);
  acceptOrderedEvent ("1620920007","D","Job_Cyclo","Ev307","Ev308",theAuditEventData);

  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 8, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'faabbad6-ac40-47a0-892b-ae272aa59ca4' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test07NormalCyclicPath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Jobs with 1 sequences based on a looped path definition - 7 iterations of the loop
  // This test does not reveal any erroneous behaviour of the twin
  //
  acceptOrderedEvent ("1620920000","A","Job_Cyclo","","Ev301",theAuditEventData);
  acceptOrderedEvent ("1620920001","B","Job_Cyclo","Ev301","Ev302",theAuditEventData);
  acceptOrderedEvent ("1620920002","C","Job_Cyclo","Ev302","Ev303",theAuditEventData);
  acceptOrderedEvent ("1620920003","B","Job_Cyclo","Ev303","Ev304",theAuditEventData);
  acceptOrderedEvent ("1620920004","C","Job_Cyclo","Ev304","Ev305",theAuditEventData);
  acceptOrderedEvent ("1620920005","B","Job_Cyclo","Ev305","Ev306",theAuditEventData);
  acceptOrderedEvent ("1620920006","C","Job_Cyclo","Ev306","Ev307",theAuditEventData);
  acceptOrderedEvent ("1620920007","B","Job_Cyclo","Ev307","Ev308",theAuditEventData);
  acceptOrderedEvent ("1620920008","C","Job_Cyclo","Ev308","Ev309",theAuditEventData);
  acceptOrderedEvent ("1620920009","B","Job_Cyclo","Ev309","Ev310",theAuditEventData);
  acceptOrderedEvent ("1620920010","C","Job_Cyclo","Ev310","Ev311",theAuditEventData);
  acceptOrderedEvent ("1620920011","B","Job_Cyclo","Ev311","Ev312",theAuditEventData);
  acceptOrderedEvent ("1620920012","C","Job_Cyclo","Ev312","Ev313",theAuditEventData);
  acceptOrderedEvent ("1620920013","B","Job_Cyclo","Ev313","Ev314",theAuditEventData);
  acceptOrderedEvent ("1620920014","C","Job_Cyclo","Ev314","Ev315",theAuditEventData);
  acceptOrderedEvent ("1620920015","B","Job_Cyclo","Ev315","Ev316",theAuditEventData);
  acceptOrderedEvent ("1620920016","C","Job_Cyclo","Ev316","Ev317",theAuditEventData);
  acceptOrderedEvent ("1620920017","D","Job_Cyclo","Ev317","Ev318",theAuditEventData);

  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 18, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '56d65193-f2ca-46f0-a80d-0cd05cb5d1dc' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test31ErrorDetection () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 3 sequences with one event out of sequence
  // This test reveals any erroneous behaviour of the twin
  //
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  // The following event type is in the wrong place in the sequence and so should cause the Job to fail
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserReadWidgetRequest","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
//
//
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
//  theSequences := theJobs -> R10;
//  theAuditEvents := theSequences -> R11;
  
  //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed, "Sequencing hasn't failed and it should have: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '77c1b97b-927a-444c-830b-dd5b337fdeca' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test32ErrorDetection () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 3 sequences with one undefined event type
  // This test reveals any erroneous behaviour of the twin
  //
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  // The following event contains an unknown event type and so should causer the Job to fail
  acceptOrderedEvent ("1620920005","ErroneousEventType","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
//
//
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if;
  theJobs := find Job ();
//  theSequences := theJobs -> R10;
//  theAuditEvents := theSequences -> R11;
  
  //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed, "Sequencing hasn't failed and it should have: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '29afb05b-8b9e-4967-972a-c6082af0eb9d' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test33ErrorDetection () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 3 sequences with one unseen previous event
  // This test reveals any erroneous behaviour of the twin
  //
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  // The following event has a previous event that has not been seen before - this should cause the Job to fail
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","EvXX","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
//
//
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if;
  theJobs := find Job ();
//  theSequences := theJobs -> R10;
//  theAuditEvents := theSequences -> R11;
  
  //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed, "Sequencing hasn't failed and it should have: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '1ac78321-21be-4ac9-a66e-9755004562d5' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test08NormalPath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 2 Jobs with 4 sequences and the BankTransfer Sequence occurs last in the first Job with
  // the AgentProcessedRequest event (an end event) occurring before any event on the other side of the fork
  // is seen. This will test that the job is not prematurely marked as complete.
  // This test does not reveal any erroneous behaviour of the twin
  //
  // Normal Mid sequence starts here
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Normal Far Side sequence starts here
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
  // Near side sequence starts here
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  // The following event is an end point event which occurs here before the branch is obvious
  // This tests the system does not prematurely indicate Job Complete
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  //...and then back to the events in the 'main' branch in the sequence.
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);

  // Process all the events on the event queue
  Test::service_event_queue();
  
  // Fire the timer that waits for optional branch events on Job_Alpha to start - no branch expected in this test
  theJob := find_only Job(jobID = "Job_Alpha");
  Test::fire_timer(theJob.jobEventTimer);
 
  // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
  // the jobEventTimer for Job_Alpha being fired.
  Test::service_event_queue();
  
  
  // This is a separate Auth Job not fundamental to the test
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
  
  // Process all the events on the event queue
  Test::service_event_queue();
  
  // Fire the timer that waits for optional branch events on Job_Gamma to start - no branch expected in this test
  theJob := find_only Job(jobID = "Job_Gamma");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
  // the jobEventTimer for Job_Gamma being fired. 
  Test::service_event_queue();
  
  // Check that the 2 jobs are as expected.
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  
  Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = true, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;
  
  // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
  theJobs := find Job();
  for theJob in theJobs loop
    Test::fire_timer(theJob.jobDeletionTimer);
  end loop;
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '6b24305e-e6c8-4333-929b-df903c470e58' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test34ErrorDetection () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Jobs with 3 sequences. However, the Mid sequence has a start event that contains a 
  // previous EventId (which is invalid for start events).
  // This test reveals any behaviour of the twin
  //
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  // The following event is a sequence start event but erroneously it has a valid previous event id 
  // This should cause the job to fail
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","Ev12","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);

  // Process all the events on the event queue - Job_Alpha should be in the 'JobFailed' state after this.
  Test::service_event_queue();
  
 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);

  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed, "Sequencing hasn't failed and it should have: " & theJob.jobID);
  end loop;
  
  // Fire the jobDeletionTimer for Job_Alpha - this will result in it being deleted.
  theJob := find_only Job(jobID = "Job_Alpha");
  Test::fire_timer(theJob.jobDeletionTimer);
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //   
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '77a44eb8-642e-422b-84e3-a856897b0aa2' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test35ErrorDetection () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Jobs with 3 sequences and all events are in the standard default order
  // but one event has an event id the same as a previous event and this is an error condition
  // This test does reveal erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  // The following event has the same event id (last parameter) as an earlier event - this should cause the Job to fail
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
//
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if;
//
  theJobs := find Job ();
//  theSequences := theJobs -> R10;
//  theAuditEvents := theSequences -> R11;
  
  //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed, "Sequencing hasn't failed and it should have: " & theJob.jobID);
  end loop;  

end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '980aaf9a-b5db-4d42-b7b7-70acf09ca267' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test09CorrectDeletionOfDefinitions () is
theJobDef : instance of JobDefinition;
theJobDefs : set of instance of JobDefinition;
theSeqDefs : set of instance of AESequenceDefinition;
theAEDefs : set of instance of SequencedAuditEventDefinition;
theAEInSeqDefs : set of instance of AEInSequenceDefinition;
theAEOccInSeqDefs : set of instance of AEOccurrenceInSequenceDefinition;
theAEOccPairDefs : set of instance of AEInSequencePairDefn;

begin
  // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
  // This test does not reveal any erroneous behaviour of the twin
  //
  theJobDefs := find JobDefinition();
  for theJobDef in theJobDefs loop
    deprecateJobDefinition(theJobDef.jobName);
  end loop;  
  //
  Test::service_event_queue();
  
  //Fire the timers to ensure that all the deprecated JoBDefinitions delete themselves
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if;
  
  Test::service_event_queue();
   
  theJobDefs := find JobDefinition();
  theSeqDefs := find AESequenceDefinition();
  theAEDefs := find SequencedAuditEventDefinition();
  theAEInSeqDefs := find AEInSequenceDefinition();
  theAEOccInSeqDefs := find AEOccurrenceInSequenceDefinition();
  theAEOccPairDefs := find AEInSequencePairDefn();
  
  Assertions::assertTrue(theJobDefs'length = 0, "Some Job Definitions remaining: " & (theJobDefs'length)'image);
  Assertions::assertTrue(theSeqDefs'length = 0, "Some Sequence Definitions remaining: " & (theSeqDefs'length)'image);
  Assertions::assertTrue(theAEDefs'length = 0, "Some Audit Event Definitions remaining: " & (theAEDefs'length)'image);
  Assertions::assertTrue(theAEInSeqDefs'length = 0, "Some Audit Event in Sequence Definitions remaining: " & (theAEInSeqDefs'length)'image);
  Assertions::assertTrue(theAEOccInSeqDefs'length = 0, "Some Audit Event Occurrences in Sequence Definitions remaining: " & (theAEOccInSeqDefs'length)'image);
  Assertions::assertTrue(theAEOccPairDefs'length = 0, "Some Audit Event in Sequence Pair Definitions remaining: " & (theAEOccPairDefs'length)'image);
//  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '64853fad-ab21-479c-9f6d-bae93065755a' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test10NormalPath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
  // The JobComplete interaction from AEOrdering is received as expected after event processing has finished
  // This test does not reveal any erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);

  // Process all the events on the event queue
  Test::service_event_queue();
  
  // Job_Alpha should be in the 'AssessingSequenceCompletion' state at this point in the test so fire the timer that is waiting for 
  // late arrival of optional branch events on Job_Alpha to arrive - no further optional branches are expected in this test.
  theJob := find_only Job(jobID = "Job_Alpha");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
  // the jobEventTimer for Job_Alpha being fired - note that Job_Alpha should be in the 'JobSuccessful' after this.
  Test::service_event_queue();
  
  // Invoke interaction from AEOrdering called jobComplete which is interpreted as Job Timeout in this domain
  jobComplete ("Job_Alpha");
   
  // Service the event queue to process the 'jobTimeOut' event directed at Job_Alpha - this event will be ignored.
  Test::service_event_queue();
 
 
  // Auth Job with single sequence but repeating event types
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
    
  // Process all the events on the event queue
  Test::service_event_queue();
  
  // Job_Gamma should be in the 'AssessingSequenceCompletion' state at this point in the test so fire the timer that is waiting for 
  // late arrival of optional branch events on Job_Gamma to arrive - no further optional branches are expected in this test.
  theJob := find_only Job(jobID = "Job_Gamma");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
  // the jobEventTimer for Job_Gamma being fired - note that Job_Gamma should be in the 'JobSuccessful' after this.
  Test::service_event_queue();
  
  // Invoke interaction from AEOrdering called JobComplete which is interpreted as Job Timeout in this domain
  jobComplete ("Job_Gamma");
  
  // Service the event queue to process the 'jobTimeOut' event directed at Job_Gamma this event will be ignored.
  Test::service_event_queue();
  
  // Check that the jobs (Job_Alpha & Job_Gamma) and their associated sequences and events are in an expected state. 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;
  
  // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
  theJobs := find Job();
  for theJob in theJobs loop
    Test::fire_timer(theJob.jobDeletionTimer);
  end loop;
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'bec7499a-88ba-404e-8e76-fc44c3dce27d' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test11NormalPath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 2 Jobs with 4 sequences and the BankTransfer Sequence occurs last in the first Job with
  // the AgentProcessedRequest event (an end event) occurring before any event on the other side of the fork
  // is seen. This will test that the job is not prematurely marked as complete.
  // This test does not reveal any erroneous behaviour of the twin
  //
  // Normal Mid sequence starts here
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Normal Far Side sequence starts here
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
  // Near side sequence starts here
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  // The following event is an end point event which occurs here before the branch is obvious
  // This tests the system does not prematurely indicate Job Complete
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);

  // Process all the events on the event queue
  Test::service_event_queue();
  
  // Job_Alpha should be in the 'AssessingSequenceCompletion' state at this point in the test so fire the timer that is waiting for 
  // late arrival of optional branch events on Job_Alpha to arrive - no further optional branches are expected in this test.
  theJob := find_only Job(jobID = "Job_Alpha");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
  // the jobEventTimer for Job_Alpha being fired - note that Job_Alpha should be in the 'JobSuccessful' after this.
  Test::service_event_queue();
  
  // Invoke interaction from AEOrdering called jobComplete which is interpreted as Job Timeout in this domain
  jobComplete ("Job_Alpha");
   
  // Service the event queue to process the 'jobTimeOut' event directed at Job_Alpha - this event will be ignored.
  Test::service_event_queue();


  // This is a separate Auth Job not fundamental to the test
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
  

  // Process all the events on the event queue
  Test::service_event_queue();
  
  // Job_Gamma should be in the 'AssessingSequenceCompletion' state at this point in the test so fire the timer that is waiting for 
  // late arrival of optional branch events on Job_Gamma to arrive - no further optional branches are expected in this test.
  theJob := find_only Job(jobID = "Job_Gamma");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
  // the jobEventTimer for Job_Gamma being fired - note that Job_Gamma should be in the 'JobSuccessful' after this.
  Test::service_event_queue();
  
  // Invoke interaction from AEOrdering called JobComplete which is interpreted as Job Timeout in this domain
  jobComplete ("Job_Gamma");
  
  // Service the event queue to process the 'jobTimeOut' event directed at Job_Gamma this event will be ignored.
  Test::service_event_queue(); 
  
  // Check that both jobs (Job_Alpha & Job_Gamma) and their associated sequences and events are in an expected state. 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  
  Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;
  
  // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
  theJobs := find Job();
  for theJob in theJobs loop
    Test::fire_timer(theJob.jobDeletionTimer);
  end loop;
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '7ea44b46-f490-40d4-9dc1-d5cd69340148' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test36ErrorDetection () is
theJobs : set of instance of Job;
theGJob : instance of Job;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
  // The JobComplete interaction from AEOrdering is received earlier than expected before all events have been processed
  // This test does reveal erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  // Job complete being injected here is an error condition because this should not occur until all events for a Job have been received
  // Invoke interaction from AEOrdering called JobComplete which is interpreted as Job Timeout in this domain
  // This will push the job into the job timed out state and report failure and start the job deletion timer
  jobComplete ("Job_Alpha");
//
//  
  Test::service_event_queue();
//
  // Auth Job with single sequence but repeating event types
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if;
  // Firing scheduled timers above will delete Job_Alpha
  // Invoke interaction from AEOrdering called JobComplete which is interpreted as Job Timeout in this domain
  jobComplete ("Job_Gamma");
  //
  Test::service_event_queue();
  
  theJobs := find Job ();
  theGJob := find_one Job (jobID = "Job_Gamma");
//  theSequences := theJobs -> R10;
//  theAuditEvents := theSequences -> R11;
  
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs remain: " & (theJobs'length)'image);
  Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '8f3133f9-1492-4999-8230-96bf1205b331' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test37ErrorDetection () is
theJobs : set of instance of Job;

begin
  // 
  // The JobComplete interaction from AEOrdering is received for an unknown Job
  // This test does reveal erroneous behaviour of the twin
  //
  // Job complete for an unknown Job is an error condition 
  jobComplete ("Job_Unknown");
//
//  
  Test::service_event_queue();
//
  theJobs := find Job (jobID = "Job_Unknown");
//  theSequences := theJobs -> R10;
//  theAuditEvents := theSequences -> R11;
  
  //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  Assertions::assertTrue(theJobs'length = 0, "Jobs reported complete for a Job that doesn't exist ; " & (theJobs'length)'image);
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '7e2ecf11-95d2-4c44-9c58-759d78db8105' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test38AnomalousCondition () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers a very special situation. It injects JobComplete from AEOrdering at the point where one branch
  // of an unconstrained BankTransfer sequence has completed but another possible branch hasn't started. The events for the
  // other branch arrive after JobComplete which would be erroneous behaviour of AEOrdering. The model ignores JobComplete
  // in this specific circumstance because it looks just like a legitimate end of a Job prior to the Job timeout. Compare with Test39.
  // This test does reveals some anomalous behaviour of this system but it is not classed as an error condition.
  //
  // Normal Mid sequence starts here
  acceptOrderedEvent ("1620920012","IOR_MidProcessPayload","IOR_Job_Alpha","","IOR_Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","IOR_MidWritePayload","IOR_Job_Alpha","IOR_Ev13","IOR_Ev14",theAuditEventData);
  // Normal Far Side sequence starts here
  acceptOrderedEvent ("1620920050","IOR_FarInput","IOR_Job_Alpha","","IOR_Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","IOR_FarOutput","IOR_Job_Alpha","IOR_Ev50","IOR_Ev55",theAuditEventData);
  // Near side sequence starts here
  acceptOrderedEvent ("1620920000","IOR_NearInput","IOR_Job_Alpha","","IOR_Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","IOR_NearPartWrite","IOR_Job_Alpha","IOR_Ev1","IOR_Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","IOR_NearJustificationWrite","IOR_Job_Alpha","IOR_Ev2","IOR_Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","IOR_AgentRequestWidgets","IOR_Job_Alpha","IOR_Ev3","IOR_Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","IOR_AuthoriserReadWidgetRequest","IOR_Job_Alpha","IOR_Ev4","IOR_Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","IOR_AuthoriserParsedJustification","IOR_Job_Alpha","IOR_Ev5","IOR_Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","IOR_AuthoriserSendWidgets","IOR_Job_Alpha","IOR_Ev6","IOR_Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","IOR_AgentReceiveWidgets","IOR_Job_Alpha","IOR_Ev7","IOR_Ev8",theAuditEventData);
  // The following event is an end point event which occurs here before the branch is obvious
  // This tests the system does not prematurely indicate Job Complete
  acceptOrderedEvent ("1620920008","IOR_AgentProcessedRequest","IOR_Job_Alpha","IOR_Ev8","IOR_Ev9a",theAuditEventData);

  // Mimic the interaction from AEOrdering called jobComplete which is interpreted as a Job Timeout in this domain.
  // Note that jobComplete being injected here is an error condition because this should not occur until all events for a Job have been received
  jobComplete ("IOR_Job_Alpha");
  
  // Process all the events on the event queue (including the jobTimedOut event). At this point in the test the Job should 
  // have reached the 'AssessingSequenceCompletion' state and so will ignore the jobTimedOut event.
  Test::service_event_queue();
  
  // Fire the timer that waits for alternative branch events on Job_Alpha to start - this mimics the situation where 
  // the events for Job_Alpha that follow (see befar) arrive too late to be processed but the Job proceeds (wrongly) on
  // on basis that all sequences must have been received.
  theJob := find_only Job(jobID = "IOR_Job_Alpha");
  Test::fire_timer(theJob.jobEventTimer);
  
  acceptOrderedEvent ("1620920008","IOR_AgentPartRead","IOR_Job_Alpha","IOR_Ev8","IOR_Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920009","IOR_AgentWritePayload","IOR_Job_Alpha","IOR_Ev9","IOR_Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","IOR_GatewayReadPayload","IOR_Job_Alpha","IOR_Ev10","IOR_Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","IOR_GatewayWritePayload","IOR_Job_Alpha","IOR_Ev11","IOR_Ev12",theAuditEventData);

  // Process all the events on the event queue - these events are not expected for a successful job, so will result in
  // IOR_Job_Alpha going 'horribly wrong'.
  Test::service_event_queue();
  

  // This is a separate Auth Job not fundamental to the test
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);

  // Process all the events on the event queue
  Test::service_event_queue();
  
  // Fire the timer that waits for alternative branch events on Job_Gamma to start - no branch expected in this test.
  theJob := find_only Job(jobID = "Job_Gamma");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Process all the events on the event queue resulting from the state actions that are executed following the
  // jobEventTimer being fired - this will result in Job_Gamma reaching the 'JobSuccessful' state.
  Test::service_event_queue();
  
  //if (Test::get_scheduled_timers ())'length /= 0 then
  //  Test::fire_scheduled_timers();
  //end if;
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  
  Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 21, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    if theJob.jobID = "IOR_Job_Alpha" then
      Assertions::assertTrue(theJob.jobCompleted = false, "Job is erroneously completed - jobID " & theJob.jobID);
    else
      Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
      Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
    end if;
  end loop;
  
  // Fire the jobDeletionTimer for both jobs (IOR_Job_Alpha and Job_Gamma) - this will result in them being deleted.
  theJobs := find Job();
  for theJob in theJobs loop
    Test::fire_timer(theJob.jobDeletionTimer);
  end loop;
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for IOR_Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  // 
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'f9c3130e-accb-44cc-a7a6-740ab2b96dfe' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test39ErrorDetection () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theTimers : sequence of timer;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers an unusual situation which shouldn't occur if AEOrdering is behaving as expected.. It injects 
  // JobComplete from AEOrdering in the middle of a BankTransfer sequence. 
  // Further events are received from AEOrdering for this same Job. Compare with Test38
  // This test does reveals erroneous behaviour of this system.
  //
  // Normal Mid sequence starts here
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Normal Far Side sequence starts here
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
  // Near side sequence starts here
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  //
  // Job complete being injected here is an error condition because this should not occur until all events for a Job have been received
  // Invoke interaction from AEOrdering called JobComplete which is interpreted as Job Timeout in this domain
  jobComplete ("Job_Alpha");
  //
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  // The following event is an end point event which occurs here before the branch is obvious
  // This tests the system does not prematurely indicate Job Complete
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
//
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if;  
//
  theJobs := find Job ();
  for theJob in theJobs loop
    // TODO It would be better also to assert that the job has timed out but this requires an additional attribute
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'a257133e-d65b-4c2c-8d2f-76e1e5b4b1f8' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test40FailedJob () is
theJobs : set of instance of Job;

begin
  // 
  // The failedJob interaction from AEOrdering is received for an unknown Job
  // This test does reveal erroneous behaviour of the twin
  //
  // Failed Job for an unknown Job is an error condition 
  failedJob ("Job_Unknown","Failure_Reason");
//
//  
  Test::service_event_queue();
//
  theJobs := find Job (jobID = "Job_Unknown");
//  theSequences := theJobs -> R10;
//  theAuditEvents := theSequences -> R11;
  
  //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  Assertions::assertTrue(theJobs'length = 0, "Job(s) reported complete for a Job that doesn't exist ; " & (theJobs'length)'image);
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '7275667d-e365-492f-8b32-10288948012c' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test41FailedJob () is
theJob : instance of Job;
theAJob : instance of Job;
theGJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  //
  // The failedJob interaction from AEOrdering is received for a normal Job in the MIDDLE of a normal sequence
  // This test does reveal erroneous behaviour of the monitored system or elsewhere in the digital twin
  // This test also includes a normal error-free Job to test that failure of one Job does not interact with another healthy Job
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  //
  // Failed Job for a normal Job is an error condition that should move the Job into the 'JobFailed' state. All Subsequent
  // audit events, if any, will be ignored in this state.
  //
  failedJob ("Job_Alpha","AEO says the job has failed");
  //
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);

  // Process all the events on the event queue - note that Job_Alpha should be in the 'JobFailed' state after this.
  Test::service_event_queue();


  // Auth Job with single sequence but repeating event types
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
  
  // Process all the events on the event queue - note that Job_Gamma should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();
  
  // Fire the timer that waits for optional branch events on Job_Gamma to start - no branch expected in this test
  theJob := find_only Job(jobID = "Job_Gamma");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
  // the jobEventTimer for Job_Gamma being fired. Note that Job_Gamma should be in the 'JobSuccessful' state after this.
  Test::service_event_queue();

  
  theJobs := find Job ();
  theAJob := find_one Job (jobID = "Job_Alpha");
  theGJob := find_one Job (jobID = "Job_Gamma");
  //
  Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theAJob.jobCompleted = false, "Job has completed but shouldn't have: " & theAJob.jobID);
  Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
  Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
  
  // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
  theJobs := find Job();
  for theJob in theJobs loop
    Test::fire_timer(theJob.jobDeletionTimer);
  end loop;
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '0ed74890-6483-4a10-9a8b-0f8349351c20' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test42FailedJob () is
theJob : instance of Job;
theAJob : instance of Job;
theGJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  //
  // The failedJob interaction from AEOrdering is received for a normal Job at the END of a sequence
  // This test does reveal erroneous behaviour of the monitored system or elsewhere in the digital twin
  // This test also includes a normal error-free Job to test that failure of one Job does not interact with another healthy Job
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  //
  // Failed Job for a normal Job is an error condition that should move the Job into a failed state. Subsequent
  // audit events, if any, will be ignored
  //
  failedJob ("Job_Alpha","AEO says the job has failed");
  //
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
  // Auth Job with single sequence but repeating event types
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
  
  // Process all the events on the event queue - note that Job_Alpha should be in the 'JobFailed' state after this, and
  // Job_Gamma in the 'AssessingSequenceCompletion' state.
  Test::service_event_queue();
 
  // Fire the timer that waits for optional branch events on Job_Gamma to start - no branch expected in this test
  theJob := find_only Job(jobID = "Job_Gamma");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
  // the jobEventTimer for Job_Gamma being fired. Note that Job_Gamma should be in the 'JobSuccessful' state after this.
  Test::service_event_queue();
  
  // Check the state of each of the two jobs.
  theJobs := find Job ();
  theAJob := find_one Job (jobID = "Job_Alpha");
  theGJob := find_one Job (jobID = "Job_Gamma");

  Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theAJob.jobCompleted = false, "Job has completed but shouldn't have: " & theAJob.jobID);
  Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
  Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
  
  
  // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
  theJobs := find Job();
  for theJob in theJobs loop
    Test::fire_timer(theJob.jobDeletionTimer);
  end loop;
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd67a6e89-0d47-4d74-8f27-987c26a3dab7' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test43FailedJobDebatableCondition () is
theJob : instance of Job;
theAJob : instance of Job;
theGJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  //
  // The failedJob interaction from AEOrdering is received for a normal Job after all events have been received but during the
  // timeout period before the Job automatically deletes itself.
  // This test does reveal erroneous behaviour of the monitored system or elsewhere in the digital twin
  // This test also includes a normal error-free Job to test that failure of one Job does not interact with another healthy Job
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);

  // Process all the events on the event queue - note that Job_Alpha should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();
  
  // Failed Job for a normal Job is an error condition that should move the Job into a failed state. Subsequent
  // audit events, if any, will be ignored
  failedJob ("Job_Alpha","AEO says the job has failed");
  //
  // Process all the events on the event queue - note that Job_Alpha should be in the 'JobFailed' state after this.
  Test::service_event_queue();
//
  // Auth Job with single sequence but repeating event types
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
  
  // Process all the events on the event queue - note that Job_Gamma should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();
  
  // Fire the timer that waits for optional branch events on Job_Gamma to arrive - no further branches are expected for this job type.
  theJob := find_only Job(jobID = "Job_Gamma");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Service the event queue again to process any events placed on queue resulting from the jobDeletionTimer for Job_Gamma being fired.
  // Note that Job_Gamma should have reached the 'JobSuccessful' state after this.
  Test::service_event_queue();
  
  // Check the state of each of the two jobs.
  theJobs := find Job ();
  theAJob := find_one Job (jobID = "Job_Alpha");
  theGJob := find_one Job (jobID = "Job_Gamma");
 
  Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theAJob.jobCompleted = false, "Job has completed but shouldn't have: " & theAJob.jobID);
  Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
  Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
  
  // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
  theJobs := find Job();
  for theJob in theJobs loop
    Test::fire_timer(theJob.jobDeletionTimer);
  end loop;
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '0b7e5706-56c0-4285-a9e9-10d2bec0acf9' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test44FailedJobDebatableCondition () is
theJob : instance of Job;
theAJob : instance of Job;
theGJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
//emptyAuditEventData : sequence of auditEventDataStructure;

begin
  //
  // The failedJob interaction from AEOrdering is received for a normal Job after the Job has completed
  // **** Current policy is that Failed Job trumps all behaviour in SVDC so the completed Job is deemed to have failed ****
  // This test does reveal erroneous behaviour of the monitored system or elsewhere in the digital twin
  // This test also includes a normal error-free Job to test that failure of one Job does not interact with another healthy Job
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
  
  // Process all the events on the event queue - note that Job_Alpha should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();
  
  // Fire the timer that waits for optional branch events on Job_Alpha to arrive - no further branches are expected in this test
  theJob := find_only Job(jobID = "Job_Alpha");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Failed Job for a normal Job is an error condition that should move the Job into a failed state. Subsequent
  // audit events, if any, will be ignored
  failedJob ("Job_Alpha","AEO says the job has failed");
  
  // Process all the events on the event queue - note that Job_Alpha should be in the 'JobSuccessful' state after this.
  Test::service_event_queue();


  // Auth Job with single sequence but repeating event types
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
  
  // Process all the events on the event queue - note that Job_Gamma should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();
  
  // Fire the timer that waits for optional branch events on Job_Gamma to arrive - no further branches are expected for this job type.
  theJob := find_only Job(jobID = "Job_Gamma");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Service the event queue again to process any events placed on queue resulting from the jobDeletionTimer for Job_Gamma being fired.
  // Note that Job_Gamma should have reached the 'JobSuccessful' state after this.
  Test::service_event_queue();
  
  // Check the state of each of the two jobs. 
  theJobs := find Job ();
  theAJob := find_one Job (jobID = "Job_Alpha");
  theGJob := find_one Job (jobID = "Job_Gamma");
  
  Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theAJob.jobCompleted = false, "Job has completed but shouldn't have: " & theAJob.jobID);
  Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
  Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
  
  // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
  theJobs := find Job();
  for theJob in theJobs loop
    Test::fire_timer(theJob.jobDeletionTimer);
  end loop;
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '7e958d53-4d00-44d3-aec7-804eb6ee73b3' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test45ErrorDetection () is
theAJob : instance of Job;
theGJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
  // This test does not reveal any erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
  
  // Process all the events on the event queue - note that Job_Alpha should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();
  
  // Fire the timer that waits for optional branch events on Job_Alpha to arrive - no further branches are expected in this test
  theAJob := find_only Job(jobID = "Job_Alpha");
  Test::fire_timer(theAJob.jobEventTimer);
 
  // Process all the events on the event queue - note that Job_Alpha should be in the 'JobSuccessful' state after this.
  Test::service_event_queue();
  
 // Test::service_event_queue();
 // if (Test::get_scheduled_timers ())'length /= 0 then
 //   Test::fire_scheduled_timers();
//  end if; 
  
  //******************************************************************************************************************************************************
  // Insert an extra event after the end of the Job. This should cause Job_Alpha to exit the 'JobSuccessful' state and transition to the 'JobFailed' state
  //******************************************************************************************************************************************************
  acceptOrderedEvent ("1620920060","AgentWritePayload","Job_Alpha","Ev55","Ev90",theAuditEventData);



  // Auth Job with single sequence but repeating event types
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
  

  // Process all the events on the event queue - note that Job_Gamma should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();
  
  // Fire the timer that waits for optional branch events on Job_Gamma to arrive - no further branches are expected for this job type.
  theGJob := find_only Job(jobID = "Job_Gamma");
  Test::fire_timer(theGJob.jobEventTimer);
  
  // Service the event queue again to process any events placed on queue resulting from the jobDeletionTimer for Job_Gamma being fired.
  // Note that Job_Gamma should have reached the 'JobSuccessful' state after this.
  Test::service_event_queue();
  
  // Check the state of each of the two jobs.
  theAJob := find_one Job (jobID = "Job_Alpha");
  theGJob := find_one Job (jobID = "Job_Gamma");

  Assertions::assertTrue(theAJob.jobCompleted = false, "Job has completed but should have failed: " & theAJob.jobID);
  Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
  Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
  
  // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
  theJobs := find Job();
  for theJob in theJobs loop
    Test::fire_timer(theJob.jobDeletionTimer);
  end loop;
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'c2addbd2-30fb-45ac-baeb-adf222cfa61b' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test12NormalForkAndMergePath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 1 sequences based on a fork and merge path definition - there are 3 branches
  // This test does not reveal any erroneous behaviour of the twin
  //
  theAuditEventData := (aeDataKindEnum.BRANCHCOUNT, "TypeFork_1", "3") & (aeDataKindEnum.MERGECOUNT, "TypeFork_2", "3");
  acceptOrderedEvent ("1620920000","FMA","Job_FandM",previousEvents,"Ev301",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  previousEvents := ("Ev301");
  acceptOrderedEvent ("1620920001","FMB","Job_FandM",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev305",theAuditEventData);
  previousEvents := empty & "Ev303" & "Ev304" & "Ev305";
  acceptOrderedEvent ("1620920006","FMF","Job_FandM",previousEvents,"Ev306",theAuditEventData);
  previousEvents := ("Ev306");
  acceptOrderedEvent ("1620920007","FMG","Job_FandM",previousEvents,"Ev307",theAuditEventData);
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 7, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '857c2322-9b34-4ed8-b1e8-64a1adde83cb' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test46ErrorDetectionForkAndMerge () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 1 sequences based on a fork and merge path definition - there are 3 branches
  // This test reveals erroneous behaviour of the twin
  //
  acceptOrderedEvent ("1620920000","FMA","Job_FandM",previousEvents,"Ev301",theAuditEventData);
  previousEvents := ("Ev301");
  acceptOrderedEvent ("1620920001","FMB","Job_FandM",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev305",theAuditEventData);
  // Error caused by an unexpected previous event type occurring at the merge
  previousEvents := empty & "Ev302" & "Ev303" & "Ev304" & "Ev305";
  acceptOrderedEvent ("1620920006","FMF","Job_FandM",previousEvents,"Ev306",theAuditEventData);
  previousEvents := ("Ev306");
  acceptOrderedEvent ("1620920007","FMG","Job_FandM",previousEvents,"Ev307",theAuditEventData);
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
  end loop;  
  
    
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '49755d4e-143c-491c-b35d-e0f6d8142b75' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test47ErrorDetectionForkAndMerge () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 1 sequences based on a fork and merge path definition - there are 3 branches
  // This test test for erroneous behaviour of the twin
  //
  acceptOrderedEvent ("1620920000","FMA","Job_FandM",previousEvents,"Ev301",theAuditEventData);
  previousEvents := ("Ev301");
  acceptOrderedEvent ("1620920001","FMB","Job_FandM",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev305",theAuditEventData);
  // Error caused by a missing previous event type occurring at the merge
  previousEvents := empty & "Ev304" & "Ev305";
  acceptOrderedEvent ("1620920006","FMF","Job_FandM",previousEvents,"Ev306",theAuditEventData);
  previousEvents := ("Ev306");
  acceptOrderedEvent ("1620920007","FMG","Job_FandM",previousEvents,"Ev307",theAuditEventData);
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
  end loop;  
  
    
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd2eb53a8-dae0-4a2c-a995-da6a96a6c273' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test48ErrorDetectionIllegalSequenceEnd () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Jobs with 2 sequences and all events are in the standard default order
  // This test does reveal any erroneous behaviour of the twin
  // The Audit Event "GatewayWritePayload" is defined as a sequence end point and so should never occur 
  // as a previous event id but in this erroneous scenario it does. This should therefore be detected as an error
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  // Error inserted here: The first event of the Mid Sequence now has an inappropriate previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","Ev12","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
//
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
//  theSequences := theJobs -> R10;
//  theAuditEvents := theSequences -> R11;
  
  //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed, "Sequencing hasn't failed and it should have: " & theJob.jobID);
  end loop;  end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '6eebfd0a-8991-449d-bb75-8c5a038a563d' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test13NormalInstanceForkAndMergePath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 1 sequences based on a fork and merge path definition - there are 3 branches
  // This test does not reveal any erroneous behaviour of the twin
  //
  theAuditEventData := (aeDataKindEnum.BRANCHCOUNT, "InstFork_1", "10") & (aeDataKindEnum.MERGECOUNT, "InstMerge_1", "10");
  acceptOrderedEvent ("1620920000","IFA","Instance_FandM_Job",previousEvents,"Ev301",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  previousEvents := ("Ev301");
  acceptOrderedEvent ("1620920001","IFB","Instance_FandM_Job",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev305",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev306",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev307",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev308",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev309",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev310",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev311",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev312",theAuditEventData);
  previousEvents := empty & "Ev303" & "Ev304" & "Ev305" & "Ev306" & "Ev307" & "Ev308" & "Ev309" & "Ev310" & "Ev311" & "Ev312";
  acceptOrderedEvent ("1620920003","IFD","Instance_FandM_Job",previousEvents,"Ev313",theAuditEventData);
  previousEvents := ("Ev313");
  acceptOrderedEvent ("1620920004","IFE","Instance_FandM_Job",previousEvents,"Ev314",theAuditEventData);
  previousEvents := ("Ev314");
  acceptOrderedEvent ("1620920005","IFF","Instance_FandM_Job",previousEvents,"Ev315",theAuditEventData);
 //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 15, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '606f441a-5bd2-41d3-a5a5-f7ce19eefbb1' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test49ErrorDetectionIllegalSequenceEnd () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 1 sequence using an illegal path definition to test that the model detects
  // an audit event end point occurring in a previous event id.
  // This test does reveals an erroneous event definition
  //
  acceptOrderedEvent ("1620920000","MALA","Illegal_Job",previousEvents,"Ev301",theAuditEventData);
  previousEvents := ("Ev301");
  acceptOrderedEvent ("1620920001","MALB","Illegal_Job",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  // The following audit event corresponds to an audit event definition that is defined as end of sequence
  // yet there is a following event. This should be trapped as an error condition
  acceptOrderedEvent ("1620920002","MALC","Illegal_Job",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev303");
  acceptOrderedEvent ("1620920002","MALD","Illegal_Job",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev304");
  acceptOrderedEvent ("1620920002","MALE","Illegal_Job",previousEvents,"Ev305",theAuditEventData);
 //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '02158917-2fa1-46ed-a31c-0691ca7ab30b' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test50ErrorDetectionInstanceForkAndMergePath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 1 sequence based on a fork and merge path definition - there are 10 branches but only 
  // 9 merge events so this is erroneous
  // This test does  reveal any erroneous behaviour of the twin
  //
  acceptOrderedEvent ("1620920000","IFA","Instance_FandM_Job",previousEvents,"Ev301",theAuditEventData);
  previousEvents := ("Ev301");
  acceptOrderedEvent ("1620920001","IFB","Instance_FandM_Job",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev305",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev306",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev307",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev308",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev309",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev310",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev311",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev312",theAuditEventData);
  //Error inserted here since Ev312 is missing
  previousEvents := empty & "Ev303" & "Ev304" & "Ev305" & "Ev306" & "Ev307" & "Ev308" & "Ev309" & "Ev310" & "Ev311";
  acceptOrderedEvent ("1620920003","IFD","Instance_FandM_Job",previousEvents,"Ev313",theAuditEventData);
  previousEvents := ("Ev313");
  acceptOrderedEvent ("1620920004","IFE","Instance_FandM_Job",previousEvents,"Ev314",theAuditEventData);
 //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
  end loop;  
 end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '695b5300-2d83-45b9-8e23-dcf150351400' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test51ErrorDetectionInstanceForkAndMergePath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 1 sequence based on a fork and merge path definition - there are 10 branches but only 
  // 9 merge events so this is erroneous
  // This test does  reveal any erroneous behaviour of the twin
  //
  acceptOrderedEvent ("1620920000","IFA","Instance_FandM_Job",previousEvents,"Ev301",theAuditEventData);
  previousEvents := ("Ev301");
  acceptOrderedEvent ("1620920001","IFB","Instance_FandM_Job",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev305",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev306",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev307",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev308",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev309",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev310",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev311",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","IFC","Instance_FandM_Job",previousEvents,"Ev312",theAuditEventData);
  //Error inserted here since Ev312 is missing and Ev303 is repeated
  previousEvents := empty & "Ev303" & "Ev304" & "Ev305" & "Ev306" & "Ev307" & "Ev308" & "Ev309" & "Ev310" & "Ev311" & "Ev303";
  acceptOrderedEvent ("1620920003","IFD","Instance_FandM_Job",previousEvents,"Ev313",theAuditEventData);
  previousEvents := ("Ev313");
  acceptOrderedEvent ("1620920004","IFE","Instance_FandM_Job",previousEvents,"Ev314",theAuditEventData);
 //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
  end loop;  
 end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '0aa87c76-9ef5-41b6-bdcf-bdfcc1ba7123' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test57MissingInvariants () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 2 sequences based on a fork and merge path definition - the first
  // sequence contains a fork to 3 branches and the second sequence contains a merge back to a single branch
  // This test does not reveal any erroneous behaviour of the twin
  //
  previousEvents := empty;
  acceptOrderedEvent ("1620920000","SFMA","Job_Split_FandM",previousEvents,"Ev301",theAuditEventData);
  previousEvents := ("Ev301");
  acceptOrderedEvent ("1620920001","SFMB","Job_Split_FandM",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","SFMC","Job_Split_FandM",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","SFMD","Job_Split_FandM",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","SFME","Job_Split_FandM",previousEvents,"Ev305",theAuditEventData);
  previousEvents := empty;
  acceptOrderedEvent ("1620920005","SFMC1","Job_Split_FandM",previousEvents,"Ev306",theAuditEventData);
  previousEvents := empty;
  acceptOrderedEvent ("1620920005","SFMD1","Job_Split_FandM",previousEvents,"Ev307",theAuditEventData);
  previousEvents := empty;
  acceptOrderedEvent ("1620920005","SFME1","Job_Split_FandM",previousEvents,"Ev308",theAuditEventData);
  previousEvents := empty & "Ev306" & "Ev307" & "Ev308";
  acceptOrderedEvent ("1620920006","SFMF","Job_Split_FandM",previousEvents,"Ev309",theAuditEventData);
  previousEvents := ("Ev309");
  acceptOrderedEvent ("1620920007","SFMG","Job_Split_FandM",previousEvents,"Ev310",theAuditEventData);
  
  // Process all the events on the event queue - note that Job_Split_FandM should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();

  // Fire the timer that waits for other branch events on Job_Split_FandM to arrive - and the job will proceed to constraint and 
  // invariant checking where it will fail the invariant checks.
  theJob := find_only Job(jobID = "Job_Split_FandM");
  Test::fire_timer(theJob.jobEventTimer);
 
  // Process all the events on the event queue - note that Job_Split_FandM should be in the 'JobFailed' state after this because
  // the job will have failed the invariant checks.
  Test::service_event_queue();
  
  // Check the state of Job_Split_FandM is as expected
  Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed expected invariants were missing: " & theJob.jobID);


// Fire the jobDeletionTimer for Job_Split_FandM - this will result in it being deleted.
  Test::fire_timer(theJob.jobDeletionTimer);
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Split_FandM being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'dcaee3ce-d56b-4cf5-a50f-212d2c506052' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test15NormalSplitInstanceForkAndMergePath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 2 sequences based on a split fork and merge path definition - there are 10 branches
  // This test does not reveal any erroneous behaviour of the twin
  // Forking Sequence

  theAuditEventData := (aeDataKindEnum.BRANCHCOUNT, "SplitInstFork_1", "10") & (aeDataKindEnum.MERGECOUNT, "SplitInstMerge_1", "10");
  acceptOrderedEvent ("1620920000","SIFA","Instance_FandM_Job",previousEvents,"Ev301",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  previousEvents := ("Ev301");
  acceptOrderedEvent ("1620920001","SIFB","Instance_FandM_Job",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","SIFC","Instance_FandM_Job",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","SIFC","Instance_FandM_Job",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","SIFC","Instance_FandM_Job",previousEvents,"Ev305",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","SIFC","Instance_FandM_Job",previousEvents,"Ev306",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","SIFC","Instance_FandM_Job",previousEvents,"Ev307",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","SIFC","Instance_FandM_Job",previousEvents,"Ev308",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","SIFC","Instance_FandM_Job",previousEvents,"Ev309",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","SIFC","Instance_FandM_Job",previousEvents,"Ev310",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","SIFC","Instance_FandM_Job",previousEvents,"Ev311",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920002","SIFC","Instance_FandM_Job",previousEvents,"Ev312",theAuditEventData);
  
  // Merging Sequence
  previousEvents := empty;
  acceptOrderedEvent ("1620920003","SIFD","Instance_FandM_Job",previousEvents,"Ev313",theAuditEventData);
  previousEvents := empty;
  acceptOrderedEvent ("1620920003","SIFD","Instance_FandM_Job",previousEvents,"Ev314",theAuditEventData);
  previousEvents := empty;
  acceptOrderedEvent ("1620920003","SIFD","Instance_FandM_Job",previousEvents,"Ev315",theAuditEventData);
  previousEvents := empty;
  acceptOrderedEvent ("1620920003","SIFD","Instance_FandM_Job",previousEvents,"Ev316",theAuditEventData);
  previousEvents := empty;
  acceptOrderedEvent ("1620920003","SIFD","Instance_FandM_Job",previousEvents,"Ev317",theAuditEventData);
  previousEvents := empty;
  acceptOrderedEvent ("1620920003","SIFD","Instance_FandM_Job",previousEvents,"Ev318",theAuditEventData);
  previousEvents := empty;
  acceptOrderedEvent ("1620920003","SIFD","Instance_FandM_Job",previousEvents,"Ev319",theAuditEventData);
  previousEvents := empty;
  acceptOrderedEvent ("1620920003","SIFD","Instance_FandM_Job",previousEvents,"Ev320",theAuditEventData);
  previousEvents := empty;
  acceptOrderedEvent ("1620920003","SIFD","Instance_FandM_Job",previousEvents,"Ev321",theAuditEventData);
  previousEvents := empty;
  acceptOrderedEvent ("1620920003","SIFD","Instance_FandM_Job",previousEvents,"Ev322",theAuditEventData);
  previousEvents := empty & "Ev313" & "Ev314" & "Ev315" & "Ev316" & "Ev317" & "Ev318" & "Ev319" & "Ev320" & "Ev321" & "Ev322";
  acceptOrderedEvent ("1620920004","SIFE","Instance_FandM_Job",previousEvents,"Ev323",theAuditEventData);
  previousEvents := ("Ev323");
  acceptOrderedEvent ("1620920005","SIFF","Instance_FandM_Job",previousEvents,"Ev324",theAuditEventData);
 //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 2, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 24, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'e5040c89-9cec-44e7-901a-646be55cf210' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test16NormalInstanceAndTypeForkAndMergePath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 1 sequence based on a fork and merge path definition - 
  // there are 3 type branches and each type branch has 5 instance branches 
  // all at the same fork point. There is a branch count defined but no merge count
  // This test does not reveal any erroneous behaviour of the twin
  //
  theAuditEventData := (aeDataKindEnum.BRANCHCOUNT, "TypeFork_1", "15") & (aeDataKindEnum.MERGECOUNT, "TypeFork_2", "15");
  acceptOrderedEvent ("1620920000","FMA","Job_FandM",previousEvents,"Ev301",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  previousEvents := ("Ev301");
  acceptOrderedEvent ("1620920001","FMB","Job_FandM",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev305",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev306",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev307",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev308",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev309",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev310",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev311",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev312",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev313",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev314",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev315",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev316",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev317",theAuditEventData);
   
  // The merge point
  previousEvents := empty & "Ev303" & "Ev304" & "Ev305" & "Ev306" & "Ev307" & "Ev308" & "Ev309" & "Ev310" & "Ev311" & "Ev312" & "Ev313" & "Ev314" & "Ev315" & "Ev316" & "Ev317";
  acceptOrderedEvent ("1620920006","FMF","Job_FandM",previousEvents,"Ev318",theAuditEventData);
  previousEvents := ("Ev318");
  acceptOrderedEvent ("1620920007","FMG","Job_FandM",previousEvents,"Ev319",theAuditEventData);
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 19, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '185343ee-85d4-4b00-869e-c9b1d905aeaf' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test18DeprecationAndDeletionOfActiveJobDefinition () is
theJob : instance of Job;
theJobDefn : instance of JobDefinition;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test checks the behaviour of deprecation and subsequent deletion of an 'Active' JobDefinition.
  // It starts with the creation of a new Job when the first event for a Bank Transfer Job arrives which is
  // then followed by a request to deprecate the related JobDefinition.
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  Test::service_event_queue();

  theJob := find_only Job(jobID = "Job_Alpha");
  theJobDefn := theJob -> R8;
  generate JobDefinition.deprecate() to theJobDefn;
  Test::service_event_queue();
    
  Assertions::assertTrue(theJobDefn.jobName = "BankTransferJob", "Wrong JobDefinition: " & theJobDefn.jobName & "was deprecated, whereas a 'BankTransferJob' was expected");
  Assertions::assertTrue(theJobDefn.isDeprecated = true, "JobDefinition with jobName: " & theJobDefn.jobName & "failed to deprecate");
  
  // Fire timers to ensure that the deprecated JobDefinition re-checks whether it's OK to delete itself
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if;
  
  // Re-check that the JobDefinition for BankTransferJob type has not been deleted
  theJobDefn := find_only JobDefinition(jobName = "BankTransferJob");
  
  Assertions::assertTrue(theJobDefn /= null, "JobDefinition 'BankTransferJob' has unexpectedly been deleted");

  // Delete the only Job for the deprecated BankTransferJob type and then re-fire the timers so that it 
  // re-checks whether it's OK to delete itself
  theJob.deleteJob();
  
  // Fire timers to ensure that the deprecated JobDefintion re-checks whether it's OK to delete itself
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if;
  
  // ...and then check to see if the deprecated JobDefinition has deleted itself.
  theJobDefn := find_only JobDefinition(jobName = "BankTransferJob");
  
  Assertions::assertTrue(theJobDefn = null, "Deprecated JobDefinition 'BankTransferJob' has not deleted itself even though it has no uncompleted Jobs");
  

end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '6ade3c71-7bc4-4f23-938c-346574638416' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test19StartOfNewJobForDeprecatedJobDefinition () is
theFirstJob : instance of Job;
theBankTransferJobs : set of instance of Job;
theJobDefn : instance of JobDefinition;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test checks that new Jobs of a type that has been deprecated cannot be started.
  // Start by creating the first of two Jobs of type 'AuthJob' and then deprecate that type so that
  // no new jobs of this type should be started.
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma_One","","Ev201",theAuditEventData);
  Test::service_event_queue();

  theFirstJob := find_only Job(jobID = "Job_Gamma_One");
  theJobDefn := theFirstJob -> R8;
  generate JobDefinition.deprecate() to theJobDefn;
  Test::service_event_queue();
    
  Assertions::assertTrue(theJobDefn.jobName = "AuthJob", "Wrong JobDefinition: " & theJobDefn.jobName & "was deprecated, whereas a 'AuthJob' was expected");
  Assertions::assertTrue(theJobDefn.isDeprecated = true, "JobDefinition with jobName: " & theJobDefn.jobName & "failed to deprecate");
  
  // Fire timers to ensure that the deprecated JobDefintion re-checks whether it's OK to delete itself
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if;
  
  // Re-check that the JobDefinition of type 'AuthJob'  has not been deleted
  theJobDefn := find_only JobDefinition(jobName = "AuthJob");
 
  Assertions::assertTrue(theJobDefn /= null, "JobDefinition 'AuthJob' has unexpectedly been deleted");

  // Now try starting a second job of the same type - and because that type has been deprecated then the new job should not be started.
  acceptOrderedEvent ("1620920101","AuthoriserSendOrderRequest","Job_Gamma_Two","","Ev202",theAuditEventData);
  Test::service_event_queue();
  
  // Fire timers to ensure that the deprecated JobDefintion re-checks whether it's OK to delete itself
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if;
  
  // ...and then check to see if the deprecated JobDefinition has NOT deleted itself.
  theJobDefn := find_only JobDefinition(jobName = "AuthJob");
  
  Assertions::assertTrue(theJobDefn /= null, "Deprecated JobDefinition 'AuthJob' has incorrectly deleted itself before all jobs of that type have completed");
  
  // ...and finally check that the second job was not started
  theBankTransferJobs := theJobDefn -> R8;
  Assertions::assertTrue(theBankTransferJobs'length = 1, "New Job of type 'AuthJob' was started despite that type being deprecated");
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '311789de-7c57-4546-9476-e31f0923292f' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test20StartOfNewJobForSuspendedJobDefinition () is
theFirstJob : instance of Job;
theThirdJob : instance of Job;
theBankTransferJobs : set of instance of Job;
theJobDefn : instance of JobDefinition;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test checks that new Jobs of a type that has been suspended cannot be started.
  // Start by creating the first of three Jobs of type 'CyclicJob' and then deprecate that type so that
  // no new jobs of this type should be started.
  acceptOrderedEvent ("1620920000","A","Job_Cyclo_One","","Ev301",theAuditEventData);
  Test::service_event_queue();

  theFirstJob := find_only Job(jobID = "Job_Cyclo_One");
  theJobDefn := theFirstJob -> R8;
  generate JobDefinition.suspend() to theJobDefn;
  Test::service_event_queue();
    
  Assertions::assertTrue(theJobDefn.jobName = "CyclicJob", "Wrong JobDefinition: " & theJobDefn.jobName & "was suspended, whereas a 'CyclicJob' was expected");
  Assertions::assertTrue(theJobDefn.isSuspended = true, "JobDefinition with jobName: " & theJobDefn.jobName & "failed to suspend");

  // Now try starting a second Job of the same type - and because that type has been suspended then the new job should not be started.
  acceptOrderedEvent ("1620920001","A","Job_Cyclo_Two","","Ev302",theAuditEventData);
  Test::service_event_queue();
  
  // ...and then check that the second job was not started.
  theBankTransferJobs := theJobDefn -> R8;
  Assertions::assertTrue(theBankTransferJobs'length = 1, "New Job of type 'CyclicJob' was started despite that type being suspended");
  
  // Next, reactivate the suspended JobDefinition and check that a third job of this type can be started.
  generate JobDefinition.reactivate() to theJobDefn;
  Test::service_event_queue();
  
  // Now try starting a third Job of the same type - this should be successful now that the JobDefinition is ACTIVE once again.
  acceptOrderedEvent ("1620920003","A","Job_Cyclo_Three","","Ev303",theAuditEventData);
  Test::service_event_queue();
  
  // ...and finally check that the third Job was successfully started.
  theThirdJob := find_only Job (jobID = "Job_Cyclo_Three");
  theBankTransferJobs := theJobDefn -> R8;
  Assertions::assertTrue(theThirdJob /= null, "New Job 'Job_Cyclo_Three' was not started despite its type being active");
  Assertions::assertTrue(theBankTransferJobs'length = 2, "New Job of type 'CyclicJob' was not started despite that type being active");
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '652d8e9f-fb5b-4148-8b64-d053ce62fbe5' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test52ErrorDetectionInstanceAndTypeForkAndMergePath () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 1 Job with 1 sequence based on a fork and merge path definition - 
  // there are 3 type branches and each type branch has 5 instance branches 
  // all at the same fork point
  // This test does reveal any erroneous behaviour of the twin since a previous event is repeated
  //
  acceptOrderedEvent ("1620920000","FMA","Job_FandM",previousEvents,"Ev301",theAuditEventData);
  previousEvents := ("Ev301");
  acceptOrderedEvent ("1620920001","FMB","Job_FandM",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev305",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev306",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMC","Job_FandM",previousEvents,"Ev307",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev308",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev309",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev310",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev311",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FMD","Job_FandM",previousEvents,"Ev312",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev313",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev314",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev315",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev316",theAuditEventData);
  previousEvents := ("Ev302");
  acceptOrderedEvent ("1620920001","FME","Job_FandM",previousEvents,"Ev317",theAuditEventData);
   
  // The merge point with error as Ev303 is repeated and Ev304 is missing so the count is still correct
  previousEvents := empty & "Ev303" & "Ev303" & "Ev305" & "Ev306" & "Ev307" & "Ev308" & "Ev309" & "Ev310" & "Ev311" & "Ev312" & "Ev313" & "Ev314" & "Ev315" & "Ev316" & "Ev317";
  acceptOrderedEvent ("1620920006","FMF","Job_FandM",previousEvents,"Ev318",theAuditEventData);
  previousEvents := ("Ev318");
  acceptOrderedEvent ("1620920007","FMG","Job_FandM",previousEvents,"Ev319",theAuditEventData);
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'd0246951-5a4b-4a45-beea-a3c14a3862df' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test53ErrorDetectionConstraintViolation () is
theAJob : instance of Job;
theGJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
  // However, Event 9a is omitted meaning that the AND constraint following the AgentReceiveWidgets event
  // will be violated. This should cause the Job to fail with a constraint violation
  // This test does reveal any erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  // Error introduced here: The following event is commented out to cause a constraint violation
  //acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);

  // Process all the events on the event queue - note that Job_Alpha should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();
  
  // Fire the timer that waits for other branch events on Job_Alpha to arrive - but the start of the AND-constrained branch had failed to arrive
  // before this, so the Job will progress as if no more sequences are expected and will progress to the 'AssessingJobConstraints' state where
  // it is expected to fail once the event queue has been fully processed.
  theAJob := find_only Job(jobID = "Job_Alpha");
  Test::fire_timer(theAJob.jobEventTimer);
 
  // Process all the events on the event queue - note that Job_Alpha should be in the 'JobFailed' state after this.
  Test::service_event_queue();
//
  // Auth Job with single sequence but repeating event types
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
  
  // Process all the events on the event queue - note that Job_Gamma should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();
  
  // Fire the timer that waits for optional branch events on Job_Gamma to arrive - no further branches are expected for this job type.
  theGJob := find_only Job(jobID = "Job_Gamma");
  Test::fire_timer(theGJob.jobEventTimer);
  
  // Service the event queue again to process any events placed on queue resulting from the jobDeletionTimer for Job_Gamma being fired.
  // Note that Job_Gamma should have reached the 'JobSuccessful' state after this.
  Test::service_event_queue();
  
  // Check the state of each of the two jobs. 
  theAJob := find_one Job (jobID = "Job_Alpha");
  theGJob := find_one Job (jobID = "Job_Gamma");

  Assertions::assertTrue(theAJob.jobCompleted = false, "Job is completed but shouldn't have: " & theAJob.jobID);
  Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
  Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
  
  // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
  theJobs := find Job();
  for theJob in theJobs loop
    Test::fire_timer(theJob.jobDeletionTimer);
  end loop;
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'a3193263-e9a2-4e2f-b7f3-f9074c68b6df' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test17NormalXORConstraint () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
  // It includes an XOR alternative error event replacing the normal event at Ev14
  // This test does not reveal any erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  // This is a variant of Test01NormalPath where the following event is simulating an error event
  // replacing in an exclusive Or constraint the normal MidWritePayload event
  acceptOrderedEvent ("1620920013","MidPayloadError","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
//
  Test::service_event_queue();
//
  // Auth Job with single sequence but repeating event types
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  //
  Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'b2ecf262-9a57-456d-a6f4-16937b22b376' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test54ErrorDetectionXORConstraintViolation () is
theAJob : instance of Job;
theGJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
  // It includes both events following an XOR constraint at Ev14 - this is an error condition
  // This test does reveal any erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  // This is a variant of Test01NormalPath where the following 2 events are violating an exclusive Or constraint 
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidPayloadError","Job_Alpha","Ev13","Ev14a",theAuditEventData);
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);

  // Process all the events on the event queue - note that Job_Alpha should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();

  // Fire the timer that waits for other branch events on Job_Alpha to arrive - the unexpected extra event that represents the start of 
  // another branch will be accepted at this point because it satisfies the sequence specification but will later fail the constraint
  // checks which are done once the job is considered to have completed.
  theAJob := find_only Job(jobID = "Job_Alpha");
  Test::fire_timer(theAJob.jobEventTimer);
 
  // Process all the events on the event queue - note that Job_Alpha should be in the 'JobFailed' state after this because
  // the job will have failed the constraint checks.
  Test::service_event_queue();
  
  
  // Auth Job with single sequence but repeating event types
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
  
  // Process all the events on the event queue - note that Job_Gamma should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();
  
  // Fire the timer that waits for optional branch events on Job_Gamma to arrive - no further branches are expected for this job type.
  theGJob := find_only Job(jobID = "Job_Gamma");
  Test::fire_timer(theGJob.jobEventTimer);
  
  // Service the event queue again to process any events placed on queue resulting from the jobDeletionTimer for Job_Gamma being fired.
  // Note that Job_Gamma should have reached the 'JobSuccessful' state after this.
  Test::service_event_queue();
  
  // Check the state of each of the two jobs.
  theAJob := find_one Job (jobID = "Job_Alpha");
  theGJob := find_one Job (jobID = "Job_Gamma");
  Assertions::assertTrue(theAJob.jobCompleted = false, "Job is completed but shouldn't have: " & theAJob.jobID);
  Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
  Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
  
  // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
  theJobs := find Job();
  for theJob in theJobs loop
    Test::fire_timer(theJob.jobDeletionTimer);
  end loop;
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '4c096f1e-9df5-4b29-a1ca-dfee203c5c46' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test21NormalIntraJobInvariant () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;
theIntraJobInvariants : set of instance of TransientInvariant;

begin
  // This test is based upon Test14 which covers 1 Job with 2 sequences based on a fork and merge path definition - the first
  // sequence contains a fork to 3 branches and the second sequence contains a merge back to a single branch
  // This test adds invariant audit event data which is used to verify the two sequences have been used correctly
  // This test does not reveal any erroneous behaviour of the twin
  //
  previousEvents := empty;
  theAuditEventData := (aeDataKindEnum.INTRAJOBINV, "InvA", "A12345");
  acceptOrderedEvent ("1620920000","SFMA","Job_Split_FandM",previousEvents,"Ev301",theAuditEventData);
  previousEvents := ("Ev301");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","SFMB","Job_Split_FandM",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","SFMC","Job_Split_FandM",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","SFMD","Job_Split_FandM",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","SFME","Job_Split_FandM",previousEvents,"Ev305",theAuditEventData);
  previousEvents := empty;
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","SFMC1","Job_Split_FandM",previousEvents,"Ev306",theAuditEventData);
  previousEvents := empty;
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","SFMD1","Job_Split_FandM",previousEvents,"Ev307",theAuditEventData);
  previousEvents := empty;
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","SFME1","Job_Split_FandM",previousEvents,"Ev308",theAuditEventData);
  previousEvents := empty & "Ev306" & "Ev307" & "Ev308";
  theAuditEventData := (aeDataKindEnum.INTRAJOBINV, "InvA", "A12345");
  acceptOrderedEvent ("1620920006","SFMF","Job_Split_FandM",previousEvents,"Ev309",theAuditEventData);
  previousEvents := ("Ev309");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920007","SFMG","Job_Split_FandM",previousEvents,"Ev310",theAuditEventData);
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  theIntraJobInvariants := theAuditEvents -> R23;
  
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 2, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 10, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  Assertions::assertTrue(theIntraJobInvariants'length = 2, "Wrong number of invariants created: " & (theIntraJobInvariants'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'f9aad914-baba-4c80-a686-83230a04235f' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test55InvalidIntraJobInvariant () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers introduces mismatching invariant values which is an error condition
  // This test does reveal any erroneous behaviour of the twin
  //
  previousEvents := empty;
  theAuditEventData := (aeDataKindEnum.INTRAJOBINV, "InvA", "A12345");
  acceptOrderedEvent ("1620920000","SFMA","Job_Split_FandM",previousEvents,"Ev301",theAuditEventData);
  previousEvents := ("Ev301");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","SFMB","Job_Split_FandM",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","SFMC","Job_Split_FandM",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","SFMD","Job_Split_FandM",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","SFME","Job_Split_FandM",previousEvents,"Ev305",theAuditEventData);
  previousEvents := empty;
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","SFMC1","Job_Split_FandM",previousEvents,"Ev306",theAuditEventData);
  previousEvents := empty;
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","SFMD1","Job_Split_FandM",previousEvents,"Ev307",theAuditEventData);
  previousEvents := empty;
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","SFME1","Job_Split_FandM",previousEvents,"Ev308",theAuditEventData);
  previousEvents := empty & "Ev306" & "Ev307" & "Ev308";
  theAuditEventData := (aeDataKindEnum.INTRAJOBINV, "InvA", "A54321");
  acceptOrderedEvent ("1620920006","SFMF","Job_Split_FandM",previousEvents,"Ev309",theAuditEventData);
  previousEvents := ("Ev309");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920007","SFMG","Job_Split_FandM",previousEvents,"Ev310",theAuditEventData);
  
  // Process all the events on the event queue - note that Job_Split_FandM should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();

  // Fire the timer that waits for other branch events on Job_Split_FandM to arrive - and the job will proceed to constraint and 
  // invariant checking where it will fail the invariant checks.
  theJob := find_only Job(jobID = "Job_Split_FandM");
  Test::fire_timer(theJob.jobEventTimer);
 
  // Process all the events on the event queue - note that Job_Split_FandM should be in the 'JobFailed' state after this because
  // the job will have failed the invariant checks.
  Test::service_event_queue(); 
  
  // Check the state of Job_Split_FandM is as expected
  Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed though the invariant was invalid: " & theJob.jobID);
  
  // Fire the jobDeletionTimer for Job_Split_FandM - this will result in it being deleted.
  Test::fire_timer(theJob.jobDeletionTimer);
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Split_FandM being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '97dabf18-a28a-4859-9c90-8423e9351fa0' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test56InvalidIntraJobInvariant () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;
logMessage : string;

begin
  // This test covers introduces a matching invariant but attached to an invalid audit event
  // This test does reveal any erroneous behaviour of the twin
  //
  previousEvents := empty;
  theAuditEventData := (aeDataKindEnum.INTRAJOBINV, "InvA", "A12345");
  acceptOrderedEvent ("1620920000","SFMA","Job_Split_FandM",previousEvents,"Ev301",theAuditEventData);
  previousEvents := ("Ev301");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","SFMB","Job_Split_FandM",previousEvents,"Ev302",theAuditEventData);
  previousEvents := ("Ev302");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","SFMC","Job_Split_FandM",previousEvents,"Ev303",theAuditEventData);
  previousEvents := ("Ev302");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","SFMD","Job_Split_FandM",previousEvents,"Ev304",theAuditEventData);
  previousEvents := ("Ev302");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","SFME","Job_Split_FandM",previousEvents,"Ev305",theAuditEventData);
  previousEvents := empty;
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","SFMC1","Job_Split_FandM",previousEvents,"Ev306",theAuditEventData);
  previousEvents := empty;
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","SFMD1","Job_Split_FandM",previousEvents,"Ev307",theAuditEventData);
  previousEvents := empty;
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","SFME1","Job_Split_FandM",previousEvents,"Ev308",theAuditEventData);
  previousEvents := empty & "Ev306" & "Ev307" & "Ev308";
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920006","SFMF","Job_Split_FandM",previousEvents,"Ev309",theAuditEventData);
  previousEvents := ("Ev309");
  theAuditEventData := (aeDataKindEnum.INTRAJOBINV, "InvA", "A12345");
  acceptOrderedEvent ("1620920007","SFMG","Job_Split_FandM",previousEvents,"Ev310",theAuditEventData);
  //
  // Process all the events on the event queue - note that Job_Split_FandM should be in the 'JobFailed' state after this.
  Test::service_event_queue();
      
  // Check the state of Job_Split_FandM is as expected
  theJob := find_only Job(jobID = "Job_Split_FandM");
  Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed though an invariant was attached to the wrong audit event: " & theJob.jobID);
 
  
 // Fire the jobDeletionTimer for Job_Split_FandM - this will result in it being deleted.
  Test::fire_timer(theJob.jobDeletionTimer);
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Split_FandM being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  //
  //
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'a1f93497-5e4d-449c-807c-dcef0dd52ca8' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test22NormalSourceExtraJobInvariant () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
previousEvents : sequence of string;
empty : sequence of string;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;
thePersistedInvariants : set of instance of PersistedInvariant;
thePersistedInvariant : instance of PersistedInvariant;
logMessage : string;

begin
  // This test covers 1 Auth Job with 2 persistentinvariant values being defined
  // This test does not reveal any erroneous behaviour of the twin
  //
  previousEvents := empty;
//  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent987654321");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920000","EAuthoriserSendOrderRequest","Job_PersistentInvariant",previousEvents,"Ev1201",theAuditEventData);
  previousEvents := ("Ev1201");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","EAuthReceiveRequest","Job_PersistentInvariant",previousEvents,"Ev1202",theAuditEventData);
  previousEvents := ("Ev1202");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920002","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1203",theAuditEventData);
  previousEvents := ("Ev1203");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920003","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1204",theAuditEventData);
  previousEvents := ("Ev1204");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920004","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1205",theAuditEventData);
  previousEvents := ("Ev1205");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1206",theAuditEventData);
  previousEvents := ("Ev1206");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920006","EAuthSendResponse","Job_PersistentInvariant",previousEvents,"Ev1207",theAuditEventData);
  previousEvents := ("Ev1207");
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920007","EAuthoriserReceiveOrder","Job_PersistentInvariant",previousEvents,"Ev1208",theAuditEventData);
 
  //
  Test::service_event_queue();
  if (Test::get_scheduled_timers ())'length /= 0 then
    Test::fire_scheduled_timers();
  end if; 
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  thePersistedInvariants := find PersistedInvariant();
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 8, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  Assertions::assertTrue(thePersistedInvariants'length = 1, "Wrong number of persistentinvariant instances created: " & (theAuditEvents'length)'image);
  for theJob in theJobs loop
    Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
    Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
  end loop;
  
  // ... and finally clear down all the existing instances of PersistedInvariant in readiness for other tests.
  for thePersistedInvariant in thePersistedInvariants loop
    thePersistedInvariant.deletePersistedInvariant();   
  end loop;
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'ad5dfbbd-e577-4a26-b295-c4ca44cf68e4' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test53aErrorDetectionANDConstraintViolation () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;

begin
  // This test covers a very special situation. It injects JobComplete from AEOrdering at the point where one branch
  // of a BankTransfer sequence has completed but another branch (if there is one) hasn't started. The events for the
  // other branch arrive after JobComplete which would be erroneous behaviour of AEOrdering. The model ignores JobComplete
  // in this specific circumstance because it looks just like a legitimate end of a Job prior to the Job timeout. Compare with Test39.
  // This test does reveals some anomalous behaviour of this system but it is not classed as an error condition.
  //
  // Normal Mid sequence starts here
  acceptOrderedEvent ("1620920012","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
  acceptOrderedEvent ("1620920013","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
  // Normal Far Side sequence starts here
  acceptOrderedEvent ("1620920050","FarInput","Job_Alpha","","Ev50",theAuditEventData);
  acceptOrderedEvent ("1620920055","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
  // Near side sequence starts here
  acceptOrderedEvent ("1620920000","NearInput","Job_Alpha","","Ev1",theAuditEventData);
  acceptOrderedEvent ("1620920001","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
  acceptOrderedEvent ("1620920002","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
  acceptOrderedEvent ("1620920003","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
  acceptOrderedEvent ("1620920004","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
  acceptOrderedEvent ("1620920005","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
  acceptOrderedEvent ("1620920006","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
  acceptOrderedEvent ("1620920007","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
  // The following event is an end point event which occurs here before the branch is obvious
  // This tests the system does not prematurely indicate Job Complete
  acceptOrderedEvent ("1620920008","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);

  // Mimic the interaction from AEOrdering called jobComplete which is interpreted as a Job Timeout in this domain.
  // Note that jobComplete being injected here is an error condition because this should not occur until all events for a Job have been received
  jobComplete ("Job_Alpha");
  
  // Process all the events on the event queue (including the jobTimedOut event). At this point in the test the Job should 
  // have reached the 'AssessingSequenceCompletion' state and so will ignore the jobTimedOut event.
  Test::service_event_queue();
  
  // Fire the timer that waits for alternative branch events on Job_Alpha to arrive - this mimics the situation where 
  // the events for Job_Alpha that follow (see below) arrive too late to be processed but the Job proceeds (wrongly) on
  // on basis that all sequences must have been received.
  theJob := find_only Job(jobID = "Job_Alpha");
  Test::fire_timer(theJob.jobEventTimer);
  
  acceptOrderedEvent ("1620920008","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
  acceptOrderedEvent ("1620920009","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
  acceptOrderedEvent ("1620920010","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
  acceptOrderedEvent ("1620920011","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);

  // Process all the events on the event queue - all of the above events will simply be ignored.
  Test::service_event_queue();
  

  // This is a separate Auth Job not fundamental to the test
  acceptOrderedEvent ("1620920100","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
  acceptOrderedEvent ("1620920101","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
  acceptOrderedEvent ("1620920102","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
  acceptOrderedEvent ("1620920103","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
  acceptOrderedEvent ("1620920104","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
  acceptOrderedEvent ("1620920105","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
  acceptOrderedEvent ("1620920106","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
  acceptOrderedEvent ("1620920107","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);

  // Process all the events on the event queue
  Test::service_event_queue();
  
  // Fire the timer that waits for alternative branch events on Job_Gamma to start - no branch expected in this test.
  theJob := find_only Job(jobID = "Job_Gamma");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Process all the events on the event queue resulting from the state actions that are executed following the
  // jobEventTimer being fired - this will result in Job_Gamma reaching the 'JobSuccessful' state.
  Test::service_event_queue();
  
  //if (Test::get_scheduled_timers ())'length /= 0 then
  //  Test::fire_scheduled_timers();
  //end if;
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  
  Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 21, "Wrong number of audit events created: " & (theAuditEvents'length)'image);

  for theJob in theJobs loop
    if theJob.jobID = "Job_Alpha" then
      Assertions::assertTrue(theJob.jobCompleted = false, "Job is erroneously completed - jobID " & theJob.jobID);
    else
      Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
      Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
    end if;
    //Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed though an invariant was attached to the wrong audit event: " & theJob.jobID);
  end loop;
  
  // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
  theJobs := find Job();
  for theJob in theJobs loop
    Test::fire_timer(theJob.jobDeletionTimer);
  end loop;
  
  // Service the event queue again to process any events placed on queue resulting from  
  // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
  Test::service_event_queue();
  
  //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
  theJobs := find Job();
  theSequences := find Sequence();
  theAuditEvents := find SequencedAuditEvent();
  
  Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
  // 
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '153562dd-10ae-4132-b8d5-f1851efcaee6' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test23NormalUserExtraJobInvariant () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;
theUserInvariants : set of instance of TransientInvariant;
theSourceInvariants : set of instance of PersistedInvariant;
previousEvents : sequence of string;
empty : sequence of string;
logMessage : string;

thePersistedInvariants : set of instance of PersistedInvariant;
thePersistedInvariant : instance of PersistedInvariant;
theExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;

begin
  // This test initially creates 1 Auth Job with 2 persistentinvariant values being defined
  // This part of the test does not reveal any erroneous behaviour of the twin
  //
  previousEvents := empty;
  //theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent987654321");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920000","EAuthoriserSendOrderRequest","Job_PersistentInvariant",previousEvents,"Ev1201",theAuditEventData);
  previousEvents := ("Ev1201");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","EAuthReceiveRequest","Job_PersistentInvariant",previousEvents,"Ev1202",theAuditEventData);
  previousEvents := ("Ev1202");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920002","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1203",theAuditEventData);
  previousEvents := ("Ev1203");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920003","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1204",theAuditEventData);
  previousEvents := ("Ev1204");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920004","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1205",theAuditEventData);
  previousEvents := ("Ev1205");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1206",theAuditEventData);
  previousEvents := ("Ev1206");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920006","EAuthSendResponse","Job_PersistentInvariant",previousEvents,"Ev1207",theAuditEventData);
  previousEvents := ("Ev1207");
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920007","EAuthoriserReceiveOrder","Job_PersistentInvariant",previousEvents,"Ev1208",theAuditEventData);
 
  //
  Test::service_event_queue();
  theJob := find_only Job(jobID = "Job_PersistentInvariant");
  Test::fire_timer(theJob.jobEventTimer);
  
  
  // It then deletes the Job that created the PersistentInvariant values but retains the persistentinvariant values as PersistedInvariants
  
  deleteJob ("Job_PersistentInvariant");
  theSourceInvariants := find PersistedInvariant(inForce = true);
  Assertions::assertTrue(theSourceInvariants'length = 1, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
  
  
  // This test test that the persistentinvariant can be used ok using 1 Job with 3 sequences and all events are in the standard default order
  // 3 of the events refer to the persistentinvariant value and all must match to pass the extra job invariant check
  // This test does not reveal any erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920000","ENearInput","Job_PersistentInvariant_Use","","Ev1",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","ENearPartWrite","Job_PersistentInvariant_Use","Ev1","Ev2",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920002","ENearJustificationWrite","Job_PersistentInvariant_Use","Ev2","Ev3",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920003","EAgentRequestWidgets","Job_PersistentInvariant_Use","Ev3","Ev4",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920004","EAuthoriserReadWidgetRequest","Job_PersistentInvariant_Use","Ev4","Ev5",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","EAuthoriserParsedJustification","Job_PersistentInvariant_Use","Ev5","Ev6",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920006","EAuthoriserSendWidgets","Job_PersistentInvariant_Use","Ev6","Ev7",theAuditEventData);
  
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920007","EAgentReceiveWidgets","Job_PersistentInvariant_Use","Ev7","Ev8",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920008","EAgentPartRead","Job_PersistentInvariant_Use","Ev8","Ev9",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920008","EAgentProcessedRequest","Job_PersistentInvariant_Use","Ev8","Ev9a",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920009","EAgentWritePayload","Job_PersistentInvariant_Use","Ev9","Ev10",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920010","EGatewayReadPayload","Job_PersistentInvariant_Use","Ev10","Ev11",theAuditEventData);
  
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920011","EGatewayWritePayload","Job_PersistentInvariant_Use","Ev11","Ev12",theAuditEventData);
  
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920012","EMidProcessPayload","Job_PersistentInvariant_Use","","Ev13",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920013","EMidWritePayload","Job_PersistentInvariant_Use","Ev13","Ev14",theAuditEventData);
  
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920050","EFarInput","Job_PersistentInvariant_Use","","Ev50",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920055","EFarOutput","Job_PersistentInvariant_Use","Ev50","Ev55",theAuditEventData);
  //
  //
  Test::service_event_queue();
  
  theJob := find_only Job(jobID = "Job_PersistentInvariant_Use");
  Test::fire_timer(theJob.jobEventTimer);

  Test::service_event_queue();
  
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  theUserInvariants := theAuditEvents -> R23;
  theSourceInvariants := find PersistedInvariant(inForce = true);
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 3, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 17, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  Assertions::assertTrue(theUserInvariants'length = 3, "Wrong number of user invariants created: " & (theUserInvariants'length)'image);
  Assertions::assertTrue(theSourceInvariants'length = 1, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
  for eachJob in theJobs loop
    Assertions::assertTrue(eachJob.jobCompleted, "Job is incomplete: " & eachJob.jobID);
    Assertions::assertTrue(eachJob.sequencingFailed = false, "Sequencing has failed: " & eachJob.jobID);
  end loop; 
  
  // ... and finally clear down all the existing instances of PersistedInvariant in readiness for other tests.
  thePersistedInvariants := find PersistedInvariant();
  for thePersistedInvariant in thePersistedInvariants loop
    thePersistedInvariant.deletePersistedInvariant();   
  end loop; 
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'fecc3bca-1730-4e2a-af31-d689ade51935' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test24MultipleInForcePersistentInvariant () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;
theUserInvariants : set of instance of TransientInvariant;
theSourceInvariants : set of instance of PersistedInvariant;
previousEvents : sequence of string;
empty : sequence of string;
logMessage : string;

thePersistedInvariants : set of instance of PersistedInvariant;
thePersistedInvariant : instance of PersistedInvariant;
theExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;

begin
  // This test initially creates 1 Auth Job with 1 persistentinvariant value being defined
  // This part of the test does not reveal any erroneous behaviour of the twin
  //
  previousEvents := empty;
  //theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent987654321");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920000","EAuthoriserSendOrderRequest","Job_PersistentInvariant_1",previousEvents,"Ev1201",theAuditEventData);
  previousEvents := ("Ev1201");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","EAuthReceiveRequest","Job_PersistentInvariant_1",previousEvents,"Ev1202",theAuditEventData);
  previousEvents := ("Ev1202");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920002","EAuthSendMidRequest","Job_PersistentInvariant_1",previousEvents,"Ev1203",theAuditEventData);
  previousEvents := ("Ev1203");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920003","EAuthReceiveMidResponse","Job_PersistentInvariant_1",previousEvents,"Ev1204",theAuditEventData);
  previousEvents := ("Ev1204");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920004","EAuthSendMidRequest","Job_PersistentInvariant_1",previousEvents,"Ev1205",theAuditEventData);
  previousEvents := ("Ev1205");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","EAuthReceiveMidResponse","Job_PersistentInvariant_1",previousEvents,"Ev1206",theAuditEventData);
  previousEvents := ("Ev1206");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920006","EAuthSendResponse","Job_PersistentInvariant_1",previousEvents,"Ev1207",theAuditEventData);
  previousEvents := ("Ev1207");
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920007","EAuthoriserReceiveOrder","Job_PersistentInvariant_1",previousEvents,"Ev1208",theAuditEventData);
 
  //
  Test::service_event_queue();
  theJob := find_only Job(jobID = "Job_PersistentInvariant_1");
  Test::fire_timer(theJob.jobEventTimer);
  
  
  // It then deletes the Job that created the PersistentInvariant values but retains the persistentinvariant values as PersistedInvariants
  
  deleteJob ("Job_PersistentInvariant_1");
  theSourceInvariants := find PersistedInvariant(inForce = true);
  Assertions::assertTrue(theSourceInvariants'length = 1, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
  
 // This test now creates a second Auth Job with the same named persistentinvariant value being defined though with a different value
  // This part of the test does not reveal any erroneous behaviour of the twin
  //
  previousEvents := empty;
  //theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent999999999");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620930000","EAuthoriserSendOrderRequest","Job_PersistentInvariant_2",previousEvents,"Ev1201",theAuditEventData);
  previousEvents := ("Ev1201");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620930001","EAuthReceiveRequest","Job_PersistentInvariant_2",previousEvents,"Ev1202",theAuditEventData);
  previousEvents := ("Ev1202");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620930002","EAuthSendMidRequest","Job_PersistentInvariant_2",previousEvents,"Ev1203",theAuditEventData);
  previousEvents := ("Ev1203");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620930003","EAuthReceiveMidResponse","Job_PersistentInvariant_2",previousEvents,"Ev1204",theAuditEventData);
  previousEvents := ("Ev1204");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620930004","EAuthSendMidRequest","Job_PersistentInvariant_2",previousEvents,"Ev1205",theAuditEventData);
  previousEvents := ("Ev1205");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620930005","EAuthReceiveMidResponse","Job_PersistentInvariant_2",previousEvents,"Ev1206",theAuditEventData);
  previousEvents := ("Ev1206");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620930006","EAuthSendResponse","Job_PersistentInvariant_2",previousEvents,"Ev1207",theAuditEventData);
  previousEvents := ("Ev1207");
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent333333333");
  acceptOrderedEvent ("1620930007","EAuthoriserReceiveOrder","Job_PersistentInvariant_2",previousEvents,"Ev1208",theAuditEventData);
 
  //
  Test::service_event_queue();
  theJob := find_only Job(jobID = "Job_PersistentInvariant_2");
  Test::fire_timer(theJob.jobEventTimer);
  
  
  // It then deletes the Job that created the PersistentInvariant values but retains the persistentinvariant values as PersistedInvariants
  
  deleteJob ("Job_PersistentInvariant_2");
  theSourceInvariants := find PersistedInvariant(inForce = true);
  Assertions::assertTrue(theSourceInvariants'length = 2, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
  
  
  // This test has set up the situation where there are 2 instances of PersistedInvariant with the same name in force at the same time
  // They have different values and the test will pass if the provided data matches either one of the values
  // 1 of the events refers to one and 2 events refer to the other persistentinvariant value and all must match a valid persistentinvariant value to pass the extra job invariant check
  // This test does not reveal any erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920000","ENearInput","Job_PersistentInvariant_Use","","Ev1",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","ENearPartWrite","Job_PersistentInvariant_Use","Ev1","Ev2",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920002","ENearJustificationWrite","Job_PersistentInvariant_Use","Ev2","Ev3",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920003","EAgentRequestWidgets","Job_PersistentInvariant_Use","Ev3","Ev4",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920004","EAuthoriserReadWidgetRequest","Job_PersistentInvariant_Use","Ev4","Ev5",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","EAuthoriserParsedJustification","Job_PersistentInvariant_Use","Ev5","Ev6",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920006","EAuthoriserSendWidgets","Job_PersistentInvariant_Use","Ev6","Ev7",theAuditEventData);
  
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent333333333");
  acceptOrderedEvent ("1620920007","EAgentReceiveWidgets","Job_PersistentInvariant_Use","Ev7","Ev8",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920008","EAgentPartRead","Job_PersistentInvariant_Use","Ev8","Ev9",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920008","EAgentProcessedRequest","Job_PersistentInvariant_Use","Ev8","Ev9a",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920009","EAgentWritePayload","Job_PersistentInvariant_Use","Ev9","Ev10",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920010","EGatewayReadPayload","Job_PersistentInvariant_Use","Ev10","Ev11",theAuditEventData);
  
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent333333333");
  acceptOrderedEvent ("1620920011","EGatewayWritePayload","Job_PersistentInvariant_Use","Ev11","Ev12",theAuditEventData);
  
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920012","EMidProcessPayload","Job_PersistentInvariant_Use","","Ev13",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920013","EMidWritePayload","Job_PersistentInvariant_Use","Ev13","Ev14",theAuditEventData);
  
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920050","EFarInput","Job_PersistentInvariant_Use","","Ev50",theAuditEventData);
  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920055","EFarOutput","Job_PersistentInvariant_Use","Ev50","Ev55",theAuditEventData);
  //
  //
  Test::service_event_queue();
  
  theJob := find_only Job(jobID = "Job_PersistentInvariant_Use");
  Test::fire_timer(theJob.jobEventTimer);

  Test::service_event_queue();
  
  theJobs := find Job ();
  theSequences := theJobs -> R10;
  theAuditEvents := theSequences -> R11;
  theUserInvariants := theAuditEvents -> R23;
  theSourceInvariants := find PersistedInvariant(inForce = true);
  //
  Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
  Assertions::assertTrue(theSequences'length = 3, "Wrong number of sequences created: " & (theSequences'length)'image);
  Assertions::assertTrue(theAuditEvents'length = 17, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
  Assertions::assertTrue(theUserInvariants'length = 3, "Wrong number of user invariants created: " & (theUserInvariants'length)'image);
  Assertions::assertTrue(theSourceInvariants'length = 2, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
  for eachJob in theJobs loop
    Assertions::assertTrue(eachJob.jobCompleted, "Job is incomplete: " & eachJob.jobID);
    Assertions::assertTrue(eachJob.sequencingFailed = false, "Sequencing has failed: " & eachJob.jobID);
  end loop; 
  
  // ... and finally clear down all the existing instances of PersistedInvariant in readiness for other tests.
  thePersistedInvariants := find PersistedInvariant();
  for thePersistedInvariant in thePersistedInvariants loop
    thePersistedInvariant.deletePersistedInvariant();   
  end loop; 
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '250aa823-3436-4913-a5f8-eea5a8cb10f1' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test58InvalidUserExtraJobInvariant () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;
theUserInvariants : set of instance of TransientInvariant;
theSourceInvariants : set of instance of PersistedInvariant;
previousEvents : sequence of string;
empty : sequence of string;
thePersistedInvariants : set of instance of PersistedInvariant;
thePersistedInvariant : instance of PersistedInvariant;
logMessage : string;

begin
  // NOTE THIS TEST CREATES THE PERSISTED INVARIANTS THAT OTHER FOLLOWING TESTS USE

  // This test initially creates 1 Auth Job with 2 persistentinvariant values being defined
  // This part of the test does not reveal any erroneous behaviour of the twin
  //
  previousEvents := empty;
  //theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent987654321");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920000","EAuthoriserSendOrderRequest","Job_PersistentInvariant",previousEvents,"Ev1201",theAuditEventData);
  previousEvents := ("Ev1201");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","EAuthReceiveRequest","Job_PersistentInvariant",previousEvents,"Ev1202",theAuditEventData);
  previousEvents := ("Ev1202");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920002","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1203",theAuditEventData);
  previousEvents := ("Ev1203");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920003","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1204",theAuditEventData);
  previousEvents := ("Ev1204");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920004","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1205",theAuditEventData);
  previousEvents := ("Ev1205");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1206",theAuditEventData);
  previousEvents := ("Ev1206");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920006","EAuthSendResponse","Job_PersistentInvariant",previousEvents,"Ev1207",theAuditEventData);
  previousEvents := ("Ev1207");
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920007","EAuthoriserReceiveOrder","Job_PersistentInvariant",previousEvents,"Ev1208",theAuditEventData);
 
  //
  Test::service_event_queue();
  theJob := find_only Job(jobID = "Job_PersistentInvariant");
  Test::fire_timer(theJob.jobEventTimer);
  
  
  // It then deletes the Job that created the PersistentInvariant values but retains the persistentinvariant values as PersistedInvariants
  deleteJob ("Job_PersistentInvariant");
  theSourceInvariants := find PersistedInvariant(inForce = true);
  Assertions::assertTrue(theSourceInvariants'length = 1, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
  
  
  // This test tests that invalid persistentinvariant is spotted and the Job fails
  // One value of persistentinvariant is incorrect
  // This test does reveal any erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920000","ENearInput","Job_PersistentInvariant_Use","","Ev1",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","ENearPartWrite","Job_PersistentInvariant_Use","Ev1","Ev2",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920002","ENearJustificationWrite","Job_PersistentInvariant_Use","Ev2","Ev3",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920003","EAgentRequestWidgets","Job_PersistentInvariant_Use","Ev3","Ev4",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920004","EAuthoriserReadWidgetRequest","Job_PersistentInvariant_Use","Ev4","Ev5",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","EAuthoriserParsedJustification","Job_PersistentInvariant_Use","Ev5","Ev6",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920006","EAuthoriserSendWidgets","Job_PersistentInvariant_Use","Ev6","Ev7",theAuditEventData);
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920007","EAgentReceiveWidgets","Job_PersistentInvariant_Use","Ev7","Ev8",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920008","EAgentPartRead","Job_PersistentInvariant_Use","Ev8","Ev9",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920008","EAgentProcessedRequest","Job_PersistentInvariant_Use","Ev8","Ev9a",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920009","EAgentWritePayload","Job_PersistentInvariant_Use","Ev9","Ev10",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920010","EGatewayReadPayload","Job_PersistentInvariant_Use","Ev10","Ev11",theAuditEventData);
  
  // Error here: The following audit event is expecting persistentinvariant but the persistentinvariant provided is of the wrong value
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent2222222222");
  acceptOrderedEvent ("1620920011","EGatewayWritePayload","Job_PersistentInvariant_Use","Ev11","Ev12",theAuditEventData);
  
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920012","EMidProcessPayload","Job_PersistentInvariant_Use","","Ev13",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920013","EMidWritePayload","Job_PersistentInvariant_Use","Ev13","Ev14",theAuditEventData);
  
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920050","EFarInput","Job_PersistentInvariant_Use","","Ev50",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920055","EFarOutput","Job_PersistentInvariant_Use","Ev50","Ev55",theAuditEventData);
//
  //
  Test::service_event_queue();
  
  theJob := find_only Job(jobID = "Job_PersistentInvariant_Use");
  Test::fire_timer(theJob.jobEventTimer);

  Test::service_event_queue();
  
  //theJobs := find Job ();
  //theSequences := theJobs -> R10;
  //theAuditEvents := theSequences -> R11;
  //theUserInvariants := theAuditEvents -> R23;
  //theSourceInvariants := find PersistedInvariant(inForce = true);
  
  // Check the Job has failed
  Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed though the extra job invariant was invalid: " & theJob.jobID);
  
  // ... and finally clear down all the existing instances of PersistedInvariant in readiness for other tests.
  thePersistedInvariants := find PersistedInvariant();
  for thePersistedInvariant in thePersistedInvariants loop
    thePersistedInvariant.deletePersistedInvariant();   
  end loop;
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '67095f83-0266-47ab-95f6-4a735a36e826' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test59InvalidUserExtraJobInvariant () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;
//theUserInvariants : set of instance of TransientInvariant;
theSourceInvariants : set of instance of PersistedInvariant;
theCorrespondingSourceInvariants : set of instance of PersistedInvariant;
eachCorrespondingSourceInvariant : instance of PersistedInvariant;
previousEvents : sequence of string;
empty : sequence of string;
thePersistedInvariants : set of instance of PersistedInvariant;
thePersistedInvariant : instance of PersistedInvariant;
logMessage : string;

begin
  // This test initially creates 1 Auth Job with 2 persistentinvariant values being defined
  // This part of the test does not reveal any erroneous behaviour of the twin
  //
  previousEvents := empty;
  //theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent987654321");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920000","EAuthoriserSendOrderRequest","Job_PersistentInvariant",previousEvents,"Ev1201",theAuditEventData);
  previousEvents := ("Ev1201");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","EAuthReceiveRequest","Job_PersistentInvariant",previousEvents,"Ev1202",theAuditEventData);
  previousEvents := ("Ev1202");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920002","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1203",theAuditEventData);
  previousEvents := ("Ev1203");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920003","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1204",theAuditEventData);
  previousEvents := ("Ev1204");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920004","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1205",theAuditEventData);
  previousEvents := ("Ev1205");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1206",theAuditEventData);
  previousEvents := ("Ev1206");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920006","EAuthSendResponse","Job_PersistentInvariant",previousEvents,"Ev1207",theAuditEventData);
  previousEvents := ("Ev1207");
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920007","EAuthoriserReceiveOrder","Job_PersistentInvariant",previousEvents,"Ev1208",theAuditEventData);
 
  // Process all the events on the event queue - at this point in the test Job_PersistentInvariant should 
  // have reached the 'AssessingSequenceCompletion' state
  Test::service_event_queue();
  
  // Fire the timer that waits for alternative branch events on Job_PersistentInvariant to arrive - and the job will proceed to constraint and 
  // invariant checking where it will pass all the invariant checks and proceed into the 'JobSuccessful' state.
  theJob := find_only Job(jobID = "Job_PersistentInvariant");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Delete the Job that created the PersistentInvariant values but retain the persistentinvariant values as PersistedInvariants
  deleteJob ("Job_PersistentInvariant");
 
  // Check that the Persisted Invariants are still present and in force
  theSourceInvariants := find PersistedInvariant(inForce = true);   
  Assertions::assertTrue(theSourceInvariants'length = 1, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
  
  // With the PersistentInvariants now in place, this test now goes on to check that valid persistentinvariant attached to the wrong event is spotted and the Job fails.
  // One value of persistentinvariant is incorrectly attached all the other value are correct and correctly attached
  // This test does reveal erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920000","ENearInput","Job_PersistentInvariant_Use","","Ev1",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","ENearPartWrite","Job_PersistentInvariant_Use","Ev1","Ev2",theAuditEventData);  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920002","ENearJustificationWrite","Job_PersistentInvariant_Use","Ev2","Ev3",theAuditEventData);  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920003","EAgentRequestWidgets","Job_PersistentInvariant_Use","Ev3","Ev4",theAuditEventData); 
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920004","EAuthoriserReadWidgetRequest","Job_PersistentInvariant_Use","Ev4","Ev5",theAuditEventData);  
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","EAuthoriserParsedJustification","Job_PersistentInvariant_Use","Ev5","Ev6",theAuditEventData); 
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920006","EAuthoriserSendWidgets","Job_PersistentInvariant_Use","Ev6","Ev7",theAuditEventData); 
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920007","EAgentReceiveWidgets","Job_PersistentInvariant_Use","Ev7","Ev8",theAuditEventData); 
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920008","EAgentPartRead","Job_PersistentInvariant_Use","Ev8","Ev9",theAuditEventData); 
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920008","EAgentProcessedRequest","Job_PersistentInvariant_Use","Ev8","Ev9a",theAuditEventData); 
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920009","EAgentWritePayload","Job_PersistentInvariant_Use","Ev9","Ev10",theAuditEventData);
  
  // Error here: The following event is not expected to carry persistentinvariant but does so erroneously in this case. The Job should fail.
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920010","EGatewayReadPayload","Job_PersistentInvariant_Use","Ev10","Ev11",theAuditEventData);

  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920011","EGatewayWritePayload","Job_PersistentInvariant_Use","Ev11","Ev12",theAuditEventData);
  // End of Bank Transfer Sequence
  
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920012","EMidProcessPayload","Job_PersistentInvariant_Use","","Ev13",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920013","EMidWritePayload","Job_PersistentInvariant_Use","Ev13","Ev14",theAuditEventData);
  
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920050","EFarInput","Job_PersistentInvariant_Use","","Ev50",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920055","EFarOutput","Job_PersistentInvariant_Use","Ev50","Ev55",theAuditEventData);
//
  // Process all the events on the event queue - note that Job_PersistentInvariant_Use should be in the 'JobFailed' state after this.
  Test::service_event_queue();
 
  // Check the state of Job_PersistentInvariant_Use is as expected
  theJob := find_only Job(jobID = "Job_PersistentInvariant_Use");
  Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed though invariant associated with the wrong event: " & theJob.jobID);

  theCorrespondingSourceInvariants := theJob -> R10 -> R11 -> R23 -> R28 -> R24;
  for eachCorrespondingSourceInvariant in theCorrespondingSourceInvariants loop
    Assertions::assertTrue(eachCorrespondingSourceInvariant.inForce, "Extra Job Invariant is not in force: " & eachCorrespondingSourceInvariant.extraJobInvName);
  end loop;

  // ... and finally clear down all the existing instances of PersistedInvariant in readiness for other tests.
  thePersistedInvariants := find PersistedInvariant();
  for thePersistedInvariant in thePersistedInvariants loop
    thePersistedInvariant.deletePersistedInvariant();   
  end loop;
  
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'dcce6c8e-a740-4902-a5f6-bc3c1651180b' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test60StalePersistedInvariant () is
theJob : instance of Job;
theJobs : set of instance of Job;
theSequences : set of instance of Sequence;
theAuditEvents : set of instance of SequencedAuditEvent;
theAuditEventData : sequence of auditEventDataStructure;
emptyAuditEventData : sequence of auditEventDataStructure;
theUserInvariants : set of instance of TransientInvariant;
thePersistedInvariants : set of instance of PersistedInvariant;
thePersistedInvariant : instance of PersistedInvariant;
theStaleSourceInvariants : set of instance of PersistedInvariant;
theInForceSourceInvariants : set of instance of PersistedInvariant;
theCorrespondingSourceInvariants : set of instance of PersistedInvariant;
previousEvents : sequence of string;
empty : sequence of string;
logMessage : string;

begin
 // This test initially creates 1 Auth Job with 2 persistentinvariant values being defined
  // This part of the test does not reveal any erroneous behaviour of the twin
  //
  previousEvents := empty;
  //theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent987654321");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920000","EAuthoriserSendOrderRequest","Job_PersistentInvariant",previousEvents,"Ev1201",theAuditEventData);
  previousEvents := ("Ev1201");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","EAuthReceiveRequest","Job_PersistentInvariant",previousEvents,"Ev1202",theAuditEventData);
  previousEvents := ("Ev1202");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920002","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1203",theAuditEventData);
  previousEvents := ("Ev1203");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920003","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1204",theAuditEventData);
  previousEvents := ("Ev1204");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920004","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1205",theAuditEventData);
  previousEvents := ("Ev1205");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1206",theAuditEventData);
  previousEvents := ("Ev1206");
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920006","EAuthSendResponse","Job_PersistentInvariant",previousEvents,"Ev1207",theAuditEventData);
  previousEvents := ("Ev1207");
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920007","EAuthoriserReceiveOrder","Job_PersistentInvariant",previousEvents,"Ev1208",theAuditEventData);
 
  // Process all the events on the event queue - at this point in the test Job_PersistentInvariant should 
  // have reached the 'AssessingSequenceCompletion' state
  Test::service_event_queue();
  
  // Fire the timer that waits for alternative branch events on Job_PersistentInvariant to arrive - and the job will proceed to constraint and 
  // invariant checking where it will pass all the invariant checks and proceed into the 'JobSuccessful' state.
  theJob := find_only Job(jobID = "Job_PersistentInvariant");
  Test::fire_timer(theJob.jobEventTimer);
  
  // Delete the Job that created the PersistentInvariant values but retain the persistentinvariant values as PersistedInvariants
  deleteJob ("Job_PersistentInvariant");
 
  // Check that the Persisted Invariants are still present and in force
  theInForceSourceInvariants := find PersistedInvariant(inForce = true);
  Assertions::assertTrue(theInForceSourceInvariants'length = 1, "Wrong number of source invariants in force: " & (theInForceSourceInvariants'length)'image);

  // Force the Persisted Invariants to reach their end of life and go stale
  for eachInForceSourceInvariant in theInForceSourceInvariants loop
    Test::fire_timer(eachInForceSourceInvariant.invariantTimer);
  end loop;  
  Test::service_event_queue();
  
  // Check the Persisted Invariants have gone stale
  theInForceSourceInvariants := find PersistedInvariant(inForce = true);
  Assertions::assertTrue(theInForceSourceInvariants'length = 0, "Wrong number of source invariants have timed out: " & (theInForceSourceInvariants'length)'image);
  theStaleSourceInvariants := find PersistedInvariant(inForce = false);
  Assertions::assertTrue(theStaleSourceInvariants'length = 1, "Wrong number of source invariants have timed out: " & (theStaleSourceInvariants'length)'image);
  
  // With the PersistentInvariants having gone stale now in place, this test now goes on to check that stale persistentinvariant attached to 
  // the correct events is spotted and the Job fails.
  // The following event sequence and persistentinvariant associations are valid. It fails simply because the persistentinvariant is stale and no longer in force
  // This test does reveal erroneous behaviour of the twin
  //
  // Bank Transfer Sequence
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920000","ENearInput","Job_PersistentInvariant_Use","","Ev1",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920001","ENearPartWrite","Job_PersistentInvariant_Use","Ev1","Ev2",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920002","ENearJustificationWrite","Job_PersistentInvariant_Use","Ev2","Ev3",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920003","EAgentRequestWidgets","Job_PersistentInvariant_Use","Ev3","Ev4",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920004","EAuthoriserReadWidgetRequest","Job_PersistentInvariant_Use","Ev4","Ev5",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920005","EAuthoriserParsedJustification","Job_PersistentInvariant_Use","Ev5","Ev6",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920006","EAuthoriserSendWidgets","Job_PersistentInvariant_Use","Ev6","Ev7",theAuditEventData);
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920007","EAgentReceiveWidgets","Job_PersistentInvariant_Use","Ev7","Ev8",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920008","EAgentPartRead","Job_PersistentInvariant_Use","Ev8","Ev9",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920008","EAgentProcessedRequest","Job_PersistentInvariant_Use","Ev8","Ev9a",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920009","EAgentWritePayload","Job_PersistentInvariant_Use","Ev9","Ev10",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920010","EGatewayReadPayload","Job_PersistentInvariant_Use","Ev10","Ev11",theAuditEventData);
  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
  acceptOrderedEvent ("1620920011","EGatewayWritePayload","Job_PersistentInvariant_Use","Ev11","Ev12",theAuditEventData);
  // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920012","EMidProcessPayload","Job_PersistentInvariant_Use","","Ev13",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920013","EMidWritePayload","Job_PersistentInvariant_Use","Ev13","Ev14",theAuditEventData);
  // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920050","EFarInput","Job_PersistentInvariant_Use","","Ev50",theAuditEventData);
  theAuditEventData := emptyAuditEventData;
  acceptOrderedEvent ("1620920055","EFarOutput","Job_PersistentInvariant_Use","Ev50","Ev55",theAuditEventData);

  // Process all the events on the event queue - note that Job_PersistentInvariant_Use should be in the 'AssessingSequenceCompletion' state after this.
  Test::service_event_queue();

  // Fire the timer that waits for other branch events on Job_PersistentInvariant_Use to arrive - and the job will proceed to constraint and 
  // invariant checking where it will fail the invariant checks.
  theJob := find_only Job(jobID = "Job_PersistentInvariant_Use");
  Test::fire_timer(theJob.jobEventTimer);
 
  // Process all the events on the event queue - note that Job_PersistentInvariant_Use should be in the 'JobFailed' state after this because
  // the job will have failed the invariant checks.
  Test::service_event_queue();
  
  // Check the state of Job_PersistentInvariant_Use is as expected and that all Extra Job Invariants that it uses (aka carries) are not 'InForce'.
  Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed though persisted invariant was no longer in force: " & theJob.jobID); 
  theCorrespondingSourceInvariants := theJob -> R10 -> R11 -> R23 -> R28 -> R24;
  for eachCorrespondingSourceInvariant in theCorrespondingSourceInvariants loop
    Assertions::assertTrue(eachCorrespondingSourceInvariant.inForce = false, "Extra Job Invariant is not in force: " & eachCorrespondingSourceInvariant.extraJobInvName);
  end loop;
  
  // ... and finally clear down all the existing instances of PersistedInvariant in readiness for other tests.
  for thePersistedInvariant in thePersistedInvariants loop
    thePersistedInvariant.deletePersistedInvariant();   
  end loop;
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '9d4bf09e-cc24-4ab6-8731-c78313ddf574' DO NOT EDIT THIS LINE.
private service AESequenceDC::Test61CreateJobDefinition () is
previousEventTypes : sequence of eventStructure;
eventDefinition : eventDefinitionStructure;
eventDefinitions : sequence of eventDefinitionStructure;
jobDefn : instance of JobDefinition;
theAuditEventDefs : sequence of instance of SequencedAuditEventDefinition;

begin
  //
  // Job TestJob, Sequence 1 TestTransfer
  // 
  eventDefinition := ("TestTransfer","TestInput",1,previousEventTypes,true,false,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  previousEventTypes := ("TestInput",1,"","");
  eventDefinition := ("TestTransfer","TestWrite",1,previousEventTypes,false,false,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  previousEventTypes := ("TestWrite",1,"","");
  eventDefinition := ("TestTransfer","TestJustificationWrite",1,previousEventTypes,false,false,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  previousEventTypes := ("TestJustificationWrite",1,"","");
  eventDefinition := ("TestTransfer","TestWidgets",1,previousEventTypes,false,false,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  previousEventTypes := ("TestWidgets",1,"","");
  eventDefinition := ("TestTransfer","TestWidgetRequest",1,previousEventTypes,false,false,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  previousEventTypes := ("TestWidgetRequest",1,"","");
  eventDefinition := ("TestTransfer","TestJustification",1,previousEventTypes,false,false,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  previousEventTypes := ("TestJustification",1,"","");
  eventDefinition := ("TestTransfer","TestSendWidgets",1,previousEventTypes,false,false,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  previousEventTypes := ("TestSendWidgets",1,"","");
  eventDefinition := ("TestTransfer","TestReceiveWidgets",1,previousEventTypes,false,false,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  previousEventTypes := ("TestReceiveWidgets",1,"Cons1","AND");
  eventDefinition := ("TestTransfer","TestProcessedRequest",1,previousEventTypes,false,true,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  previousEventTypes := ("TestProcessedRequest",1,"Cons1","AND");
  eventDefinition := ("TestTransfer","TestRead",1,previousEventTypes,false,false,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  previousEventTypes := ("TestRead",1,"","");
  eventDefinition := ("TestTransfer","TestWritePayload",1,previousEventTypes,false,false,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  previousEventTypes := ("TestWritePayload",1,"","");
  eventDefinition := ("TestTransfer","TestReadPayload",1,previousEventTypes,false,false,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  previousEventTypes := ("TestReadPayload",1,"","");
  eventDefinition := ("TestTransfer","TestGatewayWrite",1,previousEventTypes,false,true,false);
  eventDefinitions := eventDefinitions & eventDefinition;
  
  AESequenceDC::createJobDefinition("TestJob", eventDefinitions);


  jobDefn := find_one JobDefinition (jobName = "TestJob");
  theAuditEventDefs := jobDefn -> R7.AESequenceDefinition -> R1.SequencedAuditEventDefinition;
  Assertions::assertTrue(jobDefn /= null, "Job definition not created - jobName : testJob");
  Assertions::assertTrue(theAuditEventDefs'length = 13, "Wrong number of event definitions created: " & (theAuditEventDefs'length)'image);



//
//
//
//
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

