// BP 7.1.6 content: Package syschar: 3 persistence-version: 7.1.6

within SequenceVerificationDataCentric::SVDCdomain::AESequenceDC is

  package test_cases is
    @function_num(1);
    function Test01NormalPath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
        // This test does not reveal any erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      //
        Test::service_event_queue();
      //
        // Auth Job with single sequence but repeating event types
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(2);
    function Test02NormalPath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers one Job with the same 3 sequences as NormalPathTest01 but with the sequences in the opposite order.
        // This test does not reveal any erroneous behaviour of the twin
        //
        // Far Side Sequence
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
        // Mid Sequence
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        //
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theJob := theJobs'any;
        theSequences := theJob -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 3, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 17, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete");
        Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed");
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test03NormalPath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers one Job with 3 sequences and the events for a given sequence are in the correct order
        // but the events of different sequences are interleaved
        // This test does not reveal any erroneous behaviour of the twin
        //
        // Bank Transfer Sequence starts here
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        // Far side Sequence starts here
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        // Mid Sequence starts here
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        // Mid sequence ends here
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        // Far side sequence ends here
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        // This next event is an end point which occurs before the branch has been seen so is a potential error condition
        // The Job should not complete at this point despite an end point in all 3 sequences being reached
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        // This is the only event on the other branch and in this case it completes the Job
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theJob := theJobs'any;
        theSequences := theJob -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 3, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 17, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete");
        Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed");
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test04NormalCyclicPath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Jobs with 1 sequences based on a looped path definition - no iterations of the loop
        // This test does not reveal any erroneous behaviour of the twin
        //
        acceptOrderedEvent ("1620920000","Test-0001","A","Job_Cyclo","","Ev301",theAuditEventData);
        acceptOrderedEvent ("1620920001","Test-0001","B","Job_Cyclo","Ev301","Ev302",theAuditEventData);
        acceptOrderedEvent ("1620920002","Test-0001","C","Job_Cyclo","Ev302","Ev303",theAuditEventData);
        acceptOrderedEvent ("1620920003","Test-0001","D","Job_Cyclo","Ev303","Ev304",theAuditEventData);
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 4, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test05NormalCyclicPath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Jobs with 1 sequences based on a looped path definition - 1 iteration of the loop
        // This test does not reveal any erroneous behaviour of the twin
        //
        acceptOrderedEvent ("1620920000","Test-0001","A","Job_Cyclo","","Ev301",theAuditEventData);
        acceptOrderedEvent ("1620920001","Test-0001","B","Job_Cyclo","Ev301","Ev302",theAuditEventData);
        acceptOrderedEvent ("1620920002","Test-0001","C","Job_Cyclo","Ev302","Ev303",theAuditEventData);
        acceptOrderedEvent ("1620920003","Test-0001","B","Job_Cyclo","Ev303","Ev304",theAuditEventData);
        acceptOrderedEvent ("1620920004","Test-0001","C","Job_Cyclo","Ev304","Ev305",theAuditEventData);
        acceptOrderedEvent ("1620920005","Test-0001","D","Job_Cyclo","Ev305","Ev306",theAuditEventData);
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 6, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test06NormalCyclicPath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Jobs with 1 sequences based on a looped path definition - 2 iterations of the loop
        // This test does not reveal any erroneous behaviour of the twin
        //
        acceptOrderedEvent ("1620920000","Test-0001","A","Job_Cyclo","","Ev301",theAuditEventData);
        acceptOrderedEvent ("1620920001","Test-0001","B","Job_Cyclo","Ev301","Ev302",theAuditEventData);
        acceptOrderedEvent ("1620920002","Test-0001","C","Job_Cyclo","Ev302","Ev303",theAuditEventData);
        acceptOrderedEvent ("1620920003","Test-0001","B","Job_Cyclo","Ev303","Ev304",theAuditEventData);
        acceptOrderedEvent ("1620920004","Test-0001","C","Job_Cyclo","Ev304","Ev305",theAuditEventData);
        acceptOrderedEvent ("1620920005","Test-0001","B","Job_Cyclo","Ev305","Ev306",theAuditEventData);
        acceptOrderedEvent ("1620920006","Test-0001","C","Job_Cyclo","Ev306","Ev307",theAuditEventData);
        acceptOrderedEvent ("1620920007","Test-0001","D","Job_Cyclo","Ev307","Ev308",theAuditEventData);
      
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 8, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test07NormalCyclicPath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Jobs with 1 sequences based on a looped path definition - 7 iterations of the loop
        // This test does not reveal any erroneous behaviour of the twin
        //
        acceptOrderedEvent ("1620920000","Test-0001","A","Job_Cyclo","","Ev301",theAuditEventData);
        acceptOrderedEvent ("1620920001","Test-0001","B","Job_Cyclo","Ev301","Ev302",theAuditEventData);
        acceptOrderedEvent ("1620920002","Test-0001","C","Job_Cyclo","Ev302","Ev303",theAuditEventData);
        acceptOrderedEvent ("1620920003","Test-0001","B","Job_Cyclo","Ev303","Ev304",theAuditEventData);
        acceptOrderedEvent ("1620920004","Test-0001","C","Job_Cyclo","Ev304","Ev305",theAuditEventData);
        acceptOrderedEvent ("1620920005","Test-0001","B","Job_Cyclo","Ev305","Ev306",theAuditEventData);
        acceptOrderedEvent ("1620920006","Test-0001","C","Job_Cyclo","Ev306","Ev307",theAuditEventData);
        acceptOrderedEvent ("1620920007","Test-0001","B","Job_Cyclo","Ev307","Ev308",theAuditEventData);
        acceptOrderedEvent ("1620920008","Test-0001","C","Job_Cyclo","Ev308","Ev309",theAuditEventData);
        acceptOrderedEvent ("1620920009","Test-0001","B","Job_Cyclo","Ev309","Ev310",theAuditEventData);
        acceptOrderedEvent ("1620920010","Test-0001","C","Job_Cyclo","Ev310","Ev311",theAuditEventData);
        acceptOrderedEvent ("1620920011","Test-0001","B","Job_Cyclo","Ev311","Ev312",theAuditEventData);
        acceptOrderedEvent ("1620920012","Test-0001","C","Job_Cyclo","Ev312","Ev313",theAuditEventData);
        acceptOrderedEvent ("1620920013","Test-0001","B","Job_Cyclo","Ev313","Ev314",theAuditEventData);
        acceptOrderedEvent ("1620920014","Test-0001","C","Job_Cyclo","Ev314","Ev315",theAuditEventData);
        acceptOrderedEvent ("1620920015","Test-0001","B","Job_Cyclo","Ev315","Ev316",theAuditEventData);
        acceptOrderedEvent ("1620920016","Test-0001","C","Job_Cyclo","Ev316","Ev317",theAuditEventData);
        acceptOrderedEvent ("1620920017","Test-0001","D","Job_Cyclo","Ev317","Ev318",theAuditEventData);
      
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 18, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test08NormalPath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 2 Jobs with 4 sequences and the BankTransfer Sequence occurs last in the first Job with
        // the AgentProcessedRequest event (an end event) occurring before any event on the other side of the fork
        // is seen. This will test that the job is not prematurely marked as complete.
        // This test does not reveal any erroneous behaviour of the twin
        //
        // Normal Mid sequence starts here
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Normal Far Side sequence starts here
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
        // Near side sequence starts here
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        // The following event is an end point event which occurs here before the branch is obvious
        // This tests the system does not prematurely indicate Job Complete
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        //...and then back to the events in the 'main' branch in the sequence.
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
      
        // Process all the events on the event queue
        Test::service_event_queue();
        
        // Fire the timer that waits for optional branch events on Job_Alpha to start - no branch expected in this test
        theJob := find_only Job(jobID = "Job_Alpha");
        Test::fire_timer(theJob.jobEventTimer);
       
        // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
        // the jobEventTimer for Job_Alpha being fired.
        Test::service_event_queue();
        
        
        // This is a separate Auth Job not fundamental to the test
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
        
        // Process all the events on the event queue
        Test::service_event_queue();
        
        // Fire the timer that waits for optional branch events on Job_Gamma to start - no branch expected in this test
        theJob := find_only Job(jobID = "Job_Gamma");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
        // the jobEventTimer for Job_Gamma being fired. 
        Test::service_event_queue();
        
        // Check that the 2 jobs are as expected.
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        
        Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = true, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;
        
        // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
        theJobs := find Job();
        for theJob in theJobs loop
          Test::fire_timer(theJob.jobDeletionTimer);
        end loop;
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test09CorrectDeletionOfDefinitions() is
      @noparse
      theJobDef : instance of JobDefinition;
      theJobDefs : set of instance of JobDefinition;
      theSeqDefs : set of instance of AESequenceDefinition;
      theAEDefs : set of instance of AuditEventDefinition;
      theAEInSeqDefs : set of instance of AEInSequenceDefinition;
      theAEOccInSeqDefs : set of instance of AEOccurrenceInSequenceDefinition;
      theAEOccPairDefs : set of instance of AEInSequencePairDefn;
      
      begin
        // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
        // This test does not reveal any erroneous behaviour of the twin
        //
        theJobDefs := find JobDefinition();
        for theJobDef in theJobDefs loop
          deprecateJobDefinition(theJobDef.jobName);
        end loop;  
        //
        Test::service_event_queue();
        
        //Fire the timers to ensure that all the deprecated JoBDefinitions delete themselves
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if;
        
        Test::service_event_queue();
         
        theJobDefs := find JobDefinition();
        theSeqDefs := find AESequenceDefinition();
        theAEDefs := find AuditEventDefinition();
        theAEInSeqDefs := find AEInSequenceDefinition();
        theAEOccInSeqDefs := find AEOccurrenceInSequenceDefinition();
        theAEOccPairDefs := find AEInSequencePairDefn();
        
        Assertions::assertTrue(theJobDefs'length = 0, "Some Job Definitions remaining: " & (theJobDefs'length)'image);
        Assertions::assertTrue(theSeqDefs'length = 0, "Some Sequence Definitions remaining: " & (theSeqDefs'length)'image);
        Assertions::assertTrue(theAEDefs'length = 0, "Some Audit Event Definitions remaining: " & (theAEDefs'length)'image);
        Assertions::assertTrue(theAEInSeqDefs'length = 0, "Some Audit Event in Sequence Definitions remaining: " & (theAEInSeqDefs'length)'image);
        Assertions::assertTrue(theAEOccInSeqDefs'length = 0, "Some Audit Event Occurrences in Sequence Definitions remaining: " & (theAEOccInSeqDefs'length)'image);
        Assertions::assertTrue(theAEOccPairDefs'length = 0, "Some Audit Event in Sequence Pair Definitions remaining: " & (theAEOccPairDefs'length)'image);
      //  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test10NormalPath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
        // The JobComplete interaction from AEOrdering is received as expected after event processing has finished
        // This test does not reveal any erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      
        // Process all the events on the event queue
        Test::service_event_queue();
        
        // Job_Alpha should be in the 'AssessingSequenceCompletion' state at this point in the test so fire the timer that is waiting for 
        // late arrival of optional branch events on Job_Alpha to arrive - no further optional branches are expected in this test.
        theJob := find_only Job(jobID = "Job_Alpha");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
        // the jobEventTimer for Job_Alpha being fired - note that Job_Alpha should be in the 'JobSuccessful' after this.
        Test::service_event_queue();
        
        // Invoke interaction from AEOrdering called jobComplete which is interpreted as Job Timeout in this domain
        jobComplete ("Job_Alpha");
         
        // Service the event queue to process the 'jobTimeOut' event directed at Job_Alpha - this event will be ignored.
        Test::service_event_queue();
       
       
        // Auth Job with single sequence but repeating event types
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
          
        // Process all the events on the event queue
        Test::service_event_queue();
        
        // Job_Gamma should be in the 'AssessingSequenceCompletion' state at this point in the test so fire the timer that is waiting for 
        // late arrival of optional branch events on Job_Gamma to arrive - no further optional branches are expected in this test.
        theJob := find_only Job(jobID = "Job_Gamma");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
        // the jobEventTimer for Job_Gamma being fired - note that Job_Gamma should be in the 'JobSuccessful' after this.
        Test::service_event_queue();
        
        // Invoke interaction from AEOrdering called JobComplete which is interpreted as Job Timeout in this domain
        jobComplete ("Job_Gamma");
        
        // Service the event queue to process the 'jobTimeOut' event directed at Job_Gamma this event will be ignored.
        Test::service_event_queue();
        
        // Check that the jobs (Job_Alpha & Job_Gamma) and their associated sequences and events are in an expected state. 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;
        
        // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
        theJobs := find Job();
        for theJob in theJobs loop
          Test::fire_timer(theJob.jobDeletionTimer);
        end loop;
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test11NormalPath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 2 Jobs with 4 sequences and the BankTransfer Sequence occurs last in the first Job with
        // the AgentProcessedRequest event (an end event) occurring before any event on the other side of the fork
        // is seen. This will test that the job is not prematurely marked as complete.
        // This test does not reveal any erroneous behaviour of the twin
        //
        // Normal Mid sequence starts here
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Normal Far Side sequence starts here
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
        // Near side sequence starts here
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        // The following event is an end point event which occurs here before the branch is obvious
        // This tests the system does not prematurely indicate Job Complete
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
      
        // Process all the events on the event queue
        Test::service_event_queue();
        
        // Job_Alpha should be in the 'AssessingSequenceCompletion' state at this point in the test so fire the timer that is waiting for 
        // late arrival of optional branch events on Job_Alpha to arrive - no further optional branches are expected in this test.
        theJob := find_only Job(jobID = "Job_Alpha");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
        // the jobEventTimer for Job_Alpha being fired - note that Job_Alpha should be in the 'JobSuccessful' after this.
        Test::service_event_queue();
        
        // Invoke interaction from AEOrdering called jobComplete which is interpreted as Job Timeout in this domain
        jobComplete ("Job_Alpha");
         
        // Service the event queue to process the 'jobTimeOut' event directed at Job_Alpha - this event will be ignored.
        Test::service_event_queue();
      
      
        // This is a separate Auth Job not fundamental to the test
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
        
      
        // Process all the events on the event queue
        Test::service_event_queue();
        
        // Job_Gamma should be in the 'AssessingSequenceCompletion' state at this point in the test so fire the timer that is waiting for 
        // late arrival of optional branch events on Job_Gamma to arrive - no further optional branches are expected in this test.
        theJob := find_only Job(jobID = "Job_Gamma");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
        // the jobEventTimer for Job_Gamma being fired - note that Job_Gamma should be in the 'JobSuccessful' after this.
        Test::service_event_queue();
        
        // Invoke interaction from AEOrdering called JobComplete which is interpreted as Job Timeout in this domain
        jobComplete ("Job_Gamma");
        
        // Service the event queue to process the 'jobTimeOut' event directed at Job_Gamma this event will be ignored.
        Test::service_event_queue(); 
        
        // Check that both jobs (Job_Alpha & Job_Gamma) and their associated sequences and events are in an expected state. 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        
        Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;
        
        // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
        theJobs := find Job();
        for theJob in theJobs loop
          Test::fire_timer(theJob.jobDeletionTimer);
        end loop;
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test12NormalForkAndMergePath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 1 sequences based on a fork and merge path definition - there are 3 branches
        // This test does not reveal any erroneous behaviour of the twin
        //
        theAuditEventData := (aeDataKindEnum.BRANCHCOUNT, "TypeFork_1", "3");
        acceptOrderedEvent ("1620920000","Test-0001","FMA","Job_FandM",previousEvents,"Ev301",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        previousEvents := ("Ev301");
        acceptOrderedEvent ("1620920001","Test-0001","FMB","Job_FandM",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev305",theAuditEventData);
        previousEvents := empty & "Ev303" & "Ev304" & "Ev305";
        acceptOrderedEvent ("1620920006","Test-0001","FMF","Job_FandM",previousEvents,"Ev306",theAuditEventData);
        previousEvents := ("Ev306");
        acceptOrderedEvent ("1620920007","Test-0001","FMG","Job_FandM",previousEvents,"Ev307",theAuditEventData);
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 7, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test13NormalInstanceForkAndMergePath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 1 sequences based on a fork and merge path definition - there are 3 branches
        // This test does not reveal any erroneous behaviour of the twin
        //
        theAuditEventData := (aeDataKindEnum.BRANCHCOUNT, "InstFork_1", "10");
        acceptOrderedEvent ("1620920000","Test-0001","IFA","Instance_FandM_Job",previousEvents,"Ev301",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        previousEvents := ("Ev301");
        acceptOrderedEvent ("1620920001","Test-0001","IFB","Instance_FandM_Job",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev305",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev306",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev307",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev308",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev309",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev310",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev311",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev312",theAuditEventData);
        previousEvents := empty & "Ev303" & "Ev304" & "Ev305" & "Ev306" & "Ev307" & "Ev308" & "Ev309" & "Ev310" & "Ev311" & "Ev312";
        acceptOrderedEvent ("1620920003","Test-0001","IFD","Instance_FandM_Job",previousEvents,"Ev313",theAuditEventData);
        previousEvents := ("Ev313");
        acceptOrderedEvent ("1620920004","Test-0001","IFE","Instance_FandM_Job",previousEvents,"Ev314",theAuditEventData);
        previousEvents := ("Ev314");
        acceptOrderedEvent ("1620920005","Test-0001","IFF","Instance_FandM_Job",previousEvents,"Ev315",theAuditEventData);
       //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 15, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test15NormalSplitInstanceForkAndMergePath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 2 sequences based on a split fork and merge path definition - there are 10 branches
        // This test does not reveal any erroneous behaviour of the twin
        // Forking Sequence
      
        theAuditEventData := (aeDataKindEnum.BRANCHCOUNT, "SplitInstFork_1", "10");
        acceptOrderedEvent ("1620920000","Test-0001","SIFA","Instance_FandM_Job",previousEvents,"Ev301",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        previousEvents := ("Ev301");
        acceptOrderedEvent ("1620920001","Test-0001","SIFB","Instance_FandM_Job",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","SIFC","Instance_FandM_Job",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","SIFC","Instance_FandM_Job",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","SIFC","Instance_FandM_Job",previousEvents,"Ev305",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","SIFC","Instance_FandM_Job",previousEvents,"Ev306",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","SIFC","Instance_FandM_Job",previousEvents,"Ev307",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","SIFC","Instance_FandM_Job",previousEvents,"Ev308",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","SIFC","Instance_FandM_Job",previousEvents,"Ev309",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","SIFC","Instance_FandM_Job",previousEvents,"Ev310",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","SIFC","Instance_FandM_Job",previousEvents,"Ev311",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","SIFC","Instance_FandM_Job",previousEvents,"Ev312",theAuditEventData);
        
        // Merging Sequence
        previousEvents := empty;
        acceptOrderedEvent ("1620920003","Test-0001","SIFD","Instance_FandM_Job",previousEvents,"Ev313",theAuditEventData);
        previousEvents := empty;
        acceptOrderedEvent ("1620920003","Test-0001","SIFD","Instance_FandM_Job",previousEvents,"Ev314",theAuditEventData);
        previousEvents := empty;
        acceptOrderedEvent ("1620920003","Test-0001","SIFD","Instance_FandM_Job",previousEvents,"Ev315",theAuditEventData);
        previousEvents := empty;
        acceptOrderedEvent ("1620920003","Test-0001","SIFD","Instance_FandM_Job",previousEvents,"Ev316",theAuditEventData);
        previousEvents := empty;
        acceptOrderedEvent ("1620920003","Test-0001","SIFD","Instance_FandM_Job",previousEvents,"Ev317",theAuditEventData);
        previousEvents := empty;
        acceptOrderedEvent ("1620920003","Test-0001","SIFD","Instance_FandM_Job",previousEvents,"Ev318",theAuditEventData);
        previousEvents := empty;
        acceptOrderedEvent ("1620920003","Test-0001","SIFD","Instance_FandM_Job",previousEvents,"Ev319",theAuditEventData);
        previousEvents := empty;
        acceptOrderedEvent ("1620920003","Test-0001","SIFD","Instance_FandM_Job",previousEvents,"Ev320",theAuditEventData);
        previousEvents := empty;
        acceptOrderedEvent ("1620920003","Test-0001","SIFD","Instance_FandM_Job",previousEvents,"Ev321",theAuditEventData);
        previousEvents := empty;
        acceptOrderedEvent ("1620920003","Test-0001","SIFD","Instance_FandM_Job",previousEvents,"Ev322",theAuditEventData);
        previousEvents := empty & "Ev313" & "Ev314" & "Ev315" & "Ev316" & "Ev317" & "Ev318" & "Ev319" & "Ev320" & "Ev321" & "Ev322";
        acceptOrderedEvent ("1620920004","Test-0001","SIFE","Instance_FandM_Job",previousEvents,"Ev323",theAuditEventData);
        previousEvents := ("Ev323");
        acceptOrderedEvent ("1620920005","Test-0001","SIFF","Instance_FandM_Job",previousEvents,"Ev324",theAuditEventData);
       //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 2, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 24, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test16NormalInstanceAndTypeForkAndMergePath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 1 sequence based on a fork and merge path definition - 
        // there are 3 type branches and each type branch has 5 instance branches 
        // all at the same fork point. There is a branch count defined but no merge count
        // This test does not reveal any erroneous behaviour of the twin
        //
        theAuditEventData := (aeDataKindEnum.BRANCHCOUNT, "TypeFork_1", "15");
        acceptOrderedEvent ("1620920000","Test-0001","FMA","Job_FandM",previousEvents,"Ev301",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        previousEvents := ("Ev301");
        acceptOrderedEvent ("1620920001","Test-0001","FMB","Job_FandM",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev305",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev306",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev307",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev308",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev309",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev310",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev311",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev312",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev313",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev314",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev315",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev316",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev317",theAuditEventData);
         
        // The merge point
        previousEvents := empty & "Ev303" & "Ev304" & "Ev305" & "Ev306" & "Ev307" & "Ev308" & "Ev309" & "Ev310" & "Ev311" & "Ev312" & "Ev313" & "Ev314" & "Ev315" & "Ev316" & "Ev317";
        acceptOrderedEvent ("1620920006","Test-0001","FMF","Job_FandM",previousEvents,"Ev318",theAuditEventData);
        previousEvents := ("Ev318");
        acceptOrderedEvent ("1620920007","Test-0001","FMG","Job_FandM",previousEvents,"Ev319",theAuditEventData);
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 19, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test17NormalXORConstraint() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
        // It includes an XOR alternative error event replacing the normal event at Ev14
        // This test does not reveal any erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        // This is a variant of Test01NormalPath where the following event is simulating an error event
        // replacing in an exclusive Or constraint the normal MidWritePayload event
        acceptOrderedEvent ("1620920013","mid-1234","MidPayloadError","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      //
        Test::service_event_queue();
      //
        // Auth Job with single sequence but repeating event types
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(3);
    function Test18DeprecationAndDeletionOfActiveJobDefinition() is
      @noparse
      theJob : instance of Job;
      theJobDefn : instance of JobDefinition;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test checks the behaviour of deprecation and subsequent deletion of an 'Active' JobDefinition.
        // It starts with the creation of a new Job when the first event for a Bank Transfer Job arrives which is
        // then followed by a request to deprecate the related JobDefinition.
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        Test::service_event_queue();
      
        theJob := find_only Job(jobID = "Job_Alpha");
        theJobDefn := theJob -> R8;
        generate JobDefinition.deprecate() to theJobDefn;
        Test::service_event_queue();
          
        Assertions::assertTrue(theJobDefn.jobName = "BankTransferJob", "Wrong JobDefinition: " & theJobDefn.jobName & "was deprecated, whereas a 'BankTransferJob' was expected");
        Assertions::assertTrue(theJobDefn.isDeprecated = true, "JobDefinition with jobName: " & theJobDefn.jobName & "failed to deprecate");
        
        // Fire timers to ensure that the deprecated JobDefinition re-checks whether it's OK to delete itself
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if;
        
        // Re-check that the JobDefinition for BankTransferJob type has not been deleted
        theJobDefn := find_only JobDefinition(jobName = "BankTransferJob");
        
        Assertions::assertTrue(theJobDefn /= null, "JobDefinition 'BankTransferJob' has unexpectedly been deleted");
      
        // Delete the only Job for the deprecated BankTransferJob type and then re-fire the timers so that it 
        // re-checks whether it's OK to delete itself
        theJob.deleteJob();
        
        // Fire timers to ensure that the deprecated JobDefintion re-checks whether it's OK to delete itself
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if;
        
        // ...and then check to see if the deprecated JobDefinition has deleted itself.
        theJobDefn := find_only JobDefinition(jobName = "BankTransferJob");
        
        Assertions::assertTrue(theJobDefn = null, "Deprecated JobDefinition 'BankTransferJob' has not deleted itself even though it has no uncompleted Jobs");
        
      
      end service;
      @endnoparse
    end function;

    @function_num(4);
    function Test19StartOfNewJobForDeprecatedJobDefinition() is
      @noparse
      theFirstJob : instance of Job;
      theBankTransferJobs : set of instance of Job;
      theJobDefn : instance of JobDefinition;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test checks that new Jobs of a type that has been deprecated cannot be started.
        // Start by creating the first of two Jobs of type 'AuthJob' and then deprecate that type so that
        // no new jobs of this type should be started.
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma_One","","Ev201",theAuditEventData);
        Test::service_event_queue();
      
        theFirstJob := find_only Job(jobID = "Job_Gamma_One");
        theJobDefn := theFirstJob -> R8;
        generate JobDefinition.deprecate() to theJobDefn;
        Test::service_event_queue();
          
        Assertions::assertTrue(theJobDefn.jobName = "AuthJob", "Wrong JobDefinition: " & theJobDefn.jobName & "was deprecated, whereas a 'AuthJob' was expected");
        Assertions::assertTrue(theJobDefn.isDeprecated = true, "JobDefinition with jobName: " & theJobDefn.jobName & "failed to deprecate");
        
        // Fire timers to ensure that the deprecated JobDefintion re-checks whether it's OK to delete itself
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if;
        
        // Re-check that the JobDefinition of type 'AuthJob'  has not been deleted
        theJobDefn := find_only JobDefinition(jobName = "AuthJob");
       
        Assertions::assertTrue(theJobDefn /= null, "JobDefinition 'AuthJob' has unexpectedly been deleted");
      
        // Now try starting a second job of the same type - and because that type has been deprecated then the new job should not be started.
        acceptOrderedEvent ("1620920101","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma_Two","","Ev202",theAuditEventData);
        Test::service_event_queue();
        
        // Fire timers to ensure that the deprecated JobDefintion re-checks whether it's OK to delete itself
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if;
        
        // ...and then check to see if the deprecated JobDefinition has NOT deleted itself.
        theJobDefn := find_only JobDefinition(jobName = "AuthJob");
        
        Assertions::assertTrue(theJobDefn /= null, "Deprecated JobDefinition 'AuthJob' has incorrectly deleted itself before all jobs of that type have completed");
        
        // ...and finally check that the second job was not started
        theBankTransferJobs := theJobDefn -> R8;
        Assertions::assertTrue(theBankTransferJobs'length = 1, "New Job of type 'AuthJob' was started despite that type being deprecated");
        
      end service;
      @endnoparse
    end function;

    @function_num(5);
    function Test20StartOfNewJobForSuspendedJobDefinition() is
      @noparse
      theFirstJob : instance of Job;
      theThirdJob : instance of Job;
      theBankTransferJobs : set of instance of Job;
      theJobDefn : instance of JobDefinition;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test checks that new Jobs of a type that has been suspended cannot be started.
        // Start by creating the first of three Jobs of type 'CyclicJob' and then deprecate that type so that
        // no new jobs of this type should be started.
        acceptOrderedEvent ("1620920000","Test-0001","A","Job_Cyclo_One","","Ev301",theAuditEventData);
        Test::service_event_queue();
      
        theFirstJob := find_only Job(jobID = "Job_Cyclo_One");
        theJobDefn := theFirstJob -> R8;
        generate JobDefinition.suspend() to theJobDefn;
        Test::service_event_queue();
          
        Assertions::assertTrue(theJobDefn.jobName = "CyclicJob", "Wrong JobDefinition: " & theJobDefn.jobName & "was suspended, whereas a 'CyclicJob' was expected");
        Assertions::assertTrue(theJobDefn.isSuspended = true, "JobDefinition with jobName: " & theJobDefn.jobName & "failed to suspend");
      
        // Now try starting a second Job of the same type - and because that type has been suspended then the new job should not be started.
        acceptOrderedEvent ("1620920001","Test-0001","A","Job_Cyclo_Two","","Ev302",theAuditEventData);
        Test::service_event_queue();
        
        // ...and then check that the second job was not started.
        theBankTransferJobs := theJobDefn -> R8;
        Assertions::assertTrue(theBankTransferJobs'length = 1, "New Job of type 'CyclicJob' was started despite that type being suspended");
        
        // Next, reactivate the suspended JobDefinition and check that a third job of this type can be started.
        generate JobDefinition.reactivate() to theJobDefn;
        Test::service_event_queue();
        
        // Now try starting a third Job of the same type - this should be successful now that the JobDefinition is ACTIVE once again.
        acceptOrderedEvent ("1620920003","Test-0001","A","Job_Cyclo_Three","","Ev303",theAuditEventData);
        Test::service_event_queue();
        
        // ...and finally check that the third Job was successfully started.
        theThirdJob := find_only Job (jobID = "Job_Cyclo_Three");
        theBankTransferJobs := theJobDefn -> R8;
        Assertions::assertTrue(theThirdJob /= null, "New Job 'Job_Cyclo_Three' was not started despite its type being active");
        Assertions::assertTrue(theBankTransferJobs'length = 2, "New Job of type 'CyclicJob' was not started despite that type being active");
        
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test21NormalIntraJobInvariant() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      theIntraJobInvariants : set of instance of TransientInvariant;
      
      begin
        // This test is based upon Test14 which covers 1 Job with 2 sequences based on a fork and merge path definition - the first
        // sequence contains a fork to 3 branches and the second sequence contains a merge back to a single branch
        // This test adds invariant audit event data which is used to verify the two sequences have been used correctly
        // This test does not reveal any erroneous behaviour of the twin
        //
        previousEvents := empty;
        theAuditEventData := (aeDataKindEnum.INTRAJOBINV, "InvA", "A12345");
        acceptOrderedEvent ("1620920000","Test-0001","SFMA","Job_Split_FandM",previousEvents,"Ev301",theAuditEventData);
        previousEvents := ("Ev301");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Test-0001","SFMB","Job_Split_FandM",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Test-0001","SFMC","Job_Split_FandM",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Test-0001","SFMD","Job_Split_FandM",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Test-0001","SFME","Job_Split_FandM",previousEvents,"Ev305",theAuditEventData);
        previousEvents := empty;
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Test-0001","SFMC1","Job_Split_FandM",previousEvents,"Ev306",theAuditEventData);
        previousEvents := empty;
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Test-0001","SFMD1","Job_Split_FandM",previousEvents,"Ev307",theAuditEventData);
        previousEvents := empty;
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Test-0001","SFME1","Job_Split_FandM",previousEvents,"Ev308",theAuditEventData);
        previousEvents := empty & "Ev306" & "Ev307" & "Ev308";
        theAuditEventData := (aeDataKindEnum.INTRAJOBINV, "InvA", "A12345");
        acceptOrderedEvent ("1620920006","Test-0001","SFMF","Job_Split_FandM",previousEvents,"Ev309",theAuditEventData);
        previousEvents := ("Ev309");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920007","Test-0001","SFMG","Job_Split_FandM",previousEvents,"Ev310",theAuditEventData);
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        theIntraJobInvariants := theAuditEvents -> R23;
        
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 2, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 10, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        Assertions::assertTrue(theIntraJobInvariants'length = 2, "Wrong number of invariants created: " & (theIntraJobInvariants'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;
        
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test22NormalSourceExtraJobInvariant() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      thePersistedInvariants : set of instance of PersistedInvariant;
      thePersistedInvariant : instance of PersistedInvariant;
      logMessage : string;
      
      begin
        // This test covers 1 Auth Job with 2 persistentinvariant values being defined
        // This test does not reveal any erroneous behaviour of the twin
        //
        previousEvents := empty;
      //  theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent987654321");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920000","Auth-0001","EAuthoriserSendOrderRequest","Job_PersistentInvariant",previousEvents,"Ev1201",theAuditEventData);
        previousEvents := ("Ev1201");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Auth-0001","EAuthReceiveRequest","Job_PersistentInvariant",previousEvents,"Ev1202",theAuditEventData);
        previousEvents := ("Ev1202");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920002","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1203",theAuditEventData);
        previousEvents := ("Ev1203");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920003","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1204",theAuditEventData);
        previousEvents := ("Ev1204");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920004","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1205",theAuditEventData);
        previousEvents := ("Ev1205");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1206",theAuditEventData);
        previousEvents := ("Ev1206");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920006","Auth-0001","EAuthSendResponse","Job_PersistentInvariant",previousEvents,"Ev1207",theAuditEventData);
        previousEvents := ("Ev1207");
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920007","Auth-0001","EAuthoriserReceiveOrder","Job_PersistentInvariant",previousEvents,"Ev1208",theAuditEventData);
       
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        thePersistedInvariants := find PersistedInvariant();
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 1, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 8, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        Assertions::assertTrue(thePersistedInvariants'length = 1, "Wrong number of persistentinvariant instances created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
        end loop;
        
        // ... and finally clear down all the existing instances of PersistedInvariant in readiness for other tests.
        for thePersistedInvariant in thePersistedInvariants loop
          thePersistedInvariant.deletePersistedInvariant();   
        end loop;
        
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test23NormalUserExtraJobInvariant() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      theUserInvariants : set of instance of TransientInvariant;
      theSourceInvariants : set of instance of PersistedInvariant;
      previousEvents : sequence of string;
      empty : sequence of string;
      logMessage : string;
      
      thePersistedInvariants : set of instance of PersistedInvariant;
      thePersistedInvariant : instance of PersistedInvariant;
      theExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;
      
      begin
        // This test initially creates 1 Auth Job with 2 persistentinvariant values being defined
        // This part of the test does not reveal any erroneous behaviour of the twin
        //
        previousEvents := empty;
        //theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent987654321");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920000","Auth-0001","EAuthoriserSendOrderRequest","Job_PersistentInvariant",previousEvents,"Ev1201",theAuditEventData);
        previousEvents := ("Ev1201");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Auth-0001","EAuthReceiveRequest","Job_PersistentInvariant",previousEvents,"Ev1202",theAuditEventData);
        previousEvents := ("Ev1202");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920002","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1203",theAuditEventData);
        previousEvents := ("Ev1203");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920003","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1204",theAuditEventData);
        previousEvents := ("Ev1204");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920004","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1205",theAuditEventData);
        previousEvents := ("Ev1205");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1206",theAuditEventData);
        previousEvents := ("Ev1206");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920006","Auth-0001","EAuthSendResponse","Job_PersistentInvariant",previousEvents,"Ev1207",theAuditEventData);
        previousEvents := ("Ev1207");
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920007","Auth-0001","EAuthoriserReceiveOrder","Job_PersistentInvariant",previousEvents,"Ev1208",theAuditEventData);
       
        //
        Test::service_event_queue();
        theJob := find_only Job(jobID = "Job_PersistentInvariant");
        Test::fire_timer(theJob.jobEventTimer);
        
        
        // It then deletes the Job that created the PersistentInvariant values but retains the persistentinvariant values as PersistedInvariants
        
        deleteJob ("Job_PersistentInvariant");
        theSourceInvariants := find PersistedInvariant(inForce = true);
        Assertions::assertTrue(theSourceInvariants'length = 1, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
        
        
        // This test test that the persistentinvariant can be used ok using 1 Job with 3 sequences and all events are in the standard default order
        // 3 of the events refer to the persistentinvariant value and all must match to pass the extra job invariant check
        // This test does not reveal any erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920000","export-control-1234","ENearInput","Job_PersistentInvariant_Use","","Ev1",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","export-control-1234","ENearPartWrite","Job_PersistentInvariant_Use","Ev1","Ev2",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920002","export-control-1234","ENearJustificationWrite","Job_PersistentInvariant_Use","Ev2","Ev3",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920003","agent-1234","EAgentRequestWidgets","Job_PersistentInvariant_Use","Ev3","Ev4",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920004","authoriser-1234","EAuthoriserReadWidgetRequest","Job_PersistentInvariant_Use","Ev4","Ev5",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","authoriser-1234","EAuthoriserParsedJustification","Job_PersistentInvariant_Use","Ev5","Ev6",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920006","authoriser-1234","EAuthoriserSendWidgets","Job_PersistentInvariant_Use","Ev6","Ev7",theAuditEventData);
        
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920007","agent-1234","EAgentReceiveWidgets","Job_PersistentInvariant_Use","Ev7","Ev8",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920008","agent-1234","EAgentPartRead","Job_PersistentInvariant_Use","Ev8","Ev9",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920008","agent-1234","EAgentProcessedRequest","Job_PersistentInvariant_Use","Ev8","Ev9a",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920009","agent-1234","EAgentWritePayload","Job_PersistentInvariant_Use","Ev9","Ev10",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920010","gateway-1234","EGatewayReadPayload","Job_PersistentInvariant_Use","Ev10","Ev11",theAuditEventData);
        
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920011","gateway-1234","EGatewayWritePayload","Job_PersistentInvariant_Use","Ev11","Ev12",theAuditEventData);
        
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920012","mid-1234","EMidProcessPayload","Job_PersistentInvariant_Use","","Ev13",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920013","mid-1234","EMidWritePayload","Job_PersistentInvariant_Use","Ev13","Ev14",theAuditEventData);
        
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920050","import_control-1234","EFarInput","Job_PersistentInvariant_Use","","Ev50",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920055","import_control-1234","EFarOutput","Job_PersistentInvariant_Use","Ev50","Ev55",theAuditEventData);
        //
        //
        Test::service_event_queue();
        
        theJob := find_only Job(jobID = "Job_PersistentInvariant_Use");
        Test::fire_timer(theJob.jobEventTimer);
      
        Test::service_event_queue();
        
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        theUserInvariants := theAuditEvents -> R23;
        theSourceInvariants := find PersistedInvariant(inForce = true);
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 3, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 17, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        Assertions::assertTrue(theUserInvariants'length = 3, "Wrong number of user invariants created: " & (theUserInvariants'length)'image);
        Assertions::assertTrue(theSourceInvariants'length = 1, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
        for eachJob in theJobs loop
          Assertions::assertTrue(eachJob.jobCompleted, "Job is incomplete: " & eachJob.jobID);
          Assertions::assertTrue(eachJob.sequencingFailed = false, "Sequencing has failed: " & eachJob.jobID);
        end loop; 
        
        // ... and finally clear down all the existing instances of PersistedInvariant in readiness for other tests.
        thePersistedInvariants := find PersistedInvariant();
        for thePersistedInvariant in thePersistedInvariants loop
          thePersistedInvariant.deletePersistedInvariant();   
        end loop; 
        
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test24MultipleInForcePersistentInvariant() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      theUserInvariants : set of instance of TransientInvariant;
      theSourceInvariants : set of instance of PersistedInvariant;
      previousEvents : sequence of string;
      empty : sequence of string;
      logMessage : string;
      
      thePersistedInvariants : set of instance of PersistedInvariant;
      thePersistedInvariant : instance of PersistedInvariant;
      theExtraJobInvariantDefn : instance of ExtraJobInvariantDefn;
      
      begin
        // This test initially creates 1 Auth Job with 1 persistentinvariant value being defined
        // This part of the test does not reveal any erroneous behaviour of the twin
        //
        previousEvents := empty;
        //theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent987654321");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920000","Auth-0001","EAuthoriserSendOrderRequest","Job_PersistentInvariant_1",previousEvents,"Ev1201",theAuditEventData);
        previousEvents := ("Ev1201");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Auth-0001","EAuthReceiveRequest","Job_PersistentInvariant_1",previousEvents,"Ev1202",theAuditEventData);
        previousEvents := ("Ev1202");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920002","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant_1",previousEvents,"Ev1203",theAuditEventData);
        previousEvents := ("Ev1203");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920003","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant_1",previousEvents,"Ev1204",theAuditEventData);
        previousEvents := ("Ev1204");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920004","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant_1",previousEvents,"Ev1205",theAuditEventData);
        previousEvents := ("Ev1205");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant_1",previousEvents,"Ev1206",theAuditEventData);
        previousEvents := ("Ev1206");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920006","Auth-0001","EAuthSendResponse","Job_PersistentInvariant_1",previousEvents,"Ev1207",theAuditEventData);
        previousEvents := ("Ev1207");
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920007","Auth-0001","EAuthoriserReceiveOrder","Job_PersistentInvariant_1",previousEvents,"Ev1208",theAuditEventData);
       
        //
        Test::service_event_queue();
        theJob := find_only Job(jobID = "Job_PersistentInvariant_1");
        Test::fire_timer(theJob.jobEventTimer);
        
        
        // It then deletes the Job that created the PersistentInvariant values but retains the persistentinvariant values as PersistedInvariants
        
        deleteJob ("Job_PersistentInvariant_1");
        theSourceInvariants := find PersistedInvariant(inForce = true);
        Assertions::assertTrue(theSourceInvariants'length = 1, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
        
       // This test now creates a second Auth Job with the same named persistentinvariant value being defined though with a different value
        // This part of the test does not reveal any erroneous behaviour of the twin
        //
        previousEvents := empty;
        //theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent999999999");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620930000","Auth-0001","EAuthoriserSendOrderRequest","Job_PersistentInvariant_2",previousEvents,"Ev1201",theAuditEventData);
        previousEvents := ("Ev1201");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620930001","Auth-0001","EAuthReceiveRequest","Job_PersistentInvariant_2",previousEvents,"Ev1202",theAuditEventData);
        previousEvents := ("Ev1202");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620930002","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant_2",previousEvents,"Ev1203",theAuditEventData);
        previousEvents := ("Ev1203");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620930003","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant_2",previousEvents,"Ev1204",theAuditEventData);
        previousEvents := ("Ev1204");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620930004","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant_2",previousEvents,"Ev1205",theAuditEventData);
        previousEvents := ("Ev1205");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620930005","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant_2",previousEvents,"Ev1206",theAuditEventData);
        previousEvents := ("Ev1206");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620930006","Auth-0001","EAuthSendResponse","Job_PersistentInvariant_2",previousEvents,"Ev1207",theAuditEventData);
        previousEvents := ("Ev1207");
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent333333333");
        acceptOrderedEvent ("1620930007","Auth-0001","EAuthoriserReceiveOrder","Job_PersistentInvariant_2",previousEvents,"Ev1208",theAuditEventData);
       
        //
        Test::service_event_queue();
        theJob := find_only Job(jobID = "Job_PersistentInvariant_2");
        Test::fire_timer(theJob.jobEventTimer);
        
        
        // It then deletes the Job that created the PersistentInvariant values but retains the persistentinvariant values as PersistedInvariants
        
        deleteJob ("Job_PersistentInvariant_2");
        theSourceInvariants := find PersistedInvariant(inForce = true);
        Assertions::assertTrue(theSourceInvariants'length = 2, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
        
        
        // This test has set up the situation where there are 2 instances of PersistedInvariant with the same name in force at the same time
        // They have different values and the test will pass if the provided data matches either one of the values
        // 1 of the events refers to one and 2 events refer to the other persistentinvariant value and all must match a valid persistentinvariant value to pass the extra job invariant check
        // This test does not reveal any erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920000","export-control-1234","ENearInput","Job_PersistentInvariant_Use","","Ev1",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","export-control-1234","ENearPartWrite","Job_PersistentInvariant_Use","Ev1","Ev2",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920002","export-control-1234","ENearJustificationWrite","Job_PersistentInvariant_Use","Ev2","Ev3",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920003","agent-1234","EAgentRequestWidgets","Job_PersistentInvariant_Use","Ev3","Ev4",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920004","authoriser-1234","EAuthoriserReadWidgetRequest","Job_PersistentInvariant_Use","Ev4","Ev5",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","authoriser-1234","EAuthoriserParsedJustification","Job_PersistentInvariant_Use","Ev5","Ev6",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920006","authoriser-1234","EAuthoriserSendWidgets","Job_PersistentInvariant_Use","Ev6","Ev7",theAuditEventData);
        
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent333333333");
        acceptOrderedEvent ("1620920007","agent-1234","EAgentReceiveWidgets","Job_PersistentInvariant_Use","Ev7","Ev8",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920008","agent-1234","EAgentPartRead","Job_PersistentInvariant_Use","Ev8","Ev9",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920008","agent-1234","EAgentProcessedRequest","Job_PersistentInvariant_Use","Ev8","Ev9a",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920009","agent-1234","EAgentWritePayload","Job_PersistentInvariant_Use","Ev9","Ev10",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920010","gateway-1234","EGatewayReadPayload","Job_PersistentInvariant_Use","Ev10","Ev11",theAuditEventData);
        
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent333333333");
        acceptOrderedEvent ("1620920011","gateway-1234","EGatewayWritePayload","Job_PersistentInvariant_Use","Ev11","Ev12",theAuditEventData);
        
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920012","mid-1234","EMidProcessPayload","Job_PersistentInvariant_Use","","Ev13",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920013","mid-1234","EMidWritePayload","Job_PersistentInvariant_Use","Ev13","Ev14",theAuditEventData);
        
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920050","import_control-1234","EFarInput","Job_PersistentInvariant_Use","","Ev50",theAuditEventData);
        
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920055","import_control-1234","EFarOutput","Job_PersistentInvariant_Use","Ev50","Ev55",theAuditEventData);
        //
        //
        Test::service_event_queue();
        
        theJob := find_only Job(jobID = "Job_PersistentInvariant_Use");
        Test::fire_timer(theJob.jobEventTimer);
      
        Test::service_event_queue();
        
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        theUserInvariants := theAuditEvents -> R23;
        theSourceInvariants := find PersistedInvariant(inForce = true);
        //
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 3, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 17, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        Assertions::assertTrue(theUserInvariants'length = 3, "Wrong number of user invariants created: " & (theUserInvariants'length)'image);
        Assertions::assertTrue(theSourceInvariants'length = 2, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
        for eachJob in theJobs loop
          Assertions::assertTrue(eachJob.jobCompleted, "Job is incomplete: " & eachJob.jobID);
          Assertions::assertTrue(eachJob.sequencingFailed = false, "Sequencing has failed: " & eachJob.jobID);
        end loop; 
        
        // ... and finally clear down all the existing instances of PersistedInvariant in readiness for other tests.
        thePersistedInvariants := find PersistedInvariant();
        for thePersistedInvariant in thePersistedInvariants loop
          thePersistedInvariant.deletePersistedInvariant();   
        end loop; 
        
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test31ErrorDetection() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 3 sequences with one event out of sequence
        // This test reveals any erroneous behaviour of the twin
        //
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        // The following event type is in the wrong place in the sequence and so should cause the Job to fail
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      //
      //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
      //  theSequences := theJobs -> R10;
      //  theAuditEvents := theSequences -> R11;
        
        //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed, "Sequencing hasn't failed and it should have: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test32ErrorDetection() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 3 sequences with one undefined event type
        // This test reveals any erroneous behaviour of the twin
        //
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        // The following event contains an unknown event type and so should causer the Job to fail
        acceptOrderedEvent ("1620920005","authoriser-1234","ErroneousEventType","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      //
      //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if;
        theJobs := find Job ();
      //  theSequences := theJobs -> R10;
      //  theAuditEvents := theSequences -> R11;
        
        //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed, "Sequencing hasn't failed and it should have: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test33ErrorDetection() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 3 sequences with one unseen previous event
        // This test reveals any erroneous behaviour of the twin
        //
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        // The following event has a previous event that has not been seen before - this should cause the Job to fail
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","EvXX","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      //
      //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if;
        theJobs := find Job ();
      //  theSequences := theJobs -> R10;
      //  theAuditEvents := theSequences -> R11;
        
        //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed, "Sequencing hasn't failed and it should have: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test34ErrorDetection() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Jobs with 3 sequences. However, the Mid sequence has a start event that contains a 
        // previous EventId (which is invalid for start events).
        // This test reveals any behaviour of the twin
        //
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        // The following event is a sequence start event but erroneously it has a valid previous event id 
        // This should cause the job to fail
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","Ev12","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      
        // Process all the events on the event queue - Job_Alpha should be in the 'JobFailed' state after this.
        Test::service_event_queue();
        
       
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        
        Assertions::assertTrue(theJobs'length = 1, "Wrong number of jobs created: " & (theJobs'length)'image);
      
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed, "Sequencing hasn't failed and it should have: " & theJob.jobID);
        end loop;
        
        // Fire the jobDeletionTimer for Job_Alpha - this will result in it being deleted.
        theJob := find_only Job(jobID = "Job_Alpha");
        Test::fire_timer(theJob.jobDeletionTimer);
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //   
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test35ErrorDetection() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Jobs with 3 sequences and all events are in the standard default order
        // but one event has an event id the same as a previous event and this is an error condition
        // This test does reveal erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        // The following event has the same event id (last parameter) as an earlier event - this should cause the Job to fail
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if;
      //
        theJobs := find Job ();
      //  theSequences := theJobs -> R10;
      //  theAuditEvents := theSequences -> R11;
        
        //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed, "Sequencing hasn't failed and it should have: " & theJob.jobID);
        end loop;  
      
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test36ErrorDetection() is
      @noparse
      theAJob : instance of Job;
      theGJob : instance of Job;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
        // The JobComplete interaction from AEOrdering is received earlier than expected before all events have been processed
        // This test does reveal erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        // Job complete being injected here is an error condition because this should not occur until all events for a Job have been received
        // Invoke interaction from AEOrdering called JobComplete which is interpreted as Job Timeout in this domain
        jobComplete ("Job_Alpha");
      //
      //  
        Test::service_event_queue();
      //
        // Auth Job with single sequence but repeating event types
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if;
        // Invoke interaction from AEOrdering called JobComplete which is interpreted as Job Timeout in this domain
        jobComplete ("Job_Gamma");
        //
        Test::service_event_queue();
        theAJob := find_one Job (jobID = "Job_Alpha");
        theGJob := find_one Job (jobID = "Job_Gamma");
      //  theSequences := theJobs -> R10;
      //  theAuditEvents := theSequences -> R11;
        
        //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        Assertions::assertTrue(theAJob.jobCompleted = false, "Job is completed but shouldn't have: " & theAJob.jobID);
        Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test37ErrorDetection() is
      @noparse
      theJobs : set of instance of Job;
      
      begin
        // 
        // The JobComplete interaction from AEOrdering is received for an unknown Job
        // This test does reveal erroneous behaviour of the twin
        //
        // Job complete for an unknown Job is an error condition 
        jobComplete ("Job_Unknown");
      //
      //  
        Test::service_event_queue();
      //
        theJobs := find Job (jobID = "Job_Unknown");
      //  theSequences := theJobs -> R10;
      //  theAuditEvents := theSequences -> R11;
        
        //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        Assertions::assertTrue(theJobs'length = 0, "Jobs reported complete for a Job that doesn't exist ; " & (theJobs'length)'image);
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test38AnomalousCondition() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers a very special situation. It injects JobComplete from AEOrdering at the point where one branch
        // of an unconstrained BankTransfer sequence has completed but another possible branch hasn't started. The events for the
        // other branch arrive after JobComplete which would be erroneous behaviour of AEOrdering. The model ignores JobComplete
        // in this specific circumstance because it looks just like a legitimate end of a Job prior to the Job timeout. Compare with Test39.
        // This test does reveals some anomalous behaviour of this system but it is not classed as an error condition.
        //
        // Normal Mid sequence starts here
        acceptOrderedEvent ("1620920012","mid-1234","IOR_MidProcessPayload","IOR_Job_Alpha","","IOR_Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","IOR_MidWritePayload","IOR_Job_Alpha","IOR_Ev13","IOR_Ev14",theAuditEventData);
        // Normal Far Side sequence starts here
        acceptOrderedEvent ("1620920050","import_control-1234","IOR_FarInput","IOR_Job_Alpha","","IOR_Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","IOR_FarOutput","IOR_Job_Alpha","IOR_Ev50","IOR_Ev55",theAuditEventData);
        // Near side sequence starts here
        acceptOrderedEvent ("1620920000","export-control-1234","IOR_NearInput","IOR_Job_Alpha","","IOR_Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","IOR_NearPartWrite","IOR_Job_Alpha","IOR_Ev1","IOR_Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","IOR_NearJustificationWrite","IOR_Job_Alpha","IOR_Ev2","IOR_Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","IOR_AgentRequestWidgets","IOR_Job_Alpha","IOR_Ev3","IOR_Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","IOR_AuthoriserReadWidgetRequest","IOR_Job_Alpha","IOR_Ev4","IOR_Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","IOR_AuthoriserParsedJustification","IOR_Job_Alpha","IOR_Ev5","IOR_Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","IOR_AuthoriserSendWidgets","IOR_Job_Alpha","IOR_Ev6","IOR_Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","IOR_AgentReceiveWidgets","IOR_Job_Alpha","IOR_Ev7","IOR_Ev8",theAuditEventData);
        // The following event is an end point event which occurs here before the branch is obvious
        // This tests the system does not prematurely indicate Job Complete
        acceptOrderedEvent ("1620920008","agent-1234","IOR_AgentProcessedRequest","IOR_Job_Alpha","IOR_Ev8","IOR_Ev9a",theAuditEventData);
      
        // Mimic the interaction from AEOrdering called jobComplete which is interpreted as a Job Timeout in this domain.
        // Note that jobComplete being injected here is an error condition because this should not occur until all events for a Job have been received
        jobComplete ("IOR_Job_Alpha");
        
        // Process all the events on the event queue (including the jobTimedOut event). At this point in the test the Job should 
        // have reached the 'AssessingSequenceCompletion' state and so will ignore the jobTimedOut event.
        Test::service_event_queue();
        
        // Fire the timer that waits for alternative branch events on Job_Alpha to start - this mimics the situation where 
        // the events for Job_Alpha that follow (see befar) arrive too late to be processed but the Job proceeds (wrongly) on
        // on basis that all sequences must have been received.
        theJob := find_only Job(jobID = "IOR_Job_Alpha");
        Test::fire_timer(theJob.jobEventTimer);
        
        acceptOrderedEvent ("1620920008","agent-1234","IOR_AgentPartRead","IOR_Job_Alpha","IOR_Ev8","IOR_Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","IOR_AgentWritePayload","IOR_Job_Alpha","IOR_Ev9","IOR_Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","IOR_GatewayReadPayload","IOR_Job_Alpha","IOR_Ev10","IOR_Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","IOR_GatewayWritePayload","IOR_Job_Alpha","IOR_Ev11","IOR_Ev12",theAuditEventData);
      
        // Process all the events on the event queue - these events are not expected for a successful job, so will result in
        // IOR_Job_Alpha going 'horribly wrong'.
        Test::service_event_queue();
        
      
        // This is a separate Auth Job not fundamental to the test
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
      
        // Process all the events on the event queue
        Test::service_event_queue();
        
        // Fire the timer that waits for alternative branch events on Job_Gamma to start - no branch expected in this test.
        theJob := find_only Job(jobID = "Job_Gamma");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Process all the events on the event queue resulting from the state actions that are executed following the
        // jobEventTimer being fired - this will result in Job_Gamma reaching the 'JobSuccessful' state.
        Test::service_event_queue();
        
        //if (Test::get_scheduled_timers ())'length /= 0 then
        //  Test::fire_scheduled_timers();
        //end if;
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        
        Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 21, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          if theJob.jobID = "IOR_Job_Alpha" then
            Assertions::assertTrue(theJob.jobCompleted = false, "Job is erroneously completed - jobID " & theJob.jobID);
          else
            Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
            Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
          end if;
        end loop;
        
        // Fire the jobDeletionTimer for both jobs (IOR_Job_Alpha and Job_Gamma) - this will result in them being deleted.
        theJobs := find Job();
        for theJob in theJobs loop
          Test::fire_timer(theJob.jobDeletionTimer);
        end loop;
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for IOR_Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        // 
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test39ErrorDetection() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theTimers : sequence of timer;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers an unusual situation which shouldn't occur if AEOrdering is behaving as expected.. It injects 
        // JobComplete from AEOrdering in the middle of a BankTransfer sequence. 
        // Further events are received from AEOrdering for this same Job. Compare with Test38
        // This test does reveals erroneous behaviour of this system.
        //
        // Normal Mid sequence starts here
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Normal Far Side sequence starts here
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
        // Near side sequence starts here
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        //
        // Job complete being injected here is an error condition because this should not occur until all events for a Job have been received
        // Invoke interaction from AEOrdering called JobComplete which is interpreted as Job Timeout in this domain
        jobComplete ("Job_Alpha");
        //
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        // The following event is an end point event which occurs here before the branch is obvious
        // This tests the system does not prematurely indicate Job Complete
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
      //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if;  
      //
        theJobs := find Job ();
        for theJob in theJobs loop
          // TODO It would be better also to assert that the job has timed out but this requires an additional attribute
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test40FailedJob() is
      @noparse
      theJobs : set of instance of Job;
      
      begin
        // 
        // The failedJob interaction from AEOrdering is received for an unknown Job
        // This test does reveal erroneous behaviour of the twin
        //
        // Failed Job for an unknown Job is an error condition 
        failedJob ("Job_Unknown","Failure_Reason");
      //
      //  
        Test::service_event_queue();
      //
        theJobs := find Job (jobID = "Job_Unknown");
      //  theSequences := theJobs -> R10;
      //  theAuditEvents := theSequences -> R11;
        
        //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        Assertions::assertTrue(theJobs'length = 0, "Job(s) reported complete for a Job that doesn't exist ; " & (theJobs'length)'image);
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test41FailedJob() is
      @noparse
      theJob : instance of Job;
      theAJob : instance of Job;
      theGJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        //
        // The failedJob interaction from AEOrdering is received for a normal Job in the MIDDLE of a normal sequence
        // This test does reveal erroneous behaviour of the monitored system or elsewhere in the digital twin
        // This test also includes a normal error-free Job to test that failure of one Job does not interact with another healthy Job
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        //
        // Failed Job for a normal Job is an error condition that should move the Job into the 'JobFailed' state. All Subsequent
        // audit events, if any, will be ignored in this state.
        //
        failedJob ("Job_Alpha","AEO says the job has failed");
        //
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      
        // Process all the events on the event queue - note that Job_Alpha should be in the 'JobFailed' state after this.
        Test::service_event_queue();
      
      
        // Auth Job with single sequence but repeating event types
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
        
        // Process all the events on the event queue - note that Job_Gamma should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
        
        // Fire the timer that waits for optional branch events on Job_Gamma to start - no branch expected in this test
        theJob := find_only Job(jobID = "Job_Gamma");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
        // the jobEventTimer for Job_Gamma being fired. Note that Job_Gamma should be in the 'JobSuccessful' state after this.
        Test::service_event_queue();
      
        
        theJobs := find Job ();
        theAJob := find_one Job (jobID = "Job_Alpha");
        theGJob := find_one Job (jobID = "Job_Gamma");
        //
        Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theAJob.jobCompleted = false, "Job has completed but shouldn't have: " & theAJob.jobID);
        Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
        Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
        
        // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
        theJobs := find Job();
        for theJob in theJobs loop
          Test::fire_timer(theJob.jobDeletionTimer);
        end loop;
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test42FailedJob() is
      @noparse
      theJob : instance of Job;
      theAJob : instance of Job;
      theGJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        //
        // The failedJob interaction from AEOrdering is received for a normal Job at the END of a sequence
        // This test does reveal erroneous behaviour of the monitored system or elsewhere in the digital twin
        // This test also includes a normal error-free Job to test that failure of one Job does not interact with another healthy Job
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        //
        // Failed Job for a normal Job is an error condition that should move the Job into a failed state. Subsequent
        // audit events, if any, will be ignored
        //
        failedJob ("Job_Alpha","AEO says the job has failed");
        //
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
        // Auth Job with single sequence but repeating event types
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
        
        // Process all the events on the event queue - note that Job_Alpha should be in the 'JobFailed' state after this, and
        // Job_Gamma in the 'AssessingSequenceCompletion' state.
        Test::service_event_queue();
       
        // Fire the timer that waits for optional branch events on Job_Gamma to start - no branch expected in this test
        theJob := find_only Job(jobID = "Job_Gamma");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Service the event queue again to process any events placed on queue resulting from actions executed as a result of 
        // the jobEventTimer for Job_Gamma being fired. Note that Job_Gamma should be in the 'JobSuccessful' state after this.
        Test::service_event_queue();
        
        // Check the state of each of the two jobs.
        theJobs := find Job ();
        theAJob := find_one Job (jobID = "Job_Alpha");
        theGJob := find_one Job (jobID = "Job_Gamma");
      
        Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theAJob.jobCompleted = false, "Job has completed but shouldn't have: " & theAJob.jobID);
        Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
        Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
        
        
        // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
        theJobs := find Job();
        for theJob in theJobs loop
          Test::fire_timer(theJob.jobDeletionTimer);
        end loop;
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //
        //
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test43FailedJobDebatableCondition() is
      @noparse
      theJob : instance of Job;
      theAJob : instance of Job;
      theGJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        //
        // The failedJob interaction from AEOrdering is received for a normal Job after all events have been received but during the
        // timeout period before the Job automatically deletes itself.
        // This test does reveal erroneous behaviour of the monitored system or elsewhere in the digital twin
        // This test also includes a normal error-free Job to test that failure of one Job does not interact with another healthy Job
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      
        // Process all the events on the event queue - note that Job_Alpha should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
        
        // Failed Job for a normal Job is an error condition that should move the Job into a failed state. Subsequent
        // audit events, if any, will be ignored
        failedJob ("Job_Alpha","AEO says the job has failed");
        //
        // Process all the events on the event queue - note that Job_Alpha should be in the 'JobFailed' state after this.
        Test::service_event_queue();
      //
        // Auth Job with single sequence but repeating event types
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
        
        // Process all the events on the event queue - note that Job_Gamma should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
        
        // Fire the timer that waits for optional branch events on Job_Gamma to arrive - no further branches are expected for this job type.
        theJob := find_only Job(jobID = "Job_Gamma");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Service the event queue again to process any events placed on queue resulting from the jobDeletionTimer for Job_Gamma being fired.
        // Note that Job_Gamma should have reached the 'JobSuccessful' state after this.
        Test::service_event_queue();
        
        // Check the state of each of the two jobs.
        theJobs := find Job ();
        theAJob := find_one Job (jobID = "Job_Alpha");
        theGJob := find_one Job (jobID = "Job_Gamma");
       
        Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theAJob.jobCompleted = false, "Job has completed but shouldn't have: " & theAJob.jobID);
        Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
        Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
        
        // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
        theJobs := find Job();
        for theJob in theJobs loop
          Test::fire_timer(theJob.jobDeletionTimer);
        end loop;
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //
        //
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test44FailedJobDebatableCondition() is
      @noparse
      theJob : instance of Job;
      theAJob : instance of Job;
      theGJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      //emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        //
        // The failedJob interaction from AEOrdering is received for a normal Job after the Job has completed
        // **** Current policy is that Failed Job trumps all behaviour in SVDC so the completed Job is deemed to have failed ****
        // This test does reveal erroneous behaviour of the monitored system or elsewhere in the digital twin
        // This test also includes a normal error-free Job to test that failure of one Job does not interact with another healthy Job
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
        
        // Process all the events on the event queue - note that Job_Alpha should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
        
        // Fire the timer that waits for optional branch events on Job_Alpha to arrive - no further branches are expected in this test
        theJob := find_only Job(jobID = "Job_Alpha");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Failed Job for a normal Job is an error condition that should move the Job into a failed state. Subsequent
        // audit events, if any, will be ignored
        failedJob ("Job_Alpha","AEO says the job has failed");
        
        // Process all the events on the event queue - note that Job_Alpha should be in the 'JobSuccessful' state after this.
        Test::service_event_queue();
      
      
        // Auth Job with single sequence but repeating event types
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
        
        // Process all the events on the event queue - note that Job_Gamma should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
        
        // Fire the timer that waits for optional branch events on Job_Gamma to arrive - no further branches are expected for this job type.
        theJob := find_only Job(jobID = "Job_Gamma");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Service the event queue again to process any events placed on queue resulting from the jobDeletionTimer for Job_Gamma being fired.
        // Note that Job_Gamma should have reached the 'JobSuccessful' state after this.
        Test::service_event_queue();
        
        // Check the state of each of the two jobs. 
        theJobs := find Job ();
        theAJob := find_one Job (jobID = "Job_Alpha");
        theGJob := find_one Job (jobID = "Job_Gamma");
        
        Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theAJob.jobCompleted = false, "Job has completed but shouldn't have: " & theAJob.jobID);
        Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
        Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
        
        // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
        theJobs := find Job();
        for theJob in theJobs loop
          Test::fire_timer(theJob.jobDeletionTimer);
        end loop;
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //
        //
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test45ErrorDetection() is
      @noparse
      theAJob : instance of Job;
      theGJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
        // This test does not reveal any erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
        
        // Process all the events on the event queue - note that Job_Alpha should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
        
        // Fire the timer that waits for optional branch events on Job_Alpha to arrive - no further branches are expected in this test
        theAJob := find_only Job(jobID = "Job_Alpha");
        Test::fire_timer(theAJob.jobEventTimer);
       
        // Process all the events on the event queue - note that Job_Alpha should be in the 'JobSuccessful' state after this.
        Test::service_event_queue();
        
       // Test::service_event_queue();
       // if (Test::get_scheduled_timers ())'length /= 0 then
       //   Test::fire_scheduled_timers();
      //  end if; 
        
        //******************************************************************************************************************************************************
        // Insert an extra event after the end of the Job. This should cause Job_Alpha to exit the 'JobSuccessful' state and transition to the 'JobFailed' state
        //******************************************************************************************************************************************************
        acceptOrderedEvent ("1620920060","agent-1234","AgentWritePayload","Job_Alpha","Ev55","Ev90",theAuditEventData);
      
      
      
        // Auth Job with single sequence but repeating event types
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
        
      
        // Process all the events on the event queue - note that Job_Gamma should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
        
        // Fire the timer that waits for optional branch events on Job_Gamma to arrive - no further branches are expected for this job type.
        theGJob := find_only Job(jobID = "Job_Gamma");
        Test::fire_timer(theGJob.jobEventTimer);
        
        // Service the event queue again to process any events placed on queue resulting from the jobDeletionTimer for Job_Gamma being fired.
        // Note that Job_Gamma should have reached the 'JobSuccessful' state after this.
        Test::service_event_queue();
        
        // Check the state of each of the two jobs.
        theAJob := find_one Job (jobID = "Job_Alpha");
        theGJob := find_one Job (jobID = "Job_Gamma");
      
        Assertions::assertTrue(theAJob.jobCompleted = false, "Job has completed but should have failed: " & theAJob.jobID);
        Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
        Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
        
        // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
        theJobs := find Job();
        for theJob in theJobs loop
          Test::fire_timer(theJob.jobDeletionTimer);
        end loop;
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //
        //
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test46ErrorDetectionForkAndMerge() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 1 sequences based on a fork and merge path definition - there are 3 branches
        // This test reveals erroneous behaviour of the twin
        //
        acceptOrderedEvent ("1620920000","Test-0001","FMA","Job_FandM",previousEvents,"Ev301",theAuditEventData);
        previousEvents := ("Ev301");
        acceptOrderedEvent ("1620920001","Test-0001","FMB","Job_FandM",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev305",theAuditEventData);
        // Error caused by an unexpected previous event type occurring at the merge
        previousEvents := empty & "Ev302" & "Ev303" & "Ev304" & "Ev305";
        acceptOrderedEvent ("1620920006","Test-0001","FMF","Job_FandM",previousEvents,"Ev306",theAuditEventData);
        previousEvents := ("Ev306");
        acceptOrderedEvent ("1620920007","Test-0001","FMG","Job_FandM",previousEvents,"Ev307",theAuditEventData);
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
        end loop;  
        
          
        
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test47ErrorDetectionForkAndMerge() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 1 sequences based on a fork and merge path definition - there are 3 branches
        // This test test for erroneous behaviour of the twin
        //
        acceptOrderedEvent ("1620920000","Test-0001","FMA","Job_FandM",previousEvents,"Ev301",theAuditEventData);
        previousEvents := ("Ev301");
        acceptOrderedEvent ("1620920001","Test-0001","FMB","Job_FandM",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev305",theAuditEventData);
        // Error caused by a missing previous event type occurring at the merge
        previousEvents := empty & "Ev304" & "Ev305";
        acceptOrderedEvent ("1620920006","Test-0001","FMF","Job_FandM",previousEvents,"Ev306",theAuditEventData);
        previousEvents := ("Ev306");
        acceptOrderedEvent ("1620920007","Test-0001","FMG","Job_FandM",previousEvents,"Ev307",theAuditEventData);
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
        end loop;  
        
          
        
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test48ErrorDetectionIllegalSequenceEnd() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Jobs with 2 sequences and all events are in the standard default order
        // This test does reveal any erroneous behaviour of the twin
        // The Audit Event "GatewayWritePayload" is defined as a sequence end point and so should never occur 
        // as a previous event id but in this erroneous scenario it does. This should therefore be detected as an error
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        // Error inserted here: The first event of the Mid Sequence now has an inappropriate previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","Ev12","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
      //  theSequences := theJobs -> R10;
      //  theAuditEvents := theSequences -> R11;
        
        //Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        //Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        //Assertions::assertTrue(theAuditEvents'length = 25, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
          Assertions::assertTrue(theJob.sequencingFailed, "Sequencing hasn't failed and it should have: " & theJob.jobID);
        end loop;  end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test49ErrorDetectionIllegalSequenceEnd() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 1 sequence using an illegal path definition to test that the model detects
        // an audit event end point occurring in a previous event id.
        // This test does reveals an erroneous event definition
        //
        acceptOrderedEvent ("1620920000","Test-0001","MALA","Illegal_Job",previousEvents,"Ev301",theAuditEventData);
        previousEvents := ("Ev301");
        acceptOrderedEvent ("1620920001","Test-0001","MALB","Illegal_Job",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        // The following audit event corresponds to an audit event definition that is defined as end of sequence
        // yet there is a following event. This should be trapped as an error condition
        acceptOrderedEvent ("1620920002","Test-0001","MALC","Illegal_Job",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev303");
        acceptOrderedEvent ("1620920002","Test-0001","MALD","Illegal_Job",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev304");
        acceptOrderedEvent ("1620920002","Test-0001","MALE","Illegal_Job",previousEvents,"Ev305",theAuditEventData);
       //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test50ErrorDetectionInstanceForkAndMergePath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 1 sequence based on a fork and merge path definition - there are 10 branches but only 
        // 9 merge events so this is erroneous
        // This test does  reveal any erroneous behaviour of the twin
        //
        acceptOrderedEvent ("1620920000","Test-0001","IFA","Instance_FandM_Job",previousEvents,"Ev301",theAuditEventData);
        previousEvents := ("Ev301");
        acceptOrderedEvent ("1620920001","Test-0001","IFB","Instance_FandM_Job",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev305",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev306",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev307",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev308",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev309",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev310",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev311",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev312",theAuditEventData);
        //Error inserted here since Ev312 is missing
        previousEvents := empty & "Ev303" & "Ev304" & "Ev305" & "Ev306" & "Ev307" & "Ev308" & "Ev309" & "Ev310" & "Ev311";
        acceptOrderedEvent ("1620920003","Test-0001","IFD","Instance_FandM_Job",previousEvents,"Ev313",theAuditEventData);
        previousEvents := ("Ev313");
        acceptOrderedEvent ("1620920004","Test-0001","IFE","Instance_FandM_Job",previousEvents,"Ev314",theAuditEventData);
       //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
        end loop;  
       end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test51ErrorDetectionInstanceForkAndMergePath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 1 sequence based on a fork and merge path definition - there are 10 branches but only 
        // 9 merge events so this is erroneous
        // This test does  reveal any erroneous behaviour of the twin
        //
        acceptOrderedEvent ("1620920000","Test-0001","IFA","Instance_FandM_Job",previousEvents,"Ev301",theAuditEventData);
        previousEvents := ("Ev301");
        acceptOrderedEvent ("1620920001","Test-0001","IFB","Instance_FandM_Job",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev305",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev306",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev307",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev308",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev309",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev310",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev311",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920002","Test-0001","IFC","Instance_FandM_Job",previousEvents,"Ev312",theAuditEventData);
        //Error inserted here since Ev312 is missing and Ev303 is repeated
        previousEvents := empty & "Ev303" & "Ev304" & "Ev305" & "Ev306" & "Ev307" & "Ev308" & "Ev309" & "Ev310" & "Ev311" & "Ev303";
        acceptOrderedEvent ("1620920003","Test-0001","IFD","Instance_FandM_Job",previousEvents,"Ev313",theAuditEventData);
        previousEvents := ("Ev313");
        acceptOrderedEvent ("1620920004","Test-0001","IFE","Instance_FandM_Job",previousEvents,"Ev314",theAuditEventData);
       //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
        end loop;  
       end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test52ErrorDetectionInstanceAndTypeForkAndMergePath() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 1 sequence based on a fork and merge path definition - 
        // there are 3 type branches and each type branch has 5 instance branches 
        // all at the same fork point
        // This test does reveal any erroneous behaviour of the twin since a previous event is repeated
        //
        acceptOrderedEvent ("1620920000","Test-0001","FMA","Job_FandM",previousEvents,"Ev301",theAuditEventData);
        previousEvents := ("Ev301");
        acceptOrderedEvent ("1620920001","Test-0001","FMB","Job_FandM",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev305",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev306",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMC","Job_FandM",previousEvents,"Ev307",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev308",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev309",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev310",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev311",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FMD","Job_FandM",previousEvents,"Ev312",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev313",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev314",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev315",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev316",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","FME","Job_FandM",previousEvents,"Ev317",theAuditEventData);
         
        // The merge point with error as Ev303 is repeated and Ev304 is missing so the count is still correct
        previousEvents := empty & "Ev303" & "Ev303" & "Ev305" & "Ev306" & "Ev307" & "Ev308" & "Ev309" & "Ev310" & "Ev311" & "Ev312" & "Ev313" & "Ev314" & "Ev315" & "Ev316" & "Ev317";
        acceptOrderedEvent ("1620920006","Test-0001","FMF","Job_FandM",previousEvents,"Ev318",theAuditEventData);
        previousEvents := ("Ev318");
        acceptOrderedEvent ("1620920007","Test-0001","FMG","Job_FandM",previousEvents,"Ev319",theAuditEventData);
        //
        Test::service_event_queue();
        if (Test::get_scheduled_timers ())'length /= 0 then
          Test::fire_scheduled_timers();
        end if; 
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        //
        for theJob in theJobs loop
          Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed but shouldn't have: " & theJob.jobID);
        end loop;  
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test53ErrorDetectionConstraintViolation() is
      @noparse
      theAJob : instance of Job;
      theGJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
        // However, Event 9a is omitted meaning that the AND constraint following the AgentReceiveWidgets event
        // will be violated. This should cause the Job to fail with a constraint violation
        // This test does reveal any erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        // Error introduced here: The following event is commented out to cause a constraint violation
        //acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      
        // Process all the events on the event queue - note that Job_Alpha should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
        
        // Fire the timer that waits for other branch events on Job_Alpha to arrive - but the start of the AND-constrained branch had failed to arrive
        // before this, so the Job will progress as if no more sequences are expected and will progress to the 'AssessingJobConstraints' state where
        // it is expected to fail once the event queue has been fully processed.
        theAJob := find_only Job(jobID = "Job_Alpha");
        Test::fire_timer(theAJob.jobEventTimer);
       
        // Process all the events on the event queue - note that Job_Alpha should be in the 'JobFailed' state after this.
        Test::service_event_queue();
      //
        // Auth Job with single sequence but repeating event types
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
        
        // Process all the events on the event queue - note that Job_Gamma should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
        
        // Fire the timer that waits for optional branch events on Job_Gamma to arrive - no further branches are expected for this job type.
        theGJob := find_only Job(jobID = "Job_Gamma");
        Test::fire_timer(theGJob.jobEventTimer);
        
        // Service the event queue again to process any events placed on queue resulting from the jobDeletionTimer for Job_Gamma being fired.
        // Note that Job_Gamma should have reached the 'JobSuccessful' state after this.
        Test::service_event_queue();
        
        // Check the state of each of the two jobs. 
        theAJob := find_one Job (jobID = "Job_Alpha");
        theGJob := find_one Job (jobID = "Job_Gamma");
      
        Assertions::assertTrue(theAJob.jobCompleted = false, "Job is completed but shouldn't have: " & theAJob.jobID);
        Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
        Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
        
        // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
        theJobs := find Job();
        for theJob in theJobs loop
          Test::fire_timer(theJob.jobDeletionTimer);
        end loop;
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //
        //
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test53aErrorDetectionANDConstraintViolation() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers a very special situation. It injects JobComplete from AEOrdering at the point where one branch
        // of a BankTransfer sequence has completed but another branch (if there is one) hasn't started. The events for the
        // other branch arrive after JobComplete which would be erroneous behaviour of AEOrdering. The model ignores JobComplete
        // in this specific circumstance because it looks just like a legitimate end of a Job prior to the Job timeout. Compare with Test39.
        // This test does reveals some anomalous behaviour of this system but it is not classed as an error condition.
        //
        // Normal Mid sequence starts here
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        // Normal Far Side sequence starts here
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
        // Near side sequence starts here
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        // The following event is an end point event which occurs here before the branch is obvious
        // This tests the system does not prematurely indicate Job Complete
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
      
        // Mimic the interaction from AEOrdering called jobComplete which is interpreted as a Job Timeout in this domain.
        // Note that jobComplete being injected here is an error condition because this should not occur until all events for a Job have been received
        jobComplete ("Job_Alpha");
        
        // Process all the events on the event queue (including the jobTimedOut event). At this point in the test the Job should 
        // have reached the 'AssessingSequenceCompletion' state and so will ignore the jobTimedOut event.
        Test::service_event_queue();
        
        // Fire the timer that waits for alternative branch events on Job_Alpha to arrive - this mimics the situation where 
        // the events for Job_Alpha that follow (see befar) arrive too late to be processed but the Job proceeds (wrongly) on
        // on basis that all sequences must have been received.
        theJob := find_only Job(jobID = "Job_Alpha");
        Test::fire_timer(theJob.jobEventTimer);
        
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
      
        // Process all the events on the event queue - all of the above events will simply be ignored.
        Test::service_event_queue();
        
      
        // This is a separate Auth Job not fundamental to the test
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
      
        // Process all the events on the event queue
        Test::service_event_queue();
        
        // Fire the timer that waits for alternative branch events on Job_Gamma to start - no branch expected in this test.
        theJob := find_only Job(jobID = "Job_Gamma");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Process all the events on the event queue resulting from the state actions that are executed following the
        // jobEventTimer being fired - this will result in Job_Gamma reaching the 'JobSuccessful' state.
        Test::service_event_queue();
        
        //if (Test::get_scheduled_timers ())'length /= 0 then
        //  Test::fire_scheduled_timers();
        //end if;
        theJobs := find Job ();
        theSequences := theJobs -> R10;
        theAuditEvents := theSequences -> R11;
        
        Assertions::assertTrue(theJobs'length = 2, "Wrong number of jobs created: " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 4, "Wrong number of sequences created: " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 21, "Wrong number of audit events created: " & (theAuditEvents'length)'image);
      
        for theJob in theJobs loop
          if theJob.jobID = "Job_Alpha" then
            Assertions::assertTrue(theJob.jobCompleted = false, "Job is erroneously completed - jobID " & theJob.jobID);
          else
            Assertions::assertTrue(theJob.jobCompleted, "Job is incomplete: " & theJob.jobID);
            Assertions::assertTrue(theJob.sequencingFailed = false, "Sequencing has failed: " & theJob.jobID);
          end if;
          //Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed though an invariant was attached to the wrong audit event: " & theJob.jobID);
        end loop;
        
        // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
        theJobs := find Job();
        for theJob in theJobs loop
          Test::fire_timer(theJob.jobDeletionTimer);
        end loop;
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        // 
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test54ErrorDetectionXORConstraintViolation() is
      @noparse
      theAJob : instance of Job;
      theGJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 2 Jobs with 4 sequences and all events are in the standard default order
        // It includes both events following an XOR constraint at Ev14 - this is an error condition
        // This test does reveal any erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        acceptOrderedEvent ("1620920000","export-control-1234","NearInput","Job_Alpha","","Ev1",theAuditEventData);
        acceptOrderedEvent ("1620920001","export-control-1234","NearPartWrite","Job_Alpha","Ev1","Ev2",theAuditEventData);
        acceptOrderedEvent ("1620920002","export-control-1234","NearJustificationWrite","Job_Alpha","Ev2","Ev3",theAuditEventData);
        acceptOrderedEvent ("1620920003","agent-1234","AgentRequestWidgets","Job_Alpha","Ev3","Ev4",theAuditEventData);
        acceptOrderedEvent ("1620920004","authoriser-1234","AuthoriserReadWidgetRequest","Job_Alpha","Ev4","Ev5",theAuditEventData);
        acceptOrderedEvent ("1620920005","authoriser-1234","AuthoriserParsedJustification","Job_Alpha","Ev5","Ev6",theAuditEventData);
        acceptOrderedEvent ("1620920006","authoriser-1234","AuthoriserSendWidgets","Job_Alpha","Ev6","Ev7",theAuditEventData);
        acceptOrderedEvent ("1620920007","agent-1234","AgentReceiveWidgets","Job_Alpha","Ev7","Ev8",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentPartRead","Job_Alpha","Ev8","Ev9",theAuditEventData);
        acceptOrderedEvent ("1620920008","agent-1234","AgentProcessedRequest","Job_Alpha","Ev8","Ev9a",theAuditEventData);
        acceptOrderedEvent ("1620920009","agent-1234","AgentWritePayload","Job_Alpha","Ev9","Ev10",theAuditEventData);
        acceptOrderedEvent ("1620920010","gateway-1234","GatewayReadPayload","Job_Alpha","Ev10","Ev11",theAuditEventData);
        acceptOrderedEvent ("1620920011","gateway-1234","GatewayWritePayload","Job_Alpha","Ev11","Ev12",theAuditEventData);
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920012","mid-1234","MidProcessPayload","Job_Alpha","","Ev13",theAuditEventData);
        // This is a variant of Test01NormalPath where the following 2 events are violating an exclusive Or constraint 
        acceptOrderedEvent ("1620920013","mid-1234","MidWritePayload","Job_Alpha","Ev13","Ev14",theAuditEventData);
        acceptOrderedEvent ("1620920013","mid-1234","MidPayloadError","Job_Alpha","Ev13","Ev14a",theAuditEventData);
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        acceptOrderedEvent ("1620920050","import_control-1234","FarInput","Job_Alpha","","Ev50",theAuditEventData);
        acceptOrderedEvent ("1620920055","import_control-1234","FarOutput","Job_Alpha","Ev50","Ev55",theAuditEventData);
      
        // Process all the events on the event queue - note that Job_Alpha should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
      
        // Fire the timer that waits for other branch events on Job_Alpha to arrive - the unexpected extra event that represents the start of 
        // another branch will be accepted at this point because it satisfies the sequence specification but will later fail the constraint
        // checks which are done once the job is considered to have completed.
        theAJob := find_only Job(jobID = "Job_Alpha");
        Test::fire_timer(theAJob.jobEventTimer);
       
        // Process all the events on the event queue - note that Job_Alpha should be in the 'JobFailed' state after this because
        // the job will have failed the constraint checks.
        Test::service_event_queue();
        
        
        // Auth Job with single sequence but repeating event types
        acceptOrderedEvent ("1620920100","Auth-0001","AuthoriserSendOrderRequest","Job_Gamma","","Ev201",theAuditEventData);
        acceptOrderedEvent ("1620920101","Auth-0001","AuthReceiveRequest","Job_Gamma","Ev201","Ev202",theAuditEventData);
        acceptOrderedEvent ("1620920102","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev202","Ev203",theAuditEventData);
        acceptOrderedEvent ("1620920103","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev203","Ev204",theAuditEventData);
        acceptOrderedEvent ("1620920104","Auth-0001","AuthSendMidRequest","Job_Gamma","Ev204","Ev205",theAuditEventData);
        acceptOrderedEvent ("1620920105","Auth-0001","AuthReceiveMidResponse","Job_Gamma","Ev205","Ev206",theAuditEventData);
        acceptOrderedEvent ("1620920106","Auth-0001","AuthSendResponse","Job_Gamma","Ev206","Ev207",theAuditEventData);
        acceptOrderedEvent ("1620920107","Auth-0001","AuthoriserReceiveOrder","Job_Gamma","Ev207","Ev208",theAuditEventData);
        
        // Process all the events on the event queue - note that Job_Gamma should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
        
        // Fire the timer that waits for optional branch events on Job_Gamma to arrive - no further branches are expected for this job type.
        theGJob := find_only Job(jobID = "Job_Gamma");
        Test::fire_timer(theGJob.jobEventTimer);
        
        // Service the event queue again to process any events placed on queue resulting from the jobDeletionTimer for Job_Gamma being fired.
        // Note that Job_Gamma should have reached the 'JobSuccessful' state after this.
        Test::service_event_queue();
        
        // Check the state of each of the two jobs.
        theAJob := find_one Job (jobID = "Job_Alpha");
        theGJob := find_one Job (jobID = "Job_Gamma");
        Assertions::assertTrue(theAJob.jobCompleted = false, "Job is completed but shouldn't have: " & theAJob.jobID);
        Assertions::assertTrue(theGJob.jobCompleted, "Job is incomplete: " & theGJob.jobID);
        Assertions::assertTrue(theGJob.sequencingFailed = false, "Sequencing has failed: " & theGJob.jobID);
        
        // Fire the jobDeletionTimer for both jobs (Job_Alpha and Job_Gamma) - this will result in them being deleted.
        theJobs := find Job();
        for theJob in theJobs loop
          Test::fire_timer(theJob.jobDeletionTimer);
        end loop;
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Alpha & Job_Gamma being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //
        //
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test55InvalidIntraJobInvariant() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers introduces mismatching invariant values which is an error condition
        // This test does reveal any erroneous behaviour of the twin
        //
        previousEvents := empty;
        theAuditEventData := (aeDataKindEnum.INTRAJOBINV, "InvA", "A12345");
        acceptOrderedEvent ("1620920000","Test-0001","SFMA","Job_Split_FandM",previousEvents,"Ev301",theAuditEventData);
        previousEvents := ("Ev301");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Test-0001","SFMB","Job_Split_FandM",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Test-0001","SFMC","Job_Split_FandM",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Test-0001","SFMD","Job_Split_FandM",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Test-0001","SFME","Job_Split_FandM",previousEvents,"Ev305",theAuditEventData);
        previousEvents := empty;
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Test-0001","SFMC1","Job_Split_FandM",previousEvents,"Ev306",theAuditEventData);
        previousEvents := empty;
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Test-0001","SFMD1","Job_Split_FandM",previousEvents,"Ev307",theAuditEventData);
        previousEvents := empty;
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Test-0001","SFME1","Job_Split_FandM",previousEvents,"Ev308",theAuditEventData);
        previousEvents := empty & "Ev306" & "Ev307" & "Ev308";
        theAuditEventData := (aeDataKindEnum.INTRAJOBINV, "InvA", "A54321");
        acceptOrderedEvent ("1620920006","Test-0001","SFMF","Job_Split_FandM",previousEvents,"Ev309",theAuditEventData);
        previousEvents := ("Ev309");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920007","Test-0001","SFMG","Job_Split_FandM",previousEvents,"Ev310",theAuditEventData);
        
        // Process all the events on the event queue - note that Job_Split_FandM should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
      
        // Fire the timer that waits for other branch events on Job_Split_FandM to arrive - and the job will proceed to constraint and 
        // invariant checking where it will fail the invariant checks.
        theJob := find_only Job(jobID = "Job_Split_FandM");
        Test::fire_timer(theJob.jobEventTimer);
       
        // Process all the events on the event queue - note that Job_Split_FandM should be in the 'JobFailed' state after this because
        // the job will have failed the invariant checks.
        Test::service_event_queue(); 
        
        // Check the state of Job_Split_FandM is as expected
        Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed though the invariant was invalid: " & theJob.jobID);
        
        // Fire the jobDeletionTimer for Job_Split_FandM - this will result in it being deleted.
        Test::fire_timer(theJob.jobDeletionTimer);
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Split_FandM being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //
        //
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test56InvalidIntraJobInvariant() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      logMessage : string;
      
      begin
        // This test covers introduces a matching invariant but attached to an invalid audit event
        // This test does reveal any erroneous behaviour of the twin
        //
        previousEvents := empty;
        theAuditEventData := (aeDataKindEnum.INTRAJOBINV, "InvA", "A12345");
        acceptOrderedEvent ("1620920000","Test-0001","SFMA","Job_Split_FandM",previousEvents,"Ev301",theAuditEventData);
        previousEvents := ("Ev301");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Test-0001","SFMB","Job_Split_FandM",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Test-0001","SFMC","Job_Split_FandM",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Test-0001","SFMD","Job_Split_FandM",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Test-0001","SFME","Job_Split_FandM",previousEvents,"Ev305",theAuditEventData);
        previousEvents := empty;
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Test-0001","SFMC1","Job_Split_FandM",previousEvents,"Ev306",theAuditEventData);
        previousEvents := empty;
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Test-0001","SFMD1","Job_Split_FandM",previousEvents,"Ev307",theAuditEventData);
        previousEvents := empty;
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Test-0001","SFME1","Job_Split_FandM",previousEvents,"Ev308",theAuditEventData);
        previousEvents := empty & "Ev306" & "Ev307" & "Ev308";
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920006","Test-0001","SFMF","Job_Split_FandM",previousEvents,"Ev309",theAuditEventData);
        previousEvents := ("Ev309");
        theAuditEventData := (aeDataKindEnum.INTRAJOBINV, "InvA", "A12345");
        acceptOrderedEvent ("1620920007","Test-0001","SFMG","Job_Split_FandM",previousEvents,"Ev310",theAuditEventData);
        //
        // Process all the events on the event queue - note that Job_Split_FandM should be in the 'JobFailed' state after this.
        Test::service_event_queue();
            
        // Check the state of Job_Split_FandM is as expected
        theJob := find_only Job(jobID = "Job_Split_FandM");
        Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed though an invariant was attached to the wrong audit event: " & theJob.jobID);
       
        
       // Fire the jobDeletionTimer for Job_Split_FandM - this will result in it being deleted.
        Test::fire_timer(theJob.jobDeletionTimer);
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Split_FandM being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //
        //
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test57MissingInvariants() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      previousEvents : sequence of string;
      empty : sequence of string;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      
      begin
        // This test covers 1 Job with 2 sequences based on a fork and merge path definition - the first
        // sequence contains a fork to 3 branches and the second sequence contains a merge back to a single branch
        // This test does not reveal any erroneous behaviour of the twin
        //
        previousEvents := empty;
        acceptOrderedEvent ("1620920000","Test-0001","SFMA","Job_Split_FandM",previousEvents,"Ev301",theAuditEventData);
        previousEvents := ("Ev301");
        acceptOrderedEvent ("1620920001","Test-0001","SFMB","Job_Split_FandM",previousEvents,"Ev302",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","SFMC","Job_Split_FandM",previousEvents,"Ev303",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","SFMD","Job_Split_FandM",previousEvents,"Ev304",theAuditEventData);
        previousEvents := ("Ev302");
        acceptOrderedEvent ("1620920001","Test-0001","SFME","Job_Split_FandM",previousEvents,"Ev305",theAuditEventData);
        previousEvents := empty;
        acceptOrderedEvent ("1620920005","Test-0001","SFMC1","Job_Split_FandM",previousEvents,"Ev306",theAuditEventData);
        previousEvents := empty;
        acceptOrderedEvent ("1620920005","Test-0001","SFMD1","Job_Split_FandM",previousEvents,"Ev307",theAuditEventData);
        previousEvents := empty;
        acceptOrderedEvent ("1620920005","Test-0001","SFME1","Job_Split_FandM",previousEvents,"Ev308",theAuditEventData);
        previousEvents := empty & "Ev306" & "Ev307" & "Ev308";
        acceptOrderedEvent ("1620920006","Test-0001","SFMF","Job_Split_FandM",previousEvents,"Ev309",theAuditEventData);
        previousEvents := ("Ev309");
        acceptOrderedEvent ("1620920007","Test-0001","SFMG","Job_Split_FandM",previousEvents,"Ev310",theAuditEventData);
        
        // Process all the events on the event queue - note that Job_Split_FandM should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
      
        // Fire the timer that waits for other branch events on Job_Split_FandM to arrive - and the job will proceed to constraint and 
        // invariant checking where it will fail the invariant checks.
        theJob := find_only Job(jobID = "Job_Split_FandM");
        Test::fire_timer(theJob.jobEventTimer);
       
        // Process all the events on the event queue - note that Job_Split_FandM should be in the 'JobFailed' state after this because
        // the job will have failed the invariant checks.
        Test::service_event_queue();
        
        // Check the state of Job_Split_FandM is as expected
        Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed expected invariants were missing: " & theJob.jobID);
      
      
      // Fire the jobDeletionTimer for Job_Split_FandM - this will result in it being deleted.
        Test::fire_timer(theJob.jobDeletionTimer);
        
        // Service the event queue again to process any events placed on queue resulting from  
        // the jobDeletionTimer for Job_Split_FandM being fired.
        Test::service_event_queue();
        
        //...and finally test that all the jobs and their associated sequences and events have been clean up appropriately.
        theJobs := find Job();
        theSequences := find Sequence();
        theAuditEvents := find AuditEvent();
        
        Assertions::assertTrue(theJobs'length = 0, "Not all jobs were deleted - number of Jobs remaining = " & (theJobs'length)'image);
        Assertions::assertTrue(theSequences'length = 0, "Not all sequences were deleted - number of sequences remaining = " & (theSequences'length)'image);
        Assertions::assertTrue(theAuditEvents'length = 0, "Not all events were deleted - number of events remaining = " & (theAuditEvents'length)'image);
        //
        //
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test58InvalidUserExtraJobInvariant() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      theUserInvariants : set of instance of TransientInvariant;
      theSourceInvariants : set of instance of PersistedInvariant;
      previousEvents : sequence of string;
      empty : sequence of string;
      thePersistedInvariants : set of instance of PersistedInvariant;
      thePersistedInvariant : instance of PersistedInvariant;
      logMessage : string;
      
      begin
        // NOTE THIS TEST CREATES THE PERSISTED INVARIANTS THAT OTHER FOLLOWING TESTS USE
      
        // This test initially creates 1 Auth Job with 2 persistentinvariant values being defined
        // This part of the test does not reveal any erroneous behaviour of the twin
        //
        previousEvents := empty;
        //theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent987654321");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920000","Auth-0001","EAuthoriserSendOrderRequest","Job_PersistentInvariant",previousEvents,"Ev1201",theAuditEventData);
        previousEvents := ("Ev1201");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Auth-0001","EAuthReceiveRequest","Job_PersistentInvariant",previousEvents,"Ev1202",theAuditEventData);
        previousEvents := ("Ev1202");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920002","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1203",theAuditEventData);
        previousEvents := ("Ev1203");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920003","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1204",theAuditEventData);
        previousEvents := ("Ev1204");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920004","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1205",theAuditEventData);
        previousEvents := ("Ev1205");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1206",theAuditEventData);
        previousEvents := ("Ev1206");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920006","Auth-0001","EAuthSendResponse","Job_PersistentInvariant",previousEvents,"Ev1207",theAuditEventData);
        previousEvents := ("Ev1207");
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920007","Auth-0001","EAuthoriserReceiveOrder","Job_PersistentInvariant",previousEvents,"Ev1208",theAuditEventData);
       
        //
        Test::service_event_queue();
        theJob := find_only Job(jobID = "Job_PersistentInvariant");
        Test::fire_timer(theJob.jobEventTimer);
        
        
        // It then deletes the Job that created the PersistentInvariant values but retains the persistentinvariant values as PersistedInvariants
        deleteJob ("Job_PersistentInvariant");
        theSourceInvariants := find PersistedInvariant(inForce = true);
        Assertions::assertTrue(theSourceInvariants'length = 1, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
        
        
        // This test tests that invalid persistentinvariant is spotted and the Job fails
        // One value of persistentinvariant is incorrect
        // This test does reveal any erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920000","export-control-1234","ENearInput","Job_PersistentInvariant_Use","","Ev1",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","export-control-1234","ENearPartWrite","Job_PersistentInvariant_Use","Ev1","Ev2",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920002","export-control-1234","ENearJustificationWrite","Job_PersistentInvariant_Use","Ev2","Ev3",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920003","agent-1234","EAgentRequestWidgets","Job_PersistentInvariant_Use","Ev3","Ev4",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920004","authoriser-1234","EAuthoriserReadWidgetRequest","Job_PersistentInvariant_Use","Ev4","Ev5",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","authoriser-1234","EAuthoriserParsedJustification","Job_PersistentInvariant_Use","Ev5","Ev6",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920006","authoriser-1234","EAuthoriserSendWidgets","Job_PersistentInvariant_Use","Ev6","Ev7",theAuditEventData);
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920007","agent-1234","EAgentReceiveWidgets","Job_PersistentInvariant_Use","Ev7","Ev8",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920008","agent-1234","EAgentPartRead","Job_PersistentInvariant_Use","Ev8","Ev9",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920008","agent-1234","EAgentProcessedRequest","Job_PersistentInvariant_Use","Ev8","Ev9a",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920009","agent-1234","EAgentWritePayload","Job_PersistentInvariant_Use","Ev9","Ev10",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920010","gateway-1234","EGatewayReadPayload","Job_PersistentInvariant_Use","Ev10","Ev11",theAuditEventData);
        
        // Error here: The following audit event is expecting persistentinvariant but the persistentinvariant provided is of the wrong value
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent2222222222");
        acceptOrderedEvent ("1620920011","gateway-1234","EGatewayWritePayload","Job_PersistentInvariant_Use","Ev11","Ev12",theAuditEventData);
        
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920012","mid-1234","EMidProcessPayload","Job_PersistentInvariant_Use","","Ev13",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920013","mid-1234","EMidWritePayload","Job_PersistentInvariant_Use","Ev13","Ev14",theAuditEventData);
        
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920050","import_control-1234","EFarInput","Job_PersistentInvariant_Use","","Ev50",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920055","import_control-1234","EFarOutput","Job_PersistentInvariant_Use","Ev50","Ev55",theAuditEventData);
      //
        //
        Test::service_event_queue();
        
        theJob := find_only Job(jobID = "Job_PersistentInvariant_Use");
        Test::fire_timer(theJob.jobEventTimer);
      
        Test::service_event_queue();
        
        //theJobs := find Job ();
        //theSequences := theJobs -> R10;
        //theAuditEvents := theSequences -> R11;
        //theUserInvariants := theAuditEvents -> R23;
        //theSourceInvariants := find PersistedInvariant(inForce = true);
        
        // Check the Job has failed
        Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed though the extra job invariant was invalid: " & theJob.jobID);
        
        // ... and finally clear down all the existing instances of PersistedInvariant in readiness for other tests.
        thePersistedInvariants := find PersistedInvariant();
        for thePersistedInvariant in thePersistedInvariants loop
          thePersistedInvariant.deletePersistedInvariant();   
        end loop;
        
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test59InvalidUserExtraJobInvariant() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      //theUserInvariants : set of instance of TransientInvariant;
      theSourceInvariants : set of instance of PersistedInvariant;
      theCorrespondingSourceInvariants : set of instance of PersistedInvariant;
      eachCorrespondingSourceInvariant : instance of PersistedInvariant;
      previousEvents : sequence of string;
      empty : sequence of string;
      thePersistedInvariants : set of instance of PersistedInvariant;
      thePersistedInvariant : instance of PersistedInvariant;
      logMessage : string;
      
      begin
        // This test initially creates 1 Auth Job with 2 persistentinvariant values being defined
        // This part of the test does not reveal any erroneous behaviour of the twin
        //
        previousEvents := empty;
        //theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent987654321");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920000","Auth-0001","EAuthoriserSendOrderRequest","Job_PersistentInvariant",previousEvents,"Ev1201",theAuditEventData);
        previousEvents := ("Ev1201");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Auth-0001","EAuthReceiveRequest","Job_PersistentInvariant",previousEvents,"Ev1202",theAuditEventData);
        previousEvents := ("Ev1202");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920002","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1203",theAuditEventData);
        previousEvents := ("Ev1203");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920003","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1204",theAuditEventData);
        previousEvents := ("Ev1204");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920004","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1205",theAuditEventData);
        previousEvents := ("Ev1205");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1206",theAuditEventData);
        previousEvents := ("Ev1206");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920006","Auth-0001","EAuthSendResponse","Job_PersistentInvariant",previousEvents,"Ev1207",theAuditEventData);
        previousEvents := ("Ev1207");
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920007","Auth-0001","EAuthoriserReceiveOrder","Job_PersistentInvariant",previousEvents,"Ev1208",theAuditEventData);
       
        // Process all the events on the event queue - at this point in the test Job_PersistentInvariant should 
        // have reached the 'AssessingSequenceCompletion' state
        Test::service_event_queue();
        
        // Fire the timer that waits for alternative branch events on Job_PersistentInvariant to arrive - and the job will proceed to constraint and 
        // invariant checking where it will pass all the invariant checks and proceed into the 'JobSuccessful' state.
        theJob := find_only Job(jobID = "Job_PersistentInvariant");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Delete the Job that created the PersistentInvariant values but retain the persistentinvariant values as PersistedInvariants
        deleteJob ("Job_PersistentInvariant");
       
        // Check that the Persisted Invariants are still present and in force
        theSourceInvariants := find PersistedInvariant(inForce = true);   
        Assertions::assertTrue(theSourceInvariants'length = 1, "Wrong number of source invariants in force: " & (theSourceInvariants'length)'image);
        
        // With the PersistentInvariants now in place, this test now goes on to check that valid persistentinvariant attached to the wrong event is spotted and the Job fails.
        // One value of persistentinvariant is incorrectly attached all the other value are correct and correctly attached
        // This test does reveal erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920000","export-control-1234","ENearInput","Job_PersistentInvariant_Use","","Ev1",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","export-control-1234","ENearPartWrite","Job_PersistentInvariant_Use","Ev1","Ev2",theAuditEventData);  
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920002","export-control-1234","ENearJustificationWrite","Job_PersistentInvariant_Use","Ev2","Ev3",theAuditEventData);  
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920003","agent-1234","EAgentRequestWidgets","Job_PersistentInvariant_Use","Ev3","Ev4",theAuditEventData); 
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920004","authoriser-1234","EAuthoriserReadWidgetRequest","Job_PersistentInvariant_Use","Ev4","Ev5",theAuditEventData);  
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","authoriser-1234","EAuthoriserParsedJustification","Job_PersistentInvariant_Use","Ev5","Ev6",theAuditEventData); 
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920006","authoriser-1234","EAuthoriserSendWidgets","Job_PersistentInvariant_Use","Ev6","Ev7",theAuditEventData); 
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920007","agent-1234","EAgentReceiveWidgets","Job_PersistentInvariant_Use","Ev7","Ev8",theAuditEventData); 
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920008","agent-1234","EAgentPartRead","Job_PersistentInvariant_Use","Ev8","Ev9",theAuditEventData); 
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920008","agent-1234","EAgentProcessedRequest","Job_PersistentInvariant_Use","Ev8","Ev9a",theAuditEventData); 
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920009","agent-1234","EAgentWritePayload","Job_PersistentInvariant_Use","Ev9","Ev10",theAuditEventData);
        
        // Error here: The following event is not expected to carry persistentinvariant but does so erroneously in this case. The Job should fail.
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920010","gateway-1234","EGatewayReadPayload","Job_PersistentInvariant_Use","Ev10","Ev11",theAuditEventData);
      
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920011","gateway-1234","EGatewayWritePayload","Job_PersistentInvariant_Use","Ev11","Ev12",theAuditEventData);
        // End of Bank Transfer Sequence
        
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920012","mid-1234","EMidProcessPayload","Job_PersistentInvariant_Use","","Ev13",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920013","mid-1234","EMidWritePayload","Job_PersistentInvariant_Use","Ev13","Ev14",theAuditEventData);
        
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920050","import_control-1234","EFarInput","Job_PersistentInvariant_Use","","Ev50",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920055","import_control-1234","EFarOutput","Job_PersistentInvariant_Use","Ev50","Ev55",theAuditEventData);
      //
        // Process all the events on the event queue - note that Job_PersistentInvariant_Use should be in the 'JobFailed' state after this.
        Test::service_event_queue();
       
        // Check the state of Job_PersistentInvariant_Use is as expected
        theJob := find_only Job(jobID = "Job_PersistentInvariant_Use");
        Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed though invariant associated with the wrong event: " & theJob.jobID);
      
        theCorrespondingSourceInvariants := theJob -> R10 -> R11 -> R23 -> R28 -> R24;
        for eachCorrespondingSourceInvariant in theCorrespondingSourceInvariants loop
          Assertions::assertTrue(eachCorrespondingSourceInvariant.inForce, "Extra Job Invariant is not in force: " & eachCorrespondingSourceInvariant.extraJobInvName);
        end loop;
      
        // ... and finally clear down all the existing instances of PersistedInvariant in readiness for other tests.
        thePersistedInvariants := find PersistedInvariant();
        for thePersistedInvariant in thePersistedInvariants loop
          thePersistedInvariant.deletePersistedInvariant();   
        end loop;
        
      end service;
      @endnoparse
    end function;

    @function_num(1);
    function Test60StalePersistedInvariant() is
      @noparse
      theJob : instance of Job;
      theJobs : set of instance of Job;
      theSequences : set of instance of Sequence;
      theAuditEvents : set of instance of AuditEvent;
      theAuditEventData : sequence of auditEventDataStructure;
      emptyAuditEventData : sequence of auditEventDataStructure;
      theUserInvariants : set of instance of TransientInvariant;
      thePersistedInvariants : set of instance of PersistedInvariant;
      thePersistedInvariant : instance of PersistedInvariant;
      theStaleSourceInvariants : set of instance of PersistedInvariant;
      theInForceSourceInvariants : set of instance of PersistedInvariant;
      theCorrespondingSourceInvariants : set of instance of PersistedInvariant;
      previousEvents : sequence of string;
      empty : sequence of string;
      logMessage : string;
      
      begin
       // This test initially creates 1 Auth Job with 2 persistentinvariant values being defined
        // This part of the test does not reveal any erroneous behaviour of the twin
        //
        previousEvents := empty;
        //theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeA", "Ent987654321");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920000","Auth-0001","EAuthoriserSendOrderRequest","Job_PersistentInvariant",previousEvents,"Ev1201",theAuditEventData);
        previousEvents := ("Ev1201");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","Auth-0001","EAuthReceiveRequest","Job_PersistentInvariant",previousEvents,"Ev1202",theAuditEventData);
        previousEvents := ("Ev1202");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920002","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1203",theAuditEventData);
        previousEvents := ("Ev1203");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920003","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1204",theAuditEventData);
        previousEvents := ("Ev1204");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920004","Auth-0001","EAuthSendMidRequest","Job_PersistentInvariant",previousEvents,"Ev1205",theAuditEventData);
        previousEvents := ("Ev1205");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","Auth-0001","EAuthReceiveMidResponse","Job_PersistentInvariant",previousEvents,"Ev1206",theAuditEventData);
        previousEvents := ("Ev1206");
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920006","Auth-0001","EAuthSendResponse","Job_PersistentInvariant",previousEvents,"Ev1207",theAuditEventData);
        previousEvents := ("Ev1207");
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920007","Auth-0001","EAuthoriserReceiveOrder","Job_PersistentInvariant",previousEvents,"Ev1208",theAuditEventData);
       
        // Process all the events on the event queue - at this point in the test Job_PersistentInvariant should 
        // have reached the 'AssessingSequenceCompletion' state
        Test::service_event_queue();
        
        // Fire the timer that waits for alternative branch events on Job_PersistentInvariant to arrive - and the job will proceed to constraint and 
        // invariant checking where it will pass all the invariant checks and proceed into the 'JobSuccessful' state.
        theJob := find_only Job(jobID = "Job_PersistentInvariant");
        Test::fire_timer(theJob.jobEventTimer);
        
        // Delete the Job that created the PersistentInvariant values but retain the persistentinvariant values as PersistedInvariants
        deleteJob ("Job_PersistentInvariant");
       
        // Check that the Persisted Invariants are still present and in force
        theInForceSourceInvariants := find PersistedInvariant(inForce = true);
        Assertions::assertTrue(theInForceSourceInvariants'length = 1, "Wrong number of source invariants in force: " & (theInForceSourceInvariants'length)'image);
      
        // Force the Persisted Invariants to reach their end of life and go stale
        for eachInForceSourceInvariant in theInForceSourceInvariants loop
          Test::fire_timer(eachInForceSourceInvariant.invariantTimer);
        end loop;  
        Test::service_event_queue();
        
        // Check the Persisted Invariants have gone stale
        theInForceSourceInvariants := find PersistedInvariant(inForce = true);
        Assertions::assertTrue(theInForceSourceInvariants'length = 0, "Wrong number of source invariants have timed out: " & (theInForceSourceInvariants'length)'image);
        theStaleSourceInvariants := find PersistedInvariant(inForce = false);
        Assertions::assertTrue(theStaleSourceInvariants'length = 1, "Wrong number of source invariants have timed out: " & (theStaleSourceInvariants'length)'image);
        
        // With the PersistentInvariants having gone stale now in place, this test now goes on to check that stale persistentinvariant attached to 
        // the correct events is spotted and the Job fails.
        // The following event sequence and persistentinvariant associations are valid. It fails simply because the persistentinvariant is stale and no longer in force
        // This test does reveal erroneous behaviour of the twin
        //
        // Bank Transfer Sequence
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920000","export-control-1234","ENearInput","Job_PersistentInvariant_Use","","Ev1",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920001","export-control-1234","ENearPartWrite","Job_PersistentInvariant_Use","Ev1","Ev2",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920002","export-control-1234","ENearJustificationWrite","Job_PersistentInvariant_Use","Ev2","Ev3",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920003","agent-1234","EAgentRequestWidgets","Job_PersistentInvariant_Use","Ev3","Ev4",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920004","authoriser-1234","EAuthoriserReadWidgetRequest","Job_PersistentInvariant_Use","Ev4","Ev5",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920005","authoriser-1234","EAuthoriserParsedJustification","Job_PersistentInvariant_Use","Ev5","Ev6",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920006","authoriser-1234","EAuthoriserSendWidgets","Job_PersistentInvariant_Use","Ev6","Ev7",theAuditEventData);
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920007","agent-1234","EAgentReceiveWidgets","Job_PersistentInvariant_Use","Ev7","Ev8",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920008","agent-1234","EAgentPartRead","Job_PersistentInvariant_Use","Ev8","Ev9",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920008","agent-1234","EAgentProcessedRequest","Job_PersistentInvariant_Use","Ev8","Ev9a",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920009","agent-1234","EAgentWritePayload","Job_PersistentInvariant_Use","Ev9","Ev10",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920010","gateway-1234","EGatewayReadPayload","Job_PersistentInvariant_Use","Ev10","Ev11",theAuditEventData);
        theAuditEventData := (aeDataKindEnum.EXTRAJOBINV, "PersistentInvariantTypeB", "Ent123456789");
        acceptOrderedEvent ("1620920011","gateway-1234","EGatewayWritePayload","Job_PersistentInvariant_Use","Ev11","Ev12",theAuditEventData);
        // Mid Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920012","mid-1234","EMidProcessPayload","Job_PersistentInvariant_Use","","Ev13",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920013","mid-1234","EMidWritePayload","Job_PersistentInvariant_Use","Ev13","Ev14",theAuditEventData);
        // Far Side Sequence - note first event of a sequence has no previous event id (penultimate parameter)
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920050","import_control-1234","EFarInput","Job_PersistentInvariant_Use","","Ev50",theAuditEventData);
        theAuditEventData := emptyAuditEventData;
        acceptOrderedEvent ("1620920055","import_control-1234","EFarOutput","Job_PersistentInvariant_Use","Ev50","Ev55",theAuditEventData);
      
        // Process all the events on the event queue - note that Job_PersistentInvariant_Use should be in the 'AssessingSequenceCompletion' state after this.
        Test::service_event_queue();
      
        // Fire the timer that waits for other branch events on Job_PersistentInvariant_Use to arrive - and the job will proceed to constraint and 
        // invariant checking where it will fail the invariant checks.
        theJob := find_only Job(jobID = "Job_PersistentInvariant_Use");
        Test::fire_timer(theJob.jobEventTimer);
       
        // Process all the events on the event queue - note that Job_PersistentInvariant_Use should be in the 'JobFailed' state after this because
        // the job will have failed the invariant checks.
        Test::service_event_queue();
        
        // Check the state of Job_PersistentInvariant_Use is as expected and that all Extra Job Invariants that it uses (aka carries) are not 'InForce'.
        Assertions::assertTrue(theJob.jobCompleted = false, "Job is completed though persisted invariant was no longer in force: " & theJob.jobID); 
        theCorrespondingSourceInvariants := theJob -> R10 -> R11 -> R23 -> R28 -> R24;
        for eachCorrespondingSourceInvariant in theCorrespondingSourceInvariants loop
          Assertions::assertTrue(eachCorrespondingSourceInvariant.inForce = false, "Extra Job Invariant is not in force: " & eachCorrespondingSourceInvariant.extraJobInvName);
        end loop;
        
        // ... and finally clear down all the existing instances of PersistedInvariant in readiness for other tests.
        for thePersistedInvariant in thePersistedInvariants loop
          thePersistedInvariant.deletePersistedInvariant();   
        end loop;
      end service;
      @endnoparse
    end function;

  end package;

end;
