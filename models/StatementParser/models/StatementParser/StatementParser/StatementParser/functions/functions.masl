//! ACTIVITY BEGIN. '1a0e7ecf-6e82-4bcb-b78f-7f6c004a2f00' DO NOT EDIT THIS LINE.
public service StatementParser::validateStatements ( jobId : in integer,
                                                    directory : in Filesystem::filename,
                                                    filename : in Filesystem::filename ) is
logMessage : string;
job : instance of Job;
sourceFile : instance of SequenceFile;
valid : boolean := true;
failureReason : string;
begin
	
	logMessage := "StatementParser::validateStatements";
	Logger::log(Logger::Information, "StatementParser", logMessage);
	
	if find_one Job(jobId = jobId) = null then
		if Filesystem::file_exists(directory & "/" & filename) then
		  job := create Job(jobId => jobId, occurrenceIdIncEnabled => false, currentOccurrenceId => 1, sequenceEnabled => false, Current_State => Created);
		  sourceFile := create SequenceFile(filename => filename, directory => directory, Current_State => Unprocessed);
		  sourceFile.lines := Strings::tokenize(Filesystem::read_file(directory & "/" & filename), '\n');
		  link sourceFile R17 job;
		  generate SequenceFile.ReadyToProcess() to sourceFile;
		else
		  valid := false;
		  failureReason := "Source file '" & string(directory) & "/" & string(filename) & "' does not exist";
		end if;
	else
		valid := false;
		failureReason := "Job already exists, jobId = " & jobId'image;
	end if;
	Consumer~>fileVerified(jobId, valid, failureReason);
exception
	when others =>
		Consumer~>fileVerified(jobId, false, "Unexpected error.");	
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'e3593a7b-cf61-47b0-9338-db05a77b7f81' DO NOT EDIT THIS LINE.
public service StatementParser::getJobAndApps ( jobId : in integer ) is
logMessage : string;
job : instance of Job;
jobNameGrammarItems : sequence of instance of GrammarItem;
jobNameGrammarItem : instance of GrammarItem;
jobName : string := "Unknown";
applicationNames : set of string;

begin
	
	logMessage := "StatementParser::getJobAndApps";
	Logger::log(Logger::Information, "StatementParser", logMessage);
	
	job := find_one Job(jobId = jobId);
	if job /= null then
		
		// find the job name
		jobNameGrammarItems := find (job -> R11.Line -> R5.GrammarItem)(grammarName = "jobName") reverse_ordered_by (lineId);
		jobNameGrammarItem := jobNameGrammarItems[jobNameGrammarItems'first];
		if jobNameGrammarItem /= null then
			jobName := jobNameGrammarItem.itemValue;
		end if;
		
		// find all the applications
		for application in find (job -> R11.Line -> R5.GrammarItem)(grammarName = "applicationName" or grammarName = "startEndName") loop
			applicationNames := applicationNames & application.itemValue;
		end loop;
		Consumer~>jobAndApps(jobId, jobName, applicationNames'elements);
	else
	end if;
	
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'fb17491f-10ad-4e92-8826-38ac86b156e8' DO NOT EDIT THIS LINE.
public service StatementParser::getNextStatement ( jobId : in integer ) is
logMessage : string;
job : instance of Job;
line : instance of Line;
grammarItems : sequence of instance of GrammarItem;
statementType : string := "";
controlType : string := "";
sequenceName : string := "";
applicationName : string := "";
eventName : string := "";
isStartEvent : boolean := false;
isEndEvent : boolean := false;
controlGrammarType : instance of GrammarType;
grammarItem : instance of GrammarItem;
allStatementsProcessed : boolean := true;
jobGrammarItems : sequence of instance of GrammarItem;
nextStatementType : instance of StatementType;

begin
	
	logMessage := "StatementParser::getNextStatement";
	Logger::log(Logger::Information, "StatementParser", logMessage);
	
	// find the job
	job := find_one Job(jobId = jobId);
	if job /= null then
		
		// find the next statement to process
		line := job -> R16.Line;
		if line = null then
			line := job -> R12.Line;
		else
			line := line -> R9.isFollowedBy.Line;
		end if;
		// unlink the job from the last line processed
		unlink job R16;
		jobGrammarItems := job -> R11.Line -> R5.GrammarItem;
		while line /= null loop
			// we only want to process sequences, events and controls statements
			grammarItems := line -> R5.GrammarItem;
			controlGrammarType := find_one (grammarItems -> R4.GrammarType)(grammarDefinitionType = GrammarDefinitionType.CONTROL);
			if controlGrammarType /= null then
				statementType := "CONTROL";
				grammarItem := find_one (grammarItems intersection (controlGrammarType -> R4.GrammarItem))();
				controlType := grammarItem.itemValue;
				link job R16 line;
				allStatementsProcessed := false;
				exit;
			elsif (line -> R2.StatementType) /= null and (line -> R2.StatementType).statementName = "autonumber start" or
			      (line -> R2.StatementType) /= null and (line -> R2.StatementType).statementName = "autonumber resume" then
				job.occurrenceIdIncEnabled := true;
			elsif (line -> R2.StatementType) /= null and (line -> R2.StatementType).statementName = "autonumber stop" then
				job.occurrenceIdIncEnabled := false;
				job.currentOccurrenceId := 1;
			elsif (line -> R2.StatementType) /= null and (line -> R2.StatementType).statementName = "start sequence definition" then
				statementType := "SEQUENCE";
				grammarItem := find_one grammarItems(grammarName = "sequenceName");
				sequenceName := grammarItem.itemValue;
				link job R16 line;
				allStatementsProcessed := false;
				job.sequenceEnabled := true;
				exit;
			elsif (line -> R2.StatementType) /= null and (line -> R2.StatementType).statementName = "end sequence definition" then
				job.sequenceEnabled := false;
			elsif find_one (line -> R5.GrammarItem)(itemValue = "->") /= null then
				isStartEvent := false;
				isEndEvent := false;
				statementType := "EVENT";
				grammarItem := find_one grammarItems(grammarName = "sendingApplication");
				applicationName := grammarItem.itemValue;
				grammarItem := find_one grammarItems(grammarName = "eventName");
				eventName := grammarItem.itemValue;
				link job R16 line;
				allStatementsProcessed := false;
				// check if this is a starting or ending event
				if find_one jobGrammarItems(itemValue = applicationName and grammarName = "startEndName") /= null then
					isStartEvent := true;
					job.sequenceEnabled := false;
				elsif job.sequenceEnabled = true then
					isStartEvent := true;
					job.sequenceEnabled := false;
				end if;
				grammarItem := find_one grammarItems(grammarName = "receivingApplication");
				if find_one jobGrammarItems(itemValue = grammarItem.itemValue and grammarName = "startEndName") /= null then
					isEndEvent := true;
				else
					// If the next statement is an end box then we have to assume that this is a end event as end box marks the end of the sequence
					nextStatementType := line -> R9.isFollowedBy.Line -> R2.StatementType;
					if nextStatementType /= null and nextStatementType.statementName = "end sequence definition" then
						isEndEvent := true;
					end if;
				end if;
				exit;
			end if;
			line := line -> R9.isFollowedBy.Line;
		end loop;		
		
	end if;
	
	Consumer~>nextStatement(statementType, sequenceName, applicationName, controlType, eventName, isStartEvent, isEndEvent, job.currentOccurrenceId, jobId, allStatementsProcessed);
	if job.occurrenceIdIncEnabled = true then
		job.currentOccurrenceId := job.currentOccurrenceId + 1;
	end if;
	
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

