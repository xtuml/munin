//! ACTIVITY BEGIN. '1a0e7ecf-6e82-4bcb-b78f-7f6c004a2f00' DO NOT EDIT THIS LINE.
public service StatementParser::validateStatements ( jobId : in integer,
                                                    plusStatements : in string ) is
logMessage : string;
seperator : character := '\n';
line : instance of Line;
lineToken : instance of LineToken;
prevLine : instance of Line;
prevLineToken : instance of LineToken;
job : instance of Job;
pos : integer := -1;
endPos : integer := -1;
tmpLineText : string;
tmpToken : string;
valid : boolean := true;
failureReason : string;
tmp : integer;

begin
	
	logMessage := "StatementParser::validateStatements";
	Logger::log(Logger::Information, "StatementParser", logMessage);
	
	if find_one Job(jobId = jobId) = null then
		job := create Job(jobId => jobId, plusStatements => plusStatements, occurrenceIdIncEnabled => false, currentOccurrenceId => 1, sequenceEnabled => false);
		
		for lineText in Strings::tokenize(plusStatements, seperator) loop
			if (Strings::trim(lineText))'length > 0 then 
				line := create unique Line(lineText => lineText);
				if job -> R12.Line = null then
					link job R12 line;
				end if;
				link job R11 line;
				
				// before extracting the tokens remove any directive contained in [] e.g., [#Red]
				if Strings::contains(line.lineText, "[") then
					tmpLineText := line.lineText;
					pos := Strings::search_first(tmpLineText, "[");
					while pos /= 0 loop
						endPos := Strings::search_first(tmpLineText, "]");
						if endPos /= 0 then
							line.lineText := tmpLineText[tmpLineText'first .. pos - 1];
							line.lineText := line.lineText & tmpLineText[endPos + 1 .. tmpLineText'last];
						else
							exit;
						end if;
						tmpLineText := line.lineText;
						pos := Strings::search_next(tmpLineText, "[", endPos);
					end loop;
				end if;
				
				// before extracting the tokens check for "end " and if it is then remove the space
				if Strings::contains(line.lineText, "end ") then
					tmpLineText := Strings::trim_leading(line.lineText);
					line.lineText := Strings::erase_first(tmpLineText, " ");
				end if;
				if Strings::contains(line.lineText, "autonumber ") then
					tmpLineText := Strings::trim_leading(line.lineText);
					line.lineText := Strings::erase_first(tmpLineText, " ");
				end if;
				// if this is an event indicated by "->" ensure that all the tokens on the line have a space prior to tokenizing the line
				pos := Strings::search_first(line.lineText, "->");
				if pos /= 0 then
					tmpLineText := line.lineText;
					line.lineText := tmpLineText[tmpLineText'first .. pos - 1] & " ";
					line.lineText := line.lineText & "-> " & tmpLineText[pos + 2 .. tmpLineText'last];
					pos := Strings::search_first(line.lineText, ":");
					if pos /= 0 then
						tmpLineText := line.lineText;
						line.lineText := line.lineText[line.lineText'first .. pos - 1] & " : " & tmpLineText[pos + 1 .. tmpLineText'last];
					end if;
				end if;
				
				for token in Strings::tokenize(line.lineText) loop
					// only process the token if it does not start with a # as the # indicates a display directive
					tmpToken := Strings::squeeze(token);
					if Strings::contains(tmpToken, ".") then
						tmpToken := Strings::erase_all(tmpToken, ".");
					end if;
					if Strings::contains(tmpToken, "\"") then
						tmpToken := Strings::erase_all(tmpToken, "\"");
					end if;
					if token[tmpToken'first] /= '#' then
						lineToken := create unique LineToken(token => tmpToken);
						link lineToken R1 line;
						if line -> R13.LineToken = null then
							link line R13 lineToken;
						end if;
						if prevLineToken /= null then
							link lineToken R10.follows prevLineToken;
						end if;
						prevLineToken := lineToken;
					end if;
				end loop;
				if prevLine /= null then
					link line R9.follows prevLine;
				end if;
				prevLine := line;
			end if;
		end loop;
		
		// iterate over the lines and identify the valid statements
		line := job -> R12.Line;
		while valid and line /= null loop
			line.processLine(valid, failureReason);
			exit when valid = false;
			line := line -> R9.isFollowedBy.Line;
		end loop;
		
		// verify that the job name has been defined
		if valid = true and find_one (job -> R11.Line -> R5.GrammarItem)(grammarName = "jobName") = null then
			valid := false;
			failureReason := "No job name defined, jobId = " & jobId'image;
		end if;
		
	else
		valid := false;
		failureReason := "Job already exists, jobId = " & jobId'image;
	end if;
	Consumer~>fileVerified(jobId, valid, failureReason);
exception
	when others =>
		Consumer~>fileVerified(jobId, false, "Unexpected error.");	
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'e3593a7b-cf61-47b0-9338-db05a77b7f81' DO NOT EDIT THIS LINE.
public service StatementParser::getJobAndApps ( jobId : in integer ) is
logMessage : string;
job : instance of Job;
jobNameGrammarItem : instance of GrammarItem;
jobName : string := "Unknown";
applicationNames : sequence of string;

begin
	
	logMessage := "StatementParser::getJobAndApps";
	Logger::log(Logger::Information, "StatementParser", logMessage);
	
	job := find_one Job(jobId = jobId);
	if job /= null then
		
		// find the job name
		jobNameGrammarItem := find_one (job -> R11.Line -> R5.GrammarItem)(grammarName = "jobName");
		if jobNameGrammarItem /= null then
			jobName := jobNameGrammarItem.itemValue;
		end if;
		
		// find all the applications
		for application in find (job -> R11.Line -> R5.GrammarItem)(grammarName = "applicationName" or grammarName = "startEndName") loop
			applicationNames := applicationNames & application.itemValue;
		end loop;
		Consumer~>jobAndApps(jobId, jobName, applicationNames);
	else
	end if;
	
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. 'fb17491f-10ad-4e92-8826-38ac86b156e8' DO NOT EDIT THIS LINE.
public service StatementParser::getNextStatement ( jobId : in integer ) is
logMessage : string;
job : instance of Job;
line : instance of Line;
grammarItems : sequence of instance of GrammarItem;
statementType : string := "";
controlType : string := "";
sequenceName : string := "";
applicationName : string := "";
eventName : string := "";
isStartEvent : boolean := false;
isEndEvent : boolean := false;
controlGrammarType : instance of GrammarType;
grammarItem : instance of GrammarItem;
allStatementsProcessed : boolean := true;
jobGrammarItems : sequence of instance of GrammarItem;
nextStatementType : instance of StatementType;

begin
	
	logMessage := "StatementParser::getNextStatement";
	Logger::log(Logger::Information, "StatementParser", logMessage);
	
	// find the job
	job := find_one Job(jobId = jobId);
	if job /= null then
		
		// find the next statement to process
		line := job -> R16.Line;
		if line = null then
			line := job -> R12.Line;
		else
			line := line -> R9.isFollowedBy.Line;
		end if;
		// unlink the job from the last line processed
		unlink job R16;
		jobGrammarItems := job -> R11.Line -> R5.GrammarItem;
		while line /= null loop
			// we only want to process sequences, events and controls statements
			grammarItems := line -> R5.GrammarItem;
			controlGrammarType := find_one (grammarItems -> R4.GrammarType)(grammarDefinitionType = GrammarDefinitionType.CONTROL);
			if controlGrammarType /= null then
				statementType := "CONTROL";
				grammarItem := find_one (grammarItems intersection (controlGrammarType -> R4.GrammarItem))();
				controlType := grammarItem.itemValue;
				link job R16 line;
				allStatementsProcessed := false;
				exit;
			elsif (line -> R2.StatementType) /= null and (line -> R2.StatementType).statementName = "autonumber start" or
			      (line -> R2.StatementType) /= null and (line -> R2.StatementType).statementName = "autonumber resume" then
				job.occurrenceIdIncEnabled := true;
			elsif (line -> R2.StatementType) /= null and (line -> R2.StatementType).statementName = "autonumber stop" then
				job.occurrenceIdIncEnabled := false;
				job.currentOccurrenceId := 1;
			elsif (line -> R2.StatementType) /= null and (line -> R2.StatementType).statementName = "start sequence definition" then
				statementType := "SEQUENCE";
				grammarItem := find_one grammarItems(grammarName = "sequenceName");
				sequenceName := grammarItem.itemValue;
				link job R16 line;
				allStatementsProcessed := false;
				job.sequenceEnabled := true;
				exit;
			elsif (line -> R2.StatementType) /= null and (line -> R2.StatementType).statementName = "end sequence definition" then
				job.sequenceEnabled := false;
			elsif find_one (line -> R5.GrammarItem)(itemValue = "->") /= null then
				isStartEvent := false;
				isEndEvent := false;
				statementType := "EVENT";
				grammarItem := find_one grammarItems(grammarName = "sendingApplication");
				applicationName := grammarItem.itemValue;
				grammarItem := find_one grammarItems(grammarName = "eventName");
				eventName := grammarItem.itemValue;
				link job R16 line;
				allStatementsProcessed := false;
				// check if this is a starting or ending event
				if find_one jobGrammarItems(itemValue = applicationName and grammarName = "startEndName") /= null then
					isStartEvent := true;
					job.sequenceEnabled := false;
				elsif job.sequenceEnabled = true then
					isStartEvent := true;
					job.sequenceEnabled := false;
				end if;
				grammarItem := find_one grammarItems(grammarName = "receivingApplication");
				if find_one jobGrammarItems(itemValue = grammarItem.itemValue and grammarName = "startEndName") /= null then
					isEndEvent := true;
				else
					// If the next statement is an end box then we have to assume that this is a end event as end box marks the end of the sequence
					nextStatementType := line -> R9.isFollowedBy.Line -> R2.StatementType;
					if nextStatementType /= null and nextStatementType.statementName = "end sequence definition" then
						isEndEvent := true;
					end if;
				end if;
				exit;
			end if;
			line := line -> R9.isFollowedBy.Line;
		end loop;		
		
	end if;
	
	Consumer~>nextStatement(statementType, sequenceName, applicationName, controlType, eventName, isStartEvent, isEndEvent, job.currentOccurrenceId, jobId, allStatementsProcessed);
	if job.occurrenceIdIncEnabled = true then
		job.currentOccurrenceId := job.currentOccurrenceId + 1;
	end if;
	
end service;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

