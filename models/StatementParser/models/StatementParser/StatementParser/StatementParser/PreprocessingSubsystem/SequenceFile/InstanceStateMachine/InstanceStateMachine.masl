//! ACTIVITY BEGIN. '4fbea97b-e551-494d-bbc2-634a431d327c' '7764fb41-b34b-47e4-b545-c1bf03be47c6' DO NOT EDIT THIS LINE.
state StatementParser::SequenceFile.Unprocessed () is
begin
  null;
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '4fbea97b-e551-494d-bbc2-634a431d327c' '8cefb9b9-105c-44c6-80c1-a4710c1fd7f4' DO NOT EDIT THIS LINE.
state StatementParser::SequenceFile.Loaded () is
line: string;
sourceFilename: Filesystem::filename;
blockId: string;
tokens: sequence of string;
currentBlock: instance of UMLBlock;
includeStatement: instance of IncludeStatement;
sourceFile: instance of SequenceFile;
begin

  // populate UML blocks from lines in file
  // create reference dependencies. Note: this implementation does not check for cycles
  for lineNum in this.lines'range loop
    line := Strings::squeeze(this.lines[lineNum]);
    if Strings::starts_with(line, "@startuml") then
      if Strings::contains(line, "id=") or Strings::contains(line, "id =") then
        tokens := Strings::tokenize(line, "(=)");
        blockId := Strings::trim(tokens[tokens'first + 2]);
      else
        blockId := "default";
      end if;
      currentBlock := create UMLBlock(filename => this.filename, id => blockId, startLine => lineNum + 1);
      link currentBlock R101 this;
    elsif Strings::starts_with(line, "@enduml") then
      currentBlock.endLine := lineNum - 1;
    elsif Strings::starts_with(line, "!include") then
      tokens := Strings::tokenize(line, "! \t\f\n\r");
      sourceFilename := Filesystem::filename(tokens[tokens'first + 1]);
      blockId := tokens[tokens'first + 2];
      if find_one (this -> R102.IncludeStatement)(sourceFilename = sourceFilename and blockId = blockId) = null then
        includeStatement := create IncludeStatement(filename => this.filename, sourceFilename => sourceFilename, blockId => blockId, lineNum => lineNum);
        link includeStatement R102 this;
        sourceFile := find_one SequenceFile(filename = sourceFilename);
        if sourceFile = null then
          sourceFile := create SequenceFile(filename => sourceFilename, directory => this.directory, Current_State => Unprocessed);
          if Filesystem::file_exists(this.directory & "/" & sourceFilename) then
            sourceFile.lines := Strings::tokenize(Filesystem::read_file(this.directory & "/" & sourceFilename), '\n');
            generate SequenceFile.ReadyToProcess() to sourceFile;
          else
            Logger::log(Logger::Error, "StatementParser", "Source file '" & string(this.directory) & "/" & string(sourceFilename) & "' does not exist");
            raise program_error;
          end if;
        end if;
        link sourceFile R103 includeStatement;
      end if;
    end if;
  end loop;
  
  generate SequenceFile.CheckDependencies() to this;
  
end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '4fbea97b-e551-494d-bbc2-634a431d327c' 'b5351117-59c0-45e2-a004-175fe06c8b04' DO NOT EDIT THIS LINE.
state StatementParser::SequenceFile.WaitingForDependencies () is
umlBlock: instance of UMLBlock;
begin

  // for each dependency, check if it is processed and pull in the statements
  for dependency in this -> R102.IncludeStatement loop
    // only process dependencies that are fully processed themselves
    if (dependency -> R103.SequenceFile).processed then
      // get the referenced UML block from the source file
      umlBlock := find_one (dependency -> R103.SequenceFile -> R101.UMLBlock) (id = dependency.blockId);
      if umlBlock /= null then
        // inject the referred to lines
        this.lines := this.lines[this.lines'first .. dependency.lineNum - 1] & umlBlock.getLines() & this.lines[dependency.lineNum + 1 .. this.lines'last];
        // delete the dependency
        unlink dependency R102;
        unlink dependency R103;
        delete dependency;
      else
        Logger::log(Logger::Error, "StatementParser", "Source file '" & string(dependency.sourceFilename) & "' does not define block with ID '" & dependency.blockId & "'");
        raise program_error;
      end if;
    end if;
  end loop;
  
  // if there are no more dependencies, this file is done processing
  if (this -> R102.IncludeStatement)'length = 0 then
    generate SequenceFile.ProcessingComplete() to this;
  end if;

end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

//! ACTIVITY BEGIN. '4fbea97b-e551-494d-bbc2-634a431d327c' 'fd64e080-6802-4e74-b2a7-2c028f7be10a' DO NOT EDIT THIS LINE.
state StatementParser::SequenceFile.Processed () is
begin

  this.processed := true;

  // signal processing complete to all referring files
  for referencingFile in this -> R103.IncludeStatement -> R102.SequenceFile loop
    generate SequenceFile.CheckDependencies() to referencingFile;
  end loop;

  // signal processing complete to job (if applicable)
  if this -> R17.Job /= null then
    generate Job.FilePreprocessComplete() to (this -> R17.Job);
  end if;

end state;
//! ACTIVITY END. DO NOT EDIT THIS LINE.

